import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/@highcharts/dashboards/datagrid.js
var require_datagrid = __commonJS({
  "node_modules/@highcharts/dashboards/datagrid.js"(exports, module) {
    !/**
    * Highcharts Dashboards v2.0.0 (2024-03-13)
    *
    * (c) 2009-2024 Highsoft AS
    *
    * License: www.highcharts.com/license
    */
    function(e, t) {
      "object" == typeof module && module.exports ? (t.default = t, module.exports = e && e.document ? t(e) : t) : "function" == typeof define && define.amd ? define("datagrid/datagrid", function() {
        return t(e);
      }) : (e.DataGrid && e.DataGrid.error(16, true), e.DataGrid = t(e));
    }("undefined" != typeof window ? window : exports, function(e) {
      "use strict";
      var t = {};
      function i(t2, i2, s, n) {
        t2.hasOwnProperty(i2) || (t2[i2] = n.apply(null, s), "function" == typeof CustomEvent && e.dispatchEvent(new CustomEvent("DataGridModuleLoaded", { detail: { path: i2, module: t2[i2] } })));
      }
      return i(t, "Core/Globals.js", [], function() {
        var t2, i2;
        return (i2 = t2 || (t2 = {})).SVG_NS = "http://www.w3.org/2000/svg", i2.product = "Highcharts", i2.version = "2.0.0", i2.win = void 0 !== e ? e : {}, i2.doc = i2.win.document, i2.svg = i2.doc && i2.doc.createElementNS && !!i2.doc.createElementNS(i2.SVG_NS, "svg").createSVGRect, i2.userAgent = i2.win.navigator && i2.win.navigator.userAgent || "", i2.isChrome = -1 !== i2.userAgent.indexOf("Chrome"), i2.isFirefox = -1 !== i2.userAgent.indexOf("Firefox"), i2.isMS = /(edge|msie|trident)/i.test(i2.userAgent) && !i2.win.opera, i2.isSafari = !i2.isChrome && -1 !== i2.userAgent.indexOf("Safari"), i2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(i2.userAgent), i2.isWebKit = -1 !== i2.userAgent.indexOf("AppleWebKit"), i2.deg2rad = 2 * Math.PI / 360, i2.hasBidiBug = i2.isFirefox && 4 > parseInt(i2.userAgent.split("Firefox/")[1], 10), i2.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], i2.noop = function() {
        }, i2.supportsPassiveEvents = function() {
          let e2 = false;
          if (!i2.isMS) {
            let t3 = Object.defineProperty({}, "passive", { get: function() {
              e2 = true;
            } });
            i2.win.addEventListener && i2.win.removeEventListener && (i2.win.addEventListener("testPassive", i2.noop, t3), i2.win.removeEventListener("testPassive", i2.noop, t3));
          }
          return e2;
        }(), i2.charts = [], i2.composed = [], i2.dateFormats = {}, i2.seriesTypes = {}, i2.symbolSizes = {}, i2.chartCount = 0, t2;
      }), i(t, "Core/Utilities.js", [t["Core/Globals.js"]], function(e2) {
        let t2;
        let { charts: i2, doc: s, win: n } = e2;
        function o(t3, i3, s2, r2) {
          let l2 = i3 ? "Highcharts error" : "Highcharts warning";
          32 === t3 && (t3 = `${l2}: Deprecated member`);
          let a2 = f(t3), h2 = a2 ? `${l2} #${t3}: www.highcharts.com/errors/${t3}/` : t3.toString();
          if (void 0 !== r2) {
            let e3 = "";
            a2 && (h2 += "?"), T(r2, function(t4, i4) {
              e3 += `
 - ${i4}: ${t4}`, a2 && (h2 += encodeURI(i4) + "=" + encodeURI(t4));
            }), h2 += e3;
          }
          R(e2, "displayError", { chart: s2, code: t3, message: h2, params: r2 }, function() {
            if (i3)
              throw Error(h2);
            n.console && -1 === o.messages.indexOf(h2) && console.warn(h2);
          }), o.messages.push(h2);
        }
        function r(e3, t3) {
          return parseInt(e3, t3 || 10);
        }
        function l(e3) {
          return "string" == typeof e3;
        }
        function a(e3) {
          let t3 = Object.prototype.toString.call(e3);
          return "[object Array]" === t3 || "[object Array Iterator]" === t3;
        }
        function h(e3, t3) {
          return !!e3 && "object" == typeof e3 && (!t3 || !a(e3));
        }
        function d(e3) {
          return h(e3) && "number" == typeof e3.nodeType;
        }
        function u(e3) {
          let t3 = e3 && e3.constructor;
          return !!(h(e3, true) && !d(e3) && t3 && t3.name && "Object" !== t3.name);
        }
        function f(e3) {
          return "number" == typeof e3 && !isNaN(e3) && e3 < 1 / 0 && e3 > -1 / 0;
        }
        function m(e3) {
          return null != e3;
        }
        function c(e3, t3, i3) {
          let s2;
          let n2 = l(t3) && !m(i3), o2 = (t4, i4) => {
            m(t4) ? e3.setAttribute(i4, t4) : n2 ? (s2 = e3.getAttribute(i4)) || "class" !== i4 || (s2 = e3.getAttribute(i4 + "Name")) : e3.removeAttribute(i4);
          };
          return l(t3) ? o2(i3, t3) : T(t3, o2), s2;
        }
        function p(e3) {
          return a(e3) ? e3 : [e3];
        }
        function g(e3, t3) {
          let i3;
          for (i3 in e3 || (e3 = {}), t3)
            e3[i3] = t3[i3];
          return e3;
        }
        function C() {
          let e3 = arguments, t3 = e3.length;
          for (let i3 = 0; i3 < t3; i3++) {
            let t4 = e3[i3];
            if (null != t4)
              return t4;
          }
        }
        function y(e3, t3) {
          g(e3.style, t3);
        }
        function b(e3) {
          return Math.pow(10, Math.floor(Math.log(e3) / Math.LN10));
        }
        function w(e3, t3) {
          return e3 > 1e14 ? e3 : parseFloat(e3.toPrecision(t3 || 14));
        }
        (o || (o = {})).messages = [], Math.easeInOutSine = function(e3) {
          return -0.5 * (Math.cos(Math.PI * e3) - 1);
        };
        let v = Array.prototype.find ? function(e3, t3) {
          return e3.find(t3);
        } : function(e3, t3) {
          let i3;
          let s2 = e3.length;
          for (i3 = 0; i3 < s2; i3++)
            if (t3(e3[i3], i3))
              return e3[i3];
        };
        function T(e3, t3, i3) {
          for (let s2 in e3)
            Object.hasOwnProperty.call(e3, s2) && t3.call(i3 || e3[s2], e3[s2], s2, e3);
        }
        function D(e3, t3, i3) {
          function s2(t4, i4) {
            let s3 = e3.removeEventListener;
            s3 && s3.call(e3, t4, i4, false);
          }
          function n2(i4) {
            let n3, o3;
            e3.nodeName && (t3 ? (n3 = {})[t3] = true : n3 = i4, T(n3, function(e4, t4) {
              if (i4[t4])
                for (o3 = i4[t4].length; o3--; )
                  s2(t4, i4[t4][o3].fn);
            }));
          }
          let o2 = "function" == typeof e3 && e3.prototype || e3;
          if (Object.hasOwnProperty.call(o2, "hcEvents")) {
            let e4 = o2.hcEvents;
            if (t3) {
              let o3 = e4[t3] || [];
              i3 ? (e4[t3] = o3.filter(function(e5) {
                return i3 !== e5.fn;
              }), s2(t3, i3)) : (n2(e4), e4[t3] = []);
            } else
              n2(e4), delete o2.hcEvents;
          }
        }
        function R(t3, i3, n2, o2) {
          if (n2 = n2 || {}, s.createEvent && (t3.dispatchEvent || t3.fireEvent && t3 !== e2)) {
            let e3 = s.createEvent("Events");
            e3.initEvent(i3, true, true), n2 = g(e3, n2), t3.dispatchEvent ? t3.dispatchEvent(n2) : t3.fireEvent(i3, n2);
          } else if (t3.hcEvents) {
            n2.target || g(n2, { preventDefault: function() {
              n2.defaultPrevented = true;
            }, target: t3, type: i3 });
            let e3 = [], s2 = t3, o3 = false;
            for (; s2.hcEvents; )
              Object.hasOwnProperty.call(s2, "hcEvents") && s2.hcEvents[i3] && (e3.length && (o3 = true), e3.unshift.apply(e3, s2.hcEvents[i3])), s2 = Object.getPrototypeOf(s2);
            o3 && e3.sort((e4, t4) => e4.order - t4.order), e3.forEach((e4) => {
              false === e4.fn.call(t3, n2) && n2.preventDefault();
            });
          }
          o2 && !n2.defaultPrevented && o2.call(t3, n2);
        }
        T({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function(t3, i3) {
          e2[i3] = function(e3) {
            return o(32, false, void 0, { [`Highcharts.${i3}`]: `use Array.${t3}` }), Array.prototype[t3].apply(e3, [].slice.call(arguments, 1));
          };
        });
        let x = function() {
          let e3 = Math.random().toString(36).substring(2, 9) + "-", i3 = 0;
          return function() {
            return "highcharts-" + (t2 ? "" : e3) + i3++;
          };
        }();
        return n.jQuery && (n.jQuery.fn.highcharts = function() {
          let t3 = [].slice.call(arguments);
          if (this[0])
            return t3[0] ? (new e2[l(t3[0]) ? t3.shift() : "Chart"](this[0], t3[0], t3[1]), this) : i2[c(this[0], "data-highcharts-chart")];
        }), { addEvent: function(t3, i3, s2, n2 = {}) {
          let o2 = "function" == typeof t3 && t3.prototype || t3;
          Object.hasOwnProperty.call(o2, "hcEvents") || (o2.hcEvents = {});
          let r2 = o2.hcEvents;
          e2.Point && t3 instanceof e2.Point && t3.series && t3.series.chart && (t3.series.chart.runTrackerClick = true);
          let l2 = t3.addEventListener;
          l2 && l2.call(t3, i3, s2, !!e2.supportsPassiveEvents && { passive: void 0 === n2.passive ? -1 !== i3.indexOf("touch") : n2.passive, capture: false }), r2[i3] || (r2[i3] = []);
          let a2 = { fn: s2, order: "number" == typeof n2.order ? n2.order : 1 / 0 };
          return r2[i3].push(a2), r2[i3].sort((e3, t4) => e3.order - t4.order), function() {
            D(t3, i3, s2);
          };
        }, arrayMax: function(e3) {
          let t3 = e3.length, i3 = e3[0];
          for (; t3--; )
            e3[t3] > i3 && (i3 = e3[t3]);
          return i3;
        }, arrayMin: function(e3) {
          let t3 = e3.length, i3 = e3[0];
          for (; t3--; )
            e3[t3] < i3 && (i3 = e3[t3]);
          return i3;
        }, attr: c, clamp: function(e3, t3, i3) {
          return e3 > t3 ? e3 < i3 ? e3 : i3 : t3;
        }, clearTimeout: function(e3) {
          m(e3) && clearTimeout(e3);
        }, correctFloat: w, createElement: function(e3, t3, i3, n2, o2) {
          let r2 = s.createElement(e3);
          return t3 && g(r2, t3), o2 && y(r2, { padding: "0", border: "none", margin: "0" }), i3 && y(r2, i3), n2 && n2.appendChild(r2), r2;
        }, css: y, defined: m, destroyObjectProperties: function(e3, t3, i3) {
          T(e3, function(s2, n2) {
            s2 !== t3 && (s2 == null ? void 0 : s2.destroy) && s2.destroy(), ((s2 == null ? void 0 : s2.destroy) || !i3) && delete e3[n2];
          });
        }, diffObjects: function(e3, t3, i3, s2) {
          let n2 = {};
          return function e4(t4, n3, o2, r2) {
            let l2 = i3 ? n3 : t4;
            T(t4, function(i4, d2) {
              if (!r2 && s2 && s2.indexOf(d2) > -1 && n3[d2]) {
                i4 = p(i4), o2[d2] = [];
                for (let t5 = 0; t5 < Math.max(i4.length, n3[d2].length); t5++)
                  n3[d2][t5] && (void 0 === i4[t5] ? o2[d2][t5] = n3[d2][t5] : (o2[d2][t5] = {}, e4(i4[t5], n3[d2][t5], o2[d2][t5], r2 + 1)));
              } else
                h(i4, true) && !i4.nodeType ? (o2[d2] = a(i4) ? [] : {}, e4(i4, n3[d2] || {}, o2[d2], r2 + 1), 0 !== Object.keys(o2[d2]).length || "colorAxis" === d2 && 0 === r2 || delete o2[d2]) : (t4[d2] !== n3[d2] || d2 in t4 && !(d2 in n3)) && "__proto__" !== d2 && "constructor" !== d2 && (o2[d2] = l2[d2]);
            });
          }(e3, t3, n2, 0), n2;
        }, discardElement: function(e3) {
          e3 && e3.parentElement && e3.parentElement.removeChild(e3);
        }, erase: function(e3, t3) {
          let i3 = e3.length;
          for (; i3--; )
            if (e3[i3] === t3) {
              e3.splice(i3, 1);
              break;
            }
        }, error: o, extend: g, extendClass: function(e3, t3) {
          let i3 = function() {
          };
          return i3.prototype = new e3(), g(i3.prototype, t3), i3;
        }, find: v, fireEvent: R, getClosestDistance: function(e3, t3) {
          let i3, s2, n2, o2;
          let r2 = !t3;
          return e3.forEach((e4) => {
            if (e4.length > 1)
              for (o2 = s2 = e4.length - 1; o2 > 0; o2--)
                (n2 = e4[o2] - e4[o2 - 1]) < 0 && !r2 ? (t3 == null ? void 0 : t3(), t3 = void 0) : n2 && (void 0 === i3 || n2 < i3) && (i3 = n2);
          }), i3;
        }, getMagnitude: b, getNestedProperty: function(e3, t3) {
          let i3 = e3.split(".");
          for (; i3.length && m(t3); ) {
            let e4 = i3.shift();
            if (void 0 === e4 || "__proto__" === e4)
              return;
            if ("this" === e4) {
              let e5;
              return h(t3) && (e5 = t3["@this"]), e5 ?? t3;
            }
            let s2 = t3[e4];
            if (!m(s2) || "function" == typeof s2 || "number" == typeof s2.nodeType || s2 === n)
              return;
            t3 = s2;
          }
          return t3;
        }, getStyle: function e3(t3, i3, s2) {
          let o2;
          if ("width" === i3) {
            let i4 = Math.min(t3.offsetWidth, t3.scrollWidth), s3 = t3.getBoundingClientRect && t3.getBoundingClientRect().width;
            return s3 < i4 && s3 >= i4 - 1 && (i4 = Math.floor(s3)), Math.max(0, i4 - (e3(t3, "padding-left", true) || 0) - (e3(t3, "padding-right", true) || 0));
          }
          if ("height" === i3)
            return Math.max(0, Math.min(t3.offsetHeight, t3.scrollHeight) - (e3(t3, "padding-top", true) || 0) - (e3(t3, "padding-bottom", true) || 0));
          let l2 = n.getComputedStyle(t3, void 0);
          return l2 && (o2 = l2.getPropertyValue(i3), C(s2, "opacity" !== i3) && (o2 = r(o2))), o2;
        }, inArray: function(e3, t3, i3) {
          return o(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" }), t3.indexOf(e3, i3);
        }, insertItem: function(e3, t3) {
          let i3;
          let s2 = e3.options.index, n2 = t3.length;
          for (i3 = e3.options.isInternal ? n2 : 0; i3 < n2 + 1; i3++)
            if (!t3[i3] || f(s2) && s2 < C(t3[i3].options.index, t3[i3]._i) || t3[i3].options.isInternal) {
              t3.splice(i3, 0, e3);
              break;
            }
          return i3;
        }, isArray: a, isClass: u, isDOMElement: d, isFunction: function(e3) {
          return "function" == typeof e3;
        }, isNumber: f, isObject: h, isString: l, keys: function(e3) {
          return o(32, false, void 0, { "Highcharts.keys": "use Object.keys" }), Object.keys(e3);
        }, merge: function() {
          let e3, t3 = arguments, i3 = {}, s2 = function(e4, t4) {
            return "object" != typeof e4 && (e4 = {}), T(t4, function(i4, n3) {
              "__proto__" !== n3 && "constructor" !== n3 && (!h(i4, true) || u(i4) || d(i4) ? e4[n3] = t4[n3] : e4[n3] = s2(e4[n3] || {}, i4));
            }), e4;
          };
          true === t3[0] && (i3 = t3[1], t3 = Array.prototype.slice.call(t3, 2));
          let n2 = t3.length;
          for (e3 = 0; e3 < n2; e3++)
            i3 = s2(i3, t3[e3]);
          return i3;
        }, normalizeTickInterval: function(e3, t3, i3, s2, n2) {
          let o2, r2 = e3;
          i3 = C(i3, b(e3));
          let l2 = e3 / i3;
          for (!t3 && (t3 = n2 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === s2 && (1 === i3 ? t3 = t3.filter(function(e4) {
            return e4 % 1 == 0;
          }) : i3 <= 0.1 && (t3 = [1 / i3]))), o2 = 0; o2 < t3.length && (r2 = t3[o2], (!n2 || !(r2 * i3 >= e3)) && (n2 || !(l2 <= (t3[o2] + (t3[o2 + 1] || t3[o2])) / 2))); o2++)
            ;
          return w(r2 * i3, -Math.round(Math.log(1e-3) / Math.LN10));
        }, objectEach: T, offset: function(e3) {
          let t3 = s.documentElement, i3 = e3.parentElement || e3.parentNode ? e3.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
          return { top: i3.top + (n.pageYOffset || t3.scrollTop) - (t3.clientTop || 0), left: i3.left + (n.pageXOffset || t3.scrollLeft) - (t3.clientLeft || 0), width: i3.width, height: i3.height };
        }, pad: function(e3, t3, i3) {
          return Array((t3 || 2) + 1 - String(e3).replace("-", "").length).join(i3 || "0") + e3;
        }, pick: C, pInt: r, pushUnique: function(e3, t3) {
          return 0 > e3.indexOf(t3) && !!e3.push(t3);
        }, relativeLength: function(e3, t3, i3) {
          return /%$/.test(e3) ? t3 * parseFloat(e3) / 100 + (i3 || 0) : parseFloat(e3);
        }, removeEvent: D, replaceNested: function(e3, ...t3) {
          let i3, s2;
          do
            for (s2 of (i3 = e3, t3))
              e3 = e3.replace(s2[0], s2[1]);
          while (e3 !== i3);
          return e3;
        }, splat: p, stableSort: function(e3, t3) {
          let i3, s2;
          let n2 = e3.length;
          for (s2 = 0; s2 < n2; s2++)
            e3[s2].safeI = s2;
          for (e3.sort(function(e4, s3) {
            return 0 === (i3 = t3(e4, s3)) ? e4.safeI - s3.safeI : i3;
          }), s2 = 0; s2 < n2; s2++)
            delete e3[s2].safeI;
        }, syncTimeout: function(e3, t3, i3) {
          return t3 > 0 ? setTimeout(e3, t3, i3) : (e3.call(0, i3), -1);
        }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, uniqueKey: x, useSerialIds: function(e3) {
          return t2 = C(e3, t2);
        }, wrap: function(e3, t3, i3) {
          let s2 = e3[t3];
          e3[t3] = function() {
            let e4 = arguments, t4 = this;
            return i3.apply(this, [function() {
              return s2.apply(t4, arguments.length ? arguments : e4);
            }].concat([].slice.call(arguments)));
          };
        } };
      }), i(t, "Data/Modifiers/DataModifier.js", [t["Core/Utilities.js"]], function(t2) {
        var i2;
        let { addEvent: s, fireEvent: n, merge: o } = t2;
        class r {
          benchmark(t3, i3) {
            let s2 = [], n2 = this, r2 = () => {
              n2.modifyTable(t3), n2.emit({ type: "afterBenchmarkIteration" });
            }, { iterations: l } = o({ iterations: 1 }, i3);
            n2.on("afterBenchmarkIteration", () => {
              if (s2.length === l) {
                n2.emit({ type: "afterBenchmark", results: s2 });
                return;
              }
              r2();
            });
            let a = { startTime: 0, endTime: 0 };
            return n2.on("modify", () => {
              a.startTime = e.performance.now();
            }), n2.on("afterModify", () => {
              a.endTime = e.performance.now(), s2.push(a.endTime - a.startTime);
            }), r2(), s2;
          }
          emit(e2) {
            n(this, e2.type, e2);
          }
          modify(e2, t3) {
            let i3 = this;
            return new Promise((s2, n2) => {
              e2.modified === e2 && (e2.modified = e2.clone(false, t3));
              try {
                s2(i3.modifyTable(e2, t3));
              } catch (s3) {
                i3.emit({ type: "error", detail: t3, table: e2 }), n2(s3);
              }
            });
          }
          modifyCell(e2, t3, i3, s2, n2) {
            return this.modifyTable(e2);
          }
          modifyColumns(e2, t3, i3, s2) {
            return this.modifyTable(e2);
          }
          modifyRows(e2, t3, i3, s2) {
            return this.modifyTable(e2);
          }
          on(e2, t3) {
            return s(this, e2, t3);
          }
        }
        return (i2 = r || (r = {})).types = {}, i2.registerType = function(e2, t3) {
          return !!e2 && !i2.types[e2] && !!(i2.types[e2] = t3);
        }, r;
      }), i(t, "Data/DataTable.js", [t["Core/Utilities.js"]], function(e2) {
        let { addEvent: t2, fireEvent: i2, uniqueKey: s } = e2;
        class n {
          static isNull(e3) {
            if (e3 === n.NULL)
              return true;
            if (e3 instanceof Array) {
              if (!e3.length)
                return false;
              for (let t3 = 0, i3 = e3.length; t3 < i3; ++t3)
                if (null !== e3[t3])
                  return false;
            } else {
              let t3 = Object.keys(e3);
              if (!t3.length)
                return false;
              for (let i3 = 0, s2 = t3.length; i3 < s2; ++i3)
                if (null !== e3[t3[i3]])
                  return false;
            }
            return true;
          }
          constructor(e3 = {}) {
            this.aliases = e3.aliases ? JSON.parse(JSON.stringify(e3.aliases)) : {}, this.autoId = !e3.id, this.columns = {}, this.id = e3.id || s(), this.modified = this, this.rowCount = 0, this.versionTag = s();
            let t3 = e3.columns || {}, i3 = Object.keys(t3), n2 = this.columns, o = 0;
            for (let e4 = 0, s2 = i3.length, r2, l2; e4 < s2; ++e4)
              r2 = t3[l2 = i3[e4]].slice(), n2[l2] = r2, o = Math.max(o, r2.length);
            for (let e4 = 0, t4 = i3.length; e4 < t4; ++e4)
              n2[i3[e4]].length = o;
            this.rowCount = o;
            let r = e3.aliases || {}, l = Object.keys(r), a = this.aliases;
            for (let e4 = 0, t4 = l.length, i4; e4 < t4; ++e4)
              a[i4 = l[e4]] = r[i4];
          }
          clone(e3, t3) {
            let i3 = {};
            this.emit({ type: "cloneTable", detail: t3 }), e3 || (i3.aliases = this.aliases, i3.columns = this.columns), this.autoId || (i3.id = this.id);
            let s2 = new n(i3);
            return e3 || (s2.versionTag = this.versionTag), this.emit({ type: "afterCloneTable", detail: t3, tableClone: s2 }), s2;
          }
          deleteColumnAlias(e3) {
            let t3 = this.aliases[e3], i3 = this.modifier;
            return t3 && (delete this.aliases[e3], i3 && i3.modifyColumns(this, { [t3]: Array(this.rowCount) }, 0)), t3;
          }
          deleteColumns(e3, t3) {
            let i3 = this.columns, s2 = {}, n2 = {}, o = this.modifier, r = this.rowCount;
            if ((e3 = e3 || Object.keys(i3)).length) {
              this.emit({ type: "deleteColumns", columnNames: e3, detail: t3 });
              for (let t4 = 0, o2 = e3.length, l, a; t4 < o2; ++t4)
                (l = i3[a = e3[t4]]) && (s2[a] = l, n2[a] = Array(r)), delete i3[a];
              return Object.keys(i3).length || (this.rowCount = 0), o && o.modifyColumns(this, n2, 0, t3), this.emit({ type: "afterDeleteColumns", columns: s2, columnNames: e3, detail: t3 }), s2;
            }
          }
          deleteRows(e3, t3 = 1, i3) {
            let s2 = [], n2 = [], o = this.modifier;
            if (this.emit({ type: "deleteRows", detail: i3, rowCount: t3, rowIndex: e3 || 0 }), void 0 === e3 && (e3 = 0, t3 = this.rowCount), t3 > 0 && e3 < this.rowCount) {
              let i4 = this.columns, o2 = Object.keys(i4);
              for (let r = 0, l = o2.length, a, h; r < l; ++r) {
                h = (a = i4[o2[r]]).splice(e3, t3), r || (this.rowCount = a.length);
                for (let e4 = 0, t4 = h.length; e4 < t4; ++e4)
                  s2[e4] = s2[e4] || [], s2[e4][r] = h[e4];
                n2.push(Array(l));
              }
            }
            return o && o.modifyRows(this, n2, e3 || 0, i3), this.emit({ type: "afterDeleteRows", detail: i3, rowCount: t3, rowIndex: e3 || 0, rows: s2 }), s2;
          }
          emit(e3) {
            switch (e3.type) {
              case "afterDeleteColumns":
              case "afterDeleteRows":
              case "afterSetCell":
              case "afterSetColumns":
              case "afterSetRows":
                this.versionTag = s();
            }
            i2(this, e3.type, e3);
          }
          getCell(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let i3 = this.columns[e3];
            if (i3)
              return i3[t3];
          }
          getCellAsBoolean(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let i3 = this.columns[e3];
            return !!(i3 && i3[t3]);
          }
          getCellAsNumber(e3, t3, i3) {
            e3 = this.aliases[e3] || e3;
            let s2 = this.columns[e3], n2 = s2 && s2[t3];
            switch (typeof n2) {
              case "boolean":
                return n2 ? 1 : 0;
              case "number":
                return isNaN(n2) && !i3 ? null : n2;
            }
            return isNaN(n2 = parseFloat(`${n2}`)) && !i3 ? null : n2;
          }
          getCellAsString(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let i3 = this.columns[e3];
            return `${i3 && i3[t3]}`;
          }
          getColumn(e3, t3) {
            return this.getColumns([e3], t3)[e3];
          }
          getColumnAsNumbers(e3, t3) {
            let i3 = this.columns[e3 = this.aliases[e3] || e3], s2 = [];
            if (i3) {
              let n2 = i3.length;
              if (t3)
                for (let t4 = 0; t4 < n2; ++t4)
                  s2.push(this.getCellAsNumber(e3, t4, true));
              else {
                for (let e4 = 0, t4; e4 < n2; ++e4) {
                  if ("number" == typeof (t4 = i3[e4]))
                    return i3.slice();
                  if (null != t4)
                    break;
                }
                for (let t4 = 0; t4 < n2; ++t4)
                  s2.push(this.getCellAsNumber(e3, t4));
              }
            }
            return s2;
          }
          getColumnNames() {
            return Object.keys(this.columns);
          }
          getColumns(e3, t3) {
            let i3 = this.aliases, s2 = this.columns, n2 = {};
            e3 = e3 || Object.keys(s2);
            for (let o = 0, r = e3.length, l, a; o < r; ++o)
              (l = s2[i3[a = e3[o]] || a]) && (n2[a] = t3 ? l : l.slice());
            return n2;
          }
          getModifier() {
            return this.modifier;
          }
          getRow(e3, t3) {
            return this.getRows(e3, 1, t3)[0];
          }
          getRowCount() {
            return this.rowCount;
          }
          getRowIndexBy(e3, t3, i3) {
            e3 = this.aliases[e3] || e3;
            let s2 = this.columns[e3];
            if (s2) {
              let e4 = s2.indexOf(t3, i3);
              if (-1 !== e4)
                return e4;
            }
          }
          getRowObject(e3, t3) {
            return this.getRowObjects(e3, 1, t3)[0];
          }
          getRowObjects(e3 = 0, t3 = this.rowCount - e3, i3) {
            let s2 = this.aliases, n2 = this.columns, o = Array(t3);
            i3 = i3 || Object.keys(n2);
            for (let r = e3, l = 0, a = Math.min(this.rowCount, e3 + t3), h, d; r < a; ++r, ++l)
              for (let e4 of (d = o[l] = {}, i3))
                h = n2[s2[e4] || e4], d[e4] = h ? h[r] : void 0;
            return o;
          }
          getRows(e3 = 0, t3 = this.rowCount - e3, i3) {
            let s2 = this.aliases, n2 = this.columns, o = Array(t3);
            i3 = i3 || Object.keys(n2);
            for (let r = e3, l = 0, a = Math.min(this.rowCount, e3 + t3), h, d; r < a; ++r, ++l)
              for (let e4 of (d = o[l] = [], i3))
                h = n2[s2[e4] || e4], d.push(h ? h[r] : void 0);
            return o;
          }
          getVersionTag() {
            return this.versionTag;
          }
          hasColumns(e3) {
            let t3 = this.aliases, i3 = this.columns;
            for (let s2 = 0, n2 = e3.length, o; s2 < n2; ++s2)
              if (!i3[o = e3[s2]] && !t3[o])
                return false;
            return true;
          }
          hasRowWith(e3, t3) {
            e3 = this.aliases[e3] || e3;
            let i3 = this.columns[e3];
            return !!i3 && -1 !== i3.indexOf(t3);
          }
          on(e3, i3) {
            return t2(this, e3, i3);
          }
          renameColumn(e3, t3) {
            let i3 = this.columns;
            if (i3[e3]) {
              if (e3 !== t3) {
                let s2 = this.aliases;
                s2[t3] && delete s2[t3], i3[t3] = i3[e3], delete i3[e3];
              }
              return true;
            }
            return false;
          }
          setCell(e3, t3, i3, s2) {
            let n2 = this.columns, o = this.modifier, r = n2[e3 = this.aliases[e3] || e3];
            r && r[t3] === i3 || (this.emit({ type: "setCell", cellValue: i3, columnName: e3, detail: s2, rowIndex: t3 }), r || (r = n2[e3] = Array(this.rowCount)), t3 >= this.rowCount && (this.rowCount = t3 + 1), r[t3] = i3, o && o.modifyCell(this, e3, t3, i3), this.emit({ type: "afterSetCell", cellValue: i3, columnName: e3, detail: s2, rowIndex: t3 }));
          }
          setColumn(e3, t3 = [], i3 = 0, s2) {
            this.setColumns({ [e3]: t3 }, i3, s2);
          }
          setColumns(e3, t3, i3) {
            let s2 = this.columns, n2 = this.modifier, o = void 0 === t3, r = Object.keys(e3);
            this.emit({ type: "setColumns", columns: e3, columnNames: r, detail: i3, rowIndex: t3 });
            for (let i4 = 0, n3 = r.length, l2, a; i4 < n3; ++i4)
              if (l2 = e3[a = r[i4]], a = this.aliases[a] || a, o)
                s2[a] = l2.slice(), this.rowCount = l2.length;
              else {
                let e4 = s2[a] ? s2[a] : s2[a] = Array(this.rowCount);
                for (let i5 = t3 || 0, s3 = l2.length; i5 < s3; ++i5)
                  e4[i5] = l2[i5];
                this.rowCount = Math.max(this.rowCount, e4.length);
              }
            let l = Object.keys(s2);
            for (let e4 = 0, t4 = l.length; e4 < t4; ++e4)
              s2[l[e4]].length = this.rowCount;
            n2 && n2.modifyColumns(this, e3, t3 || 0), this.emit({ type: "afterSetColumns", columns: e3, columnNames: r, detail: i3, rowIndex: t3 });
          }
          setModifier(e3, t3) {
            let i3 = this;
            return i3.emit({ type: "setModifier", detail: t3, modifier: e3, modified: i3.modified }), i3.modified = i3, i3.modifier = e3, (e3 ? e3.modify(i3) : Promise.resolve(i3)).then((i4) => (i4.emit({ type: "afterSetModifier", detail: t3, modifier: e3, modified: i4.modified }), i4)).catch((t4) => {
              throw i3.emit({ type: "setModifierError", error: t4, modifier: e3, modified: i3.modified }), t4;
            });
          }
          setRow(e3, t3, i3) {
            this.setRows([e3], t3, i3);
          }
          setRows(e3, t3 = this.rowCount, i3) {
            let s2 = this.aliases, o = this.columns, r = Object.keys(o), l = this.modifier, a = e3.length;
            this.emit({ type: "setRows", detail: i3, rowCount: a, rowIndex: t3, rows: e3 });
            for (let i4 = 0, l2 = t3, h2; i4 < a; ++i4, ++l2)
              if ((h2 = e3[i4]) === n.NULL)
                for (let e4 = 0, t4 = r.length; e4 < t4; ++e4)
                  o[r[e4]][l2] = null;
              else if (h2 instanceof Array)
                for (let e4 = 0, t4 = r.length; e4 < t4; ++e4)
                  o[r[e4]][l2] = h2[e4];
              else {
                let e4 = Object.keys(h2);
                for (let t4 = 0, i5 = e4.length, n2; t4 < i5; ++t4)
                  o[n2 = s2[n2 = e4[t4]] || n2] || (o[n2] = Array(l2 + 1)), o[n2][l2] = h2[n2];
              }
            let h = t3 + a;
            if (h > this.rowCount) {
              this.rowCount = h;
              for (let e4 = 0, t4 = r.length; e4 < t4; ++e4)
                o[r[e4]].length = h;
            }
            l && l.modifyRows(this, e3, t3), this.emit({ type: "afterSetRows", detail: i3, rowCount: a, rowIndex: t3, rows: e3 });
          }
        }
        return n.NULL = {}, n.version = "1.0.0", n;
      }), i(t, "Data/Connectors/DataConnector.js", [t["Data/Modifiers/DataModifier.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(t2, i2, s) {
        var n;
        let { addEvent: o, fireEvent: r, merge: l, pick: a } = s;
        class h {
          constructor(e2 = {}) {
            this.table = new i2(e2.dataTable), this.metadata = e2.metadata || { columns: {} };
          }
          get polling() {
            return !!this.polling;
          }
          describeColumn(e2, t3) {
            let i3 = this.metadata.columns;
            i3[e2] = l(i3[e2] || {}, t3);
          }
          describeColumns(e2) {
            let t3;
            let i3 = Object.keys(e2);
            for (; "string" == typeof (t3 = i3.pop()); )
              this.describeColumn(t3, e2[t3]);
          }
          emit(e2) {
            r(this, e2.type, e2);
          }
          getColumnOrder(e2) {
            let t3 = this.metadata.columns, i3 = Object.keys(t3 || {});
            if (i3.length)
              return i3.sort((e3, i4) => a(t3[e3].index, 0) - a(t3[i4].index, 0));
          }
          getSortedColumns(e2) {
            return this.table.getColumns(this.getColumnOrder(e2));
          }
          load() {
            return r(this, "afterLoad", { table: this.table }), Promise.resolve(this);
          }
          on(e2, t3) {
            return o(this, e2, t3);
          }
          save() {
            return r(this, "saveError", { table: this.table }), Promise.reject(Error("Not implemented"));
          }
          setColumnOrder(e2) {
            for (let t3 = 0, i3 = e2.length; t3 < i3; ++t3)
              this.describeColumn(e2[t3], { index: t3 });
          }
          setModifierOptions(e2) {
            let i3 = e2 && t2.types[e2.type];
            return this.table.setModifier(i3 ? new i3(e2) : void 0).then(() => this);
          }
          startPolling(t3 = 1e3) {
            let i3 = this;
            e.clearTimeout(i3._polling), i3._polling = e.setTimeout(() => i3.load().catch((e2) => i3.emit({ type: "loadError", error: e2, table: i3.table })).then(() => {
              i3._polling && i3.startPolling(t3);
            }), t3);
          }
          stopPolling() {
            e.clearTimeout(this._polling), delete this._polling;
          }
          whatIs(e2) {
            return this.metadata.columns[e2];
          }
        }
        return (n = h || (h = {})).types = {}, n.registerType = function(e2, t3) {
          return !!e2 && !n.types[e2] && !!(n.types[e2] = t3);
        }, h;
      }), i(t, "Data/DataCursor.js", [], function() {
        class e2 {
          constructor(e3 = {}) {
            this.emittingRegister = [], this.listenerMap = {}, this.stateMap = e3;
          }
          addListener(e3, t2, i2) {
            let s = this.listenerMap[e3] = this.listenerMap[e3] || {};
            return (s[t2] = s[t2] || []).push(i2), this;
          }
          buildEmittingTag(e3) {
            return ("position" === e3.cursor.type ? [e3.table.id, e3.cursor.column, e3.cursor.row, e3.cursor.state, e3.cursor.type] : [e3.table.id, e3.cursor.columns, e3.cursor.firstRow, e3.cursor.lastRow, e3.cursor.state, e3.cursor.type]).join("\0");
          }
          emitCursor(t2, i2, s, n, o) {
            let r = "object" == typeof i2 ? i2 : s, l = "object" == typeof n ? n : s, a = "string" == typeof i2 ? i2 : void 0, h = t2.id, d = r.state, u = this.listenerMap[h] && this.listenerMap[h][d];
            if (o = o || true === n, u) {
              let i3 = this.stateMap[h] = this.stateMap[h] || {}, s2 = i3[r.state] || [];
              o && (s2.length || (i3[r.state] = s2), -1 === e2.getIndex(r, s2) && s2.push(r));
              let n2 = { cursor: r, cursors: s2, table: t2 };
              l && (n2.event = l), a && (n2.group = a);
              let d2 = this.emittingRegister, f = this.buildEmittingTag(n2);
              if (d2.indexOf(f) >= 0)
                return this;
              try {
                this.emittingRegister.push(f);
                for (let e3 = 0, t3 = u.length; e3 < t3; ++e3)
                  u[e3].call(this, n2);
              } finally {
                let e3 = this.emittingRegister.indexOf(f);
                e3 >= 0 && this.emittingRegister.splice(e3, 1);
              }
            }
            return this;
          }
          remitCursor(t2, i2) {
            let s = this.stateMap[t2] && this.stateMap[t2][i2.state];
            if (s) {
              let t3 = e2.getIndex(i2, s);
              t3 >= 0 && s.splice(t3, 1);
            }
            return this;
          }
          removeListener(e3, t2, i2) {
            let s = this.listenerMap[e3] && this.listenerMap[e3][t2];
            if (s) {
              let e4 = s.indexOf(i2);
              e4 && s.splice(e4, 1);
            }
            return this;
          }
        }
        return e2.version = "1.0.0", function(e3) {
          function t2(e4, t3) {
            if ("range" === e4.type)
              return e4;
            let i2 = { type: "range", firstRow: e4.row ?? (t3 && t3.firstRow) ?? 0, lastRow: e4.row ?? (t3 && t3.lastRow) ?? Number.MAX_VALUE, state: e4.state };
            return void 0 !== e4.column && (i2.columns = [e4.column]), i2;
          }
          e3.getIndex = function(e4, t3) {
            if ("position" === e4.type) {
              for (let i2, s = 0, n = t3.length; s < n; ++s)
                if ("position" === (i2 = t3[s]).type && i2.state === e4.state && i2.column === e4.column && i2.row === e4.row)
                  return s;
            } else {
              let i2 = JSON.stringify(e4.columns);
              for (let s, n = 0, o = t3.length; n < o; ++n)
                if ("range" === (s = t3[n]).type && s.state === e4.state && s.firstRow === e4.firstRow && s.lastRow === e4.lastRow && JSON.stringify(s.columns) === i2)
                  return n;
            }
            return -1;
          }, e3.isEqual = function(e4, t3) {
            return "position" === e4.type && "position" === t3.type ? e4.column === t3.column && e4.row === t3.row && e4.state === t3.state : "range" === e4.type && "range" === t3.type && e4.firstRow === t3.firstRow && e4.lastRow === t3.lastRow && JSON.stringify(e4.columns) === JSON.stringify(t3.columns);
          }, e3.isInRange = function(e4, i2) {
            "position" === i2.type && (i2 = t2(i2)), "position" === e4.type && (e4 = t2(e4, i2));
            let s = e4.columns, n = i2.columns;
            return e4.firstRow >= i2.firstRow && e4.lastRow <= i2.lastRow && (!s || !n || s.every((e5) => n.indexOf(e5) >= 0));
          }, e3.toPositions = function(e4) {
            if ("position" === e4.type)
              return [e4];
            let t3 = e4.columns || [], i2 = [], s = e4.state;
            for (let n = e4.firstRow, o = e4.lastRow; n < o; ++n) {
              if (!t3.length) {
                i2.push({ type: "position", row: n, state: s });
                continue;
              }
              for (let e5 = 0, o2 = t3.length; e5 < o2; ++e5)
                i2.push({ type: "position", column: t3[e5], row: n, state: s });
            }
            return i2;
          }, e3.toRange = t2;
        }(e2 || (e2 = {})), e2;
      }), i(t, "DataGrid/DataGridUtils.js", [], function() {
        return { dataTableCellToString: (e2) => "string" == typeof e2 || "number" == typeof e2 || "boolean" == typeof e2 ? "" + e2 : "", emptyHTMLElement(e2) {
          for (; e2.firstChild; )
            e2.removeChild(e2.firstChild);
        }, makeDiv: (e2, t2) => {
          let i2 = document.createElement("div");
          return i2.className = e2, t2 && (i2.id = t2), i2;
        } };
      }), i(t, "DataGrid/Globals.js", [], function() {
        var t2, i2;
        return (i2 = t2 || (t2 = {})).classNamePrefix = "highcharts-datagrid-", i2.classNames = { gridContainer: i2.classNamePrefix + "container", outerContainer: i2.classNamePrefix + "outer-container", scrollContainer: i2.classNamePrefix + "scroll-container", innerContainer: i2.classNamePrefix + "inner-container", cell: i2.classNamePrefix + "cell", cellInput: i2.classNamePrefix + "cell-input", row: i2.classNamePrefix + "row", columnHeader: i2.classNamePrefix + "column-header" }, i2.win = e, i2.userAgent = i2.win.navigator && i2.win.navigator.userAgent || "", i2.isChrome = -1 !== i2.userAgent.indexOf("Chrome"), i2.isSafari = !i2.isChrome && -1 !== i2.userAgent.indexOf("Safari"), t2;
      }), i(t, "Core/Chart/ChartDefaults.js", [], function() {
        return { alignThresholds: false, panning: { enabled: false, type: "x" }, styledMode: false, borderRadius: 0, colorCount: 10, allowMutatingData: true, ignoreHiddenSeries: true, spacing: [10, 10, 15, 10], resetZoomButton: { theme: {}, position: {} }, reflow: true, type: "line", zooming: { singleTouch: false, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } }, width: null, height: null, borderColor: "#334eff", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" };
      }), i(t, "Core/Color/Palettes.js", [], function() {
        return { colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"] };
      }), i(t, "Core/Time.js", [t["Core/Globals.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { win: i2 } = e2, { defined: s, error: n, extend: o, isNumber: r, isObject: l, merge: a, objectEach: h, pad: d, pick: u, splat: f, timeUnits: m } = t2, c = e2.isSafari && i2.Intl && i2.Intl.DateTimeFormat.prototype.formatRange, p = e2.isSafari && i2.Intl && !i2.Intl.DateTimeFormat.prototype.formatRange;
        class g {
          constructor(e3) {
            this.options = {}, this.useUTC = false, this.variableTimezone = false, this.Date = i2.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(e3);
          }
          get(e3, t3) {
            if (this.variableTimezone || this.timezoneOffset) {
              let i3 = t3.getTime(), s2 = i3 - this.getTimezoneOffset(t3);
              t3.setTime(s2);
              let n2 = t3["getUTC" + e3]();
              return t3.setTime(i3), n2;
            }
            return this.useUTC ? t3["getUTC" + e3]() : t3["get" + e3]();
          }
          set(e3, t3, i3) {
            if (this.variableTimezone || this.timezoneOffset) {
              if ("Milliseconds" === e3 || "Seconds" === e3 || "Minutes" === e3 && this.getTimezoneOffset(t3) % 36e5 == 0)
                return t3["setUTC" + e3](i3);
              let s2 = this.getTimezoneOffset(t3), n2 = t3.getTime() - s2;
              t3.setTime(n2), t3["setUTC" + e3](i3);
              let o2 = this.getTimezoneOffset(t3);
              return n2 = t3.getTime() + o2, t3.setTime(n2);
            }
            return this.useUTC || c && "FullYear" === e3 ? t3["setUTC" + e3](i3) : t3["set" + e3](i3);
          }
          update(e3 = {}) {
            let t3 = u(e3.useUTC, true);
            this.options = e3 = a(true, this.options, e3), this.Date = e3.Date || i2.Date || Date, this.useUTC = t3, this.timezoneOffset = t3 && e3.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = t3 && !!(e3.getTimezoneOffset || e3.timezone);
          }
          makeTime(e3, t3, i3, s2, n2, o2) {
            let r2, l2, a2;
            return this.useUTC ? (r2 = this.Date.UTC.apply(0, arguments), l2 = this.getTimezoneOffset(r2), r2 += l2, l2 !== (a2 = this.getTimezoneOffset(r2)) ? r2 += a2 - l2 : l2 - 36e5 !== this.getTimezoneOffset(r2 - 36e5) || p || (r2 -= 36e5)) : r2 = new this.Date(e3, t3, u(i3, 1), u(s2, 0), u(n2, 0), u(o2, 0)).getTime(), r2;
          }
          timezoneOffsetFunction() {
            let e3 = this, t3 = this.options, i3 = t3.getTimezoneOffset;
            return this.useUTC ? t3.timezone ? (e4) => {
              try {
                let i4 = `shortOffset,${t3.timezone || ""}`, [s2, n2, o2, l2, a2 = 0] = (g.formatCache[i4] = g.formatCache[i4] || Intl.DateTimeFormat("en", { timeZone: t3.timezone, timeZoneName: "shortOffset" })).format(e4).split(/(GMT|:)/).map(Number), h2 = -(36e5 * (o2 + a2 / 60));
                if (r(h2))
                  return h2;
              } catch (e5) {
                n(34);
              }
              return 0;
            } : this.useUTC && i3 ? (e4) => 6e4 * i3(e4.valueOf()) : () => 6e4 * (e3.timezoneOffset || 0) : (e4) => 6e4 * new Date(e4.toString()).getTimezoneOffset();
          }
          dateFormat(t3, i3, n2) {
            if (!s(i3) || isNaN(i3))
              return e2.defaultOptions.lang && e2.defaultOptions.lang.invalidDate || "";
            t3 = u(t3, "%Y-%m-%d %H:%M:%S");
            let r2 = this, l2 = new this.Date(i3), a2 = this.get("Hours", l2), f2 = this.get("Day", l2), m2 = this.get("Date", l2), c2 = this.get("Month", l2), p2 = this.get("FullYear", l2), g2 = e2.defaultOptions.lang, C = g2 && g2.weekdays, y = g2 && g2.shortWeekdays;
            return h(o({ a: y ? y[f2] : C[f2].substr(0, 3), A: C[f2], d: d(m2), e: d(m2, 2, " "), w: f2, b: g2.shortMonths[c2], B: g2.months[c2], m: d(c2 + 1), o: c2 + 1, y: p2.toString().substr(2, 2), Y: p2, H: d(a2), k: a2, I: d(a2 % 12 || 12), l: a2 % 12 || 12, M: d(this.get("Minutes", l2)), p: a2 < 12 ? "AM" : "PM", P: a2 < 12 ? "am" : "pm", S: d(this.get("Seconds", l2)), L: d(Math.floor(i3 % 1e3), 3) }, e2.dateFormats), function(e3, s2) {
              for (; -1 !== t3.indexOf("%" + s2); )
                t3 = t3.replace("%" + s2, "function" == typeof e3 ? e3.call(r2, i3) : e3);
            }), n2 ? t3.substr(0, 1).toUpperCase() + t3.substr(1) : t3;
          }
          resolveDTLFormat(e3) {
            return l(e3, true) ? e3 : { main: (e3 = f(e3))[0], from: e3[1], to: e3[2] };
          }
          getTimeTicks(e3, t3, i3, n2) {
            let r2, l2, a2, h2;
            let d2 = this, f2 = d2.Date, c2 = [], p2 = {}, g2 = new f2(t3), C = e3.unitRange, y = e3.count || 1;
            if (n2 = u(n2, 1), s(t3)) {
              d2.set("Milliseconds", g2, C >= m.second ? 0 : y * Math.floor(d2.get("Milliseconds", g2) / y)), C >= m.second && d2.set("Seconds", g2, C >= m.minute ? 0 : y * Math.floor(d2.get("Seconds", g2) / y)), C >= m.minute && d2.set("Minutes", g2, C >= m.hour ? 0 : y * Math.floor(d2.get("Minutes", g2) / y)), C >= m.hour && d2.set("Hours", g2, C >= m.day ? 0 : y * Math.floor(d2.get("Hours", g2) / y)), C >= m.day && d2.set("Date", g2, C >= m.month ? 1 : Math.max(1, y * Math.floor(d2.get("Date", g2) / y))), C >= m.month && (d2.set("Month", g2, C >= m.year ? 0 : y * Math.floor(d2.get("Month", g2) / y)), l2 = d2.get("FullYear", g2)), C >= m.year && (l2 -= l2 % y, d2.set("FullYear", g2, l2)), C === m.week && (h2 = d2.get("Day", g2), d2.set("Date", g2, d2.get("Date", g2) - h2 + n2 + (h2 < n2 ? -7 : 0))), l2 = d2.get("FullYear", g2);
              let e4 = d2.get("Month", g2), o2 = d2.get("Date", g2), u2 = d2.get("Hours", g2);
              t3 = g2.getTime(), (d2.variableTimezone || !d2.useUTC) && s(i3) && (a2 = i3 - t3 > 4 * m.month || d2.getTimezoneOffset(t3) !== d2.getTimezoneOffset(i3));
              let f3 = g2.getTime();
              for (r2 = 1; f3 < i3; )
                c2.push(f3), C === m.year ? f3 = d2.makeTime(l2 + r2 * y, 0) : C === m.month ? f3 = d2.makeTime(l2, e4 + r2 * y) : a2 && (C === m.day || C === m.week) ? f3 = d2.makeTime(l2, e4, o2 + r2 * y * (C === m.day ? 1 : 7)) : a2 && C === m.hour && y > 1 ? f3 = d2.makeTime(l2, e4, o2, u2 + r2 * y) : f3 += C * y, r2++;
              c2.push(f3), C <= m.hour && c2.length < 1e4 && c2.forEach(function(e5) {
                e5 % 18e5 == 0 && "000000000" === d2.dateFormat("%H%M%S%L", e5) && (p2[e5] = "day");
              });
            }
            return c2.info = o(e3, { higherRanks: p2, totalRange: C * y }), c2;
          }
          getDateFormat(e3, t3, i3, s2) {
            let n2 = this.dateFormat("%m-%d %H:%M:%S.%L", t3), o2 = "01-01 00:00:00.000", r2 = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, l2 = "millisecond", a2 = l2;
            for (l2 in m) {
              if (e3 === m.week && +this.dateFormat("%w", t3) === i3 && n2.substr(6) === o2.substr(6)) {
                l2 = "week";
                break;
              }
              if (m[l2] > e3) {
                l2 = a2;
                break;
              }
              if (r2[l2] && n2.substr(r2[l2]) !== o2.substr(r2[l2]))
                break;
              "week" !== l2 && (a2 = l2);
            }
            return this.resolveDTLFormat(s2[l2]).main;
          }
        }
        return g.formatCache = {}, g;
      }), i(t, "Core/Defaults.js", [t["Core/Chart/ChartDefaults.js"], t["Core/Globals.js"], t["Core/Color/Palettes.js"], t["Core/Time.js"], t["Core/Utilities.js"]], function(e2, t2, i2, s, n) {
        let { isTouchDevice: o, svg: r } = t2, { merge: l } = n, a = { colors: i2.colors, symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], decimalPoint: ".", numericSymbols: ["k", "M", "G", "T", "P", "E"], resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: {}, time: { Date: void 0, getTimezoneOffset: void 0, timezone: void 0, timezoneOffset: 0, useUTC: true }, chart: e2, title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "center", widthAdjust: -44 }, caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, legend: { enabled: true, align: "center", alignColumns: true, className: "highcharts-no-tooltip", layout: "horizontal", itemMarginBottom: 2, itemMarginTop: 2, labelFormatter: function() {
          return this.name;
        }, borderColor: "#999999", borderRadius: 0, navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" }, itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#666666", textDecoration: "line-through" }, shadow: false, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: true, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontSize: "0.8em", fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } }, tooltip: { enabled: true, animation: r, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %e %b, %H:%M:%S.%L", second: "%A, %e %b, %H:%M:%S", minute: "%A, %e %b, %H:%M", hour: "%A, %e %b, %H:%M", day: "%A, %e %b %Y", week: "Week from %A, %e %b %Y", month: "%B %Y", year: "%Y" }, footerFormat: "", headerShape: "callout", hideDelay: 500, padding: 8, shape: "callout", shared: false, snap: o ? 25 : 10, headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>', pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>', backgroundColor: "#ffffff", borderWidth: void 0, shadow: true, stickOnContact: false, style: { color: "#333333", cursor: "default", fontSize: "0.8em" }, useHTML: false }, credits: { enabled: true, href: "https://www.highcharts.com?credits", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" }, text: "Highcharts.com" } };
        a.chart.styledMode = false;
        let h = new s(a.time);
        return { defaultOptions: a, defaultTime: h, getOptions: function() {
          return a;
        }, setOptions: function(e3) {
          return l(true, a, e3), (e3.time || e3.global) && (t2.time ? t2.time.update(l(a.global, a.time, e3.global, e3.time)) : t2.time = h), a;
        } };
      }), i(t, "Core/Templating.js", [t["Core/Defaults.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { defaultOptions: i2, defaultTime: s } = e2, { extend: n, getNestedProperty: o, isArray: r, isNumber: l, isObject: a, pick: h, pInt: d } = t2, u = { add: (e3, t3) => e3 + t3, divide: (e3, t3) => 0 !== t3 ? e3 / t3 : "", eq: (e3, t3) => e3 == t3, each: function(e3) {
          let t3 = arguments[arguments.length - 1];
          return !!r(e3) && e3.map((i3, s2) => f(t3.body, n(a(i3) ? i3 : { "@this": i3 }, { "@index": s2, "@first": 0 === s2, "@last": s2 === e3.length - 1 }))).join("");
        }, ge: (e3, t3) => e3 >= t3, gt: (e3, t3) => e3 > t3, if: (e3) => !!e3, le: (e3, t3) => e3 <= t3, lt: (e3, t3) => e3 < t3, multiply: (e3, t3) => e3 * t3, ne: (e3, t3) => e3 != t3, subtract: (e3, t3) => e3 - t3, unless: (e3) => !e3 };
        function f(e3 = "", t3, n2) {
          let r2 = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g, l2 = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g, a2 = [], d2 = /f$/, c = /\.([0-9])/, p = i2.lang, g = n2 && n2.time || s, C = n2 && n2.numberFormatter || m, y = (e4 = "") => {
            let i3;
            return "true" === e4 || "false" !== e4 && ((i3 = Number(e4)).toString() === e4 ? i3 : o(e4, t3));
          }, b, w, v = 0, T;
          for (; null !== (b = r2.exec(e3)); ) {
            let i3 = l2.exec(b[1]);
            i3 && (b = i3, T = true), w && w.isBlock || (w = { ctx: t3, expression: b[1], find: b[0], isBlock: "#" === b[1].charAt(0), start: b.index, startInner: b.index + b[0].length, length: b[0].length });
            let s2 = b[1].split(" ")[0].replace("#", "");
            u[s2] && (w.isBlock && s2 === w.fn && v++, w.fn || (w.fn = s2));
            let n3 = "else" === b[1];
            if (w.isBlock && w.fn && (b[1] === `/${w.fn}` || n3)) {
              if (v)
                !n3 && v--;
              else {
                let t4 = w.startInner, i4 = e3.substr(t4, b.index - t4);
                void 0 === w.body ? (w.body = i4, w.startInner = b.index + b[0].length) : w.elseBody = i4, w.find += i4 + b[0], n3 || (a2.push(w), w = void 0);
              }
            } else
              w.isBlock || a2.push(w);
            if (i3 && !(w == null ? void 0 : w.isBlock))
              break;
          }
          return a2.forEach((i3) => {
            let s2, n3;
            let { body: o2, elseBody: r3, expression: l3, fn: a3 } = i3;
            if (a3) {
              let e4 = [i3], h2 = l3.split(" ");
              for (n3 = u[a3].length; n3--; )
                e4.unshift(y(h2[n3 + 1]));
              s2 = u[a3].apply(t3, e4), i3.isBlock && "boolean" == typeof s2 && (s2 = f(s2 ? o2 : r3, t3));
            } else {
              let e4 = l3.split(":");
              if (s2 = y(e4.shift() || ""), e4.length && "number" == typeof s2) {
                let t4 = e4.join(":");
                if (d2.test(t4)) {
                  let e5 = parseInt((t4.match(c) || ["", "-1"])[1], 10);
                  null !== s2 && (s2 = C(s2, e5, p.decimalPoint, t4.indexOf(",") > -1 ? p.thousandsSep : ""));
                } else
                  s2 = g.dateFormat(t4, s2);
              }
            }
            e3 = e3.replace(i3.find, h(s2, ""));
          }), T ? f(e3, t3, n2) : e3;
        }
        function m(e3, t3, s2, n2) {
          let o2, r2;
          e3 = +e3 || 0, t3 = +t3;
          let a2 = i2.lang, u2 = (e3.toString().split(".")[1] || "").split("e")[0].length, f2 = e3.toString().split("e"), m2 = t3;
          -1 === t3 ? t3 = Math.min(u2, 20) : l(t3) ? t3 && f2[1] && f2[1] < 0 && ((r2 = t3 + +f2[1]) >= 0 ? (f2[0] = (+f2[0]).toExponential(r2).split("e")[0], t3 = r2) : (f2[0] = f2[0].split(".")[0] || 0, e3 = t3 < 20 ? (f2[0] * Math.pow(10, f2[1])).toFixed(t3) : 0, f2[1] = 0)) : t3 = 2;
          let c = (Math.abs(f2[1] ? f2[0] : e3) + Math.pow(10, -Math.max(t3, u2) - 1)).toFixed(t3), p = String(d(c)), g = p.length > 3 ? p.length % 3 : 0;
          return s2 = h(s2, a2.decimalPoint), n2 = h(n2, a2.thousandsSep), o2 = (e3 < 0 ? "-" : "") + (g ? p.substr(0, g) + n2 : ""), 0 > +f2[1] && !m2 ? o2 = "0" : o2 += p.substr(g).replace(/(\d{3})(?=\d)/g, "$1" + n2), t3 && (o2 += s2 + c.slice(-t3)), f2[1] && 0 != +o2 && (o2 += "e" + f2[1]), o2;
        }
        return { dateFormat: function(e3, t3, i3) {
          return s.dateFormat(e3, t3, i3);
        }, format: f, helpers: u, numberFormat: m };
      }), i(t, "DataGrid/DataGridDefaults.js", [], function() {
        return { cellHeight: 49, columnHeaders: { enabled: true }, columns: {}, defaultHeight: 400, editable: true, resizableColumns: true };
      }), i(t, "DataGrid/DataGrid.js", [t["Data/DataTable.js"], t["DataGrid/DataGridUtils.js"], t["DataGrid/Globals.js"], t["Core/Templating.js"], t["DataGrid/DataGridDefaults.js"], t["Core/Utilities.js"]], function(t2, i2, s, n, o, r) {
        let { dataTableCellToString: l, emptyHTMLElement: a, makeDiv: h } = i2, { isSafari: d, win: u } = s, { addEvent: f, clamp: m, defined: c, fireEvent: p, isNumber: g, merge: C, pick: y } = r;
        class b {
          constructor(e2, t3) {
            if (this.columnNames = [], this.prevTop = -1, this.scrollEndRowCount = 0, this.scrollEndTop = 0, this.bottom = false, this.overflowHeaderWidths = [], "string" == typeof e2) {
              let t4 = u.document.getElementById(e2);
              t4 ? this.container = t4 : this.container = h(s.classNames.gridContainer, e2);
            } else
              this.container = e2;
            this.gridContainer = h(s.classNames.gridContainer), this.outerContainer = h(s.classNames.outerContainer), this.scrollContainer = h(s.classNames.scrollContainer), this.innerContainer = h(s.classNames.innerContainer), this.outerContainer.appendChild(this.scrollContainer), this.gridContainer.appendChild(this.outerContainer), this.container.appendChild(this.gridContainer), this.options = C(b.defaultOptions, t3), this.gridContainer.style.height = this.getDataGridSize() + "px", this.gridContainer.role = "figure", this.dataTable = this.initDataTable(), this.rowElements = [], this.draggedResizeHandle = null, this.draggedColumnRightIx = null, this.columnNames = this.getColumnsToDisplay(), this.render(), (this.containerResizeObserver = new ResizeObserver(() => {
              this.updateGridElements();
            })).observe(this.container);
          }
          update(e2) {
            this.options = C(this.options, e2), this.options.dataTable !== this.dataTable && (this.dataTable = this.initDataTable()), this.columnNames = this.getColumnsToDisplay(), this.scrollContainer.removeChild(this.innerContainer), this.render();
          }
          resizeColumn(e2, t3) {
            let i3 = this.columnHeadersContainer, s2 = "string" == typeof t3 ? this.columnNames.indexOf(t3) : t3, n2 = `${e2}`;
            if (g(s2)) {
              if (-1 !== s2) {
                if (i3) {
                  let e3 = i3.children[s2];
                  e3 && (e3.style.flex = n2);
                }
                for (let e3 = 0; e3 < this.rowElements.length; e3++) {
                  let t4 = this.rowElements[e3].children[s2];
                  t4 && (t4.style.flex = n2);
                }
              }
            } else {
              if (i3)
                for (let e3 = 0; e3 < i3.children.length; e3++)
                  i3.children[e3].style.flex = n2;
              for (let e3 = 0; e3 < this.rowElements.length; e3++) {
                let t4 = this.rowElements[e3];
                for (let e4 = 0; e4 < t4.children.length; e4++)
                  t4.children[e4].style.flex = n2;
              }
            }
            this.renderColumnDragHandles(), this.emit({ type: "afterResizeColumn", width: e2, index: s2, name: g(s2) ? this.columnNames[s2] : void 0 });
          }
          emit(e2) {
            p(this, e2.type, e2);
          }
          toggleRowHighlight(e2) {
            this.hoveredRow && this.hoveredRow.classList.contains("hovered") && this.hoveredRow.classList.remove("hovered"), e2 && (e2.classList.contains("hovered") ? e2.classList.remove("hovered") : e2.classList.add("hovered"));
          }
          on(e2, t3) {
            return f(this, e2, t3);
          }
          scrollToRow(e2) {
            this.outerContainer.scrollTop = e2 * this.options.cellHeight;
          }
          getColumnsToDisplay() {
            let e2 = this.options.columns, t3 = this.dataTable.modified.getColumnNames(), i3 = [];
            for (let s2 = 0; s2 < t3.length; s2++) {
              let n2 = t3[s2], o2 = e2[n2];
              o2 && c(o2.show) ? e2[n2].show && i3.push(n2) : i3.push(n2);
            }
            return i3;
          }
          isColumnEditable(e2) {
            return y((this.options.columns[e2] || {}).editable, this.options.editable);
          }
          initDataTable() {
            return this.options.dataTable ? this.options.dataTable : new t2();
          }
          render() {
            let { options: e2 } = this;
            this.prevTop = -1, this.bottom = false, a(this.innerContainer), e2.columnHeaders.enabled ? this.renderColumnHeaders() : this.outerContainer.style.top = "0", this.renderInitialRows(), this.addEvents(), this.updateScrollingLength(), this.updateVisibleCells(), e2.columnHeaders.enabled && e2.resizableColumns && this.renderColumnDragHandles(), this.updateGridElements(), this.gridContainer.ariaLabel = `Grid with ${this.dataTable.getColumnNames().length} columns and ${this.dataTable.getRowCount()} rows.`;
          }
          addEvents() {
            this.outerContainer.addEventListener("scroll", (e2) => {
              this.onScroll(e2);
            }), document.addEventListener("click", (e2) => {
              this.onDocumentClick(e2);
            }), this.container.addEventListener("mouseover", (e2) => {
              this.handleMouseOver(e2);
            }), this.container.addEventListener("click", (e2) => {
              this.handleRowClick(e2);
            });
          }
          updateVisibleCells(e2 = false) {
            let t3 = this.outerContainer.scrollTop;
            d && (t3 = m(t3, 0, this.outerContainer.scrollHeight - this.outerContainer.clientHeight));
            let i3 = Math.floor(t3 / this.options.cellHeight);
            if (i3 === this.prevTop && !e2)
              return;
            this.prevTop = i3;
            let s2 = this.columnNames, n2 = this.dataTable.modified.getRowCount();
            for (let e3 = 0; e3 < this.rowElements.length && i3 < n2; e3++, i3++) {
              let t4 = this.rowElements[e3];
              t4.dataset.rowIndex = String(i3);
              let n3 = t4.childNodes;
              for (let e4 = 0, o2 = s2.length; e4 < o2; e4++) {
                let o3 = n3[e4], r2 = s2[e4], l2 = this.dataTable.modified.getCell(s2[e4], i3);
                o3.textContent = this.formatCell(l2, r2), o3.dataset.originalData = "" + l2, o3.dataset.columnName = s2[e4], o3.dataset.dataType = typeof l2, 0 === e4 && (t4.dataset.rowXIndex = String(g(l2) ? l2 : i3));
              }
            }
            this.prevTop + this.scrollEndRowCount === n2 ? !this.bottom && this.scrollEndTop && (this.bottom = true, this.innerContainer.scrollTop = this.scrollEndTop) : this.bottom && (this.bottom = false, this.innerContainer.scrollTop = 0);
          }
          onScroll(t3) {
            t3.preventDefault(), e.requestAnimationFrame(this.updateVisibleCells.bind(this, false));
          }
          onCellClick(e2, t3) {
            if (this.isColumnEditable(t3)) {
              let t4 = e2.querySelector("input"), i3 = e2.getAttribute("data-original-data");
              if (!t4) {
                this.removeCellInputElement();
                let n2 = e2.clientHeight;
                e2.textContent = "", (t4 = this.cellInputEl = document.createElement("input")).style.height = n2 + "px", t4.className = s.classNames.cellInput, e2.appendChild(t4), t4.focus(), t4.value = i3 || "";
              }
              this.emit({ type: "cellClick", input: t4 });
            }
          }
          onDocumentClick(e2) {
            if (this.cellInputEl && e2.target) {
              let t3 = this.cellInputEl.parentNode;
              t3 && t3.contains(e2.target) || this.removeCellInputElement();
            }
          }
          handleMouseOver(e2) {
            let t3 = e2.target;
            if (t3 && t3.classList.contains(s.classNames.cell)) {
              let e3 = t3.parentElement;
              this.toggleRowHighlight(e3), this.hoveredRow = e3, p(this.container, "dataGridHover", { row: e3 });
            } else
              this.hoveredRow && (this.toggleRowHighlight(), this.hoveredRow = void 0);
          }
          handleRowClick(e2) {
            var _a, _b;
            let t3 = e2.target, i3 = (_b = (_a = this.options.events) == null ? void 0 : _a.row) == null ? void 0 : _b.click;
            i3 && (t3 == null ? void 0 : t3.classList.contains(s.classNames.cell)) && i3.call(t3.parentElement, e2);
          }
          removeCellInputElement() {
            let e2 = this.cellInputEl;
            if (e2) {
              let t3 = e2.parentNode;
              if (t3) {
                let i3 = t3.getAttribute("data-data-type"), s2 = t3.getAttribute("data-column-name"), n2 = e2.value;
                "number" === i3 && (n2 = parseFloat(n2)), t3.textContent = this.formatCell(n2, s2 || "");
              }
              e2.remove(), delete this.cellInputEl;
            }
          }
          updateScrollingLength() {
            let e2 = this.columnNames, t3 = this.dataTable.modified.getRowCount() - 1, i3 = 0, s2 = t3 - this.getNumRowsToDraw(), n2 = this.outerContainer.clientHeight;
            this.innerContainer.style.height = n2 + "px";
            for (let i4 = 0; i4 < this.rowElements.length; i4++) {
              let s3 = this.rowElements[i4].childNodes;
              for (let n3 = 0; n3 < e2.length; n3++)
                s3[n3].textContent = l(this.dataTable.modified.getCell(e2[n3], t3 - i4));
            }
            this.scrollContainer.appendChild(this.innerContainer);
            for (let e3 = 0; t3 > s2; t3--, e3++)
              if ((i3 += this.rowElements[e3].offsetHeight) > n2) {
                t3--;
                break;
              }
            let o2 = t3 - s2;
            this.scrollEndRowCount = this.rowElements.length - o2, this.scrollEndTop = i3 - n2;
            let r2 = (this.dataTable.modified.getRowCount() + o2) * this.options.cellHeight;
            this.scrollContainer.style.height = r2 + "px";
          }
          getNumRowsToDraw() {
            return Math.min(this.dataTable.modified.getRowCount(), Math.ceil((this.outerContainer.offsetHeight || this.options.defaultHeight) / this.options.cellHeight));
          }
          getDataGridSize() {
            let e2 = this.options, { height: t3 } = this.container.getBoundingClientRect();
            return t3 > 2 ? t3 : e2.defaultHeight;
          }
          renderCell(e2, t3) {
            let i3 = s.classNames.cell;
            this.isColumnEditable(t3) || (i3 += ` ${i3}-readonly`);
            let n2 = h(i3);
            n2.style.minHeight = this.options.cellHeight + "px", n2.addEventListener("click", () => this.onCellClick(n2, t3)), e2.appendChild(n2);
          }
          renderRow() {
            let e2 = h(s.classNames.row);
            for (let t3 = 0; t3 < this.columnNames.length; t3++)
              this.renderCell(e2, this.columnNames[t3]);
            this.innerContainer.appendChild(e2), this.rowElements.push(e2);
          }
          formatHeaderCell(e2) {
            let t3 = this.options.columns[e2], i3 = t3 && t3.headerFormat;
            return i3 ? n.format(i3, { text: e2 }) : e2;
          }
          formatCell(e2, t3) {
            let i3 = this.options.columns[t3], s2 = i3 && i3.cellFormat, o2 = i3 && i3.cellFormatter, r2 = c(e2) ? e2 : "";
            return (s2 && ("number" == typeof e2 && s2.indexOf("value") > -1 ? r2 = n.format(s2, { value: e2 }) : "string" == typeof e2 && s2.indexOf("text") > -1 && (r2 = n.format(s2, { text: e2 }))), o2) ? o2.call({ value: e2 }) : r2.toString();
          }
          renderColumnHeader(e2, t3) {
            let i3 = s.classNames.columnHeader;
            this.isColumnEditable(t3) || (i3 += ` ${i3}-readonly`);
            let n2 = h(i3);
            n2.style.minHeight = this.options.cellHeight + "px", n2.style.maxHeight = 2 * this.options.cellHeight + "px", n2.textContent = this.formatHeaderCell(t3), e2.appendChild(n2);
          }
          renderColumnHeaders() {
            let e2 = this.columnNames, t3 = this.columnHeadersContainer = this.columnHeadersContainer || h(`${s.classNamePrefix}column-headers`);
            a(t3), e2.forEach(this.renderColumnHeader.bind(this, t3)), this.headerContainer || (this.headerContainer = h(`${s.classNamePrefix}header-container`), this.headerContainer.appendChild(t3)), this.gridContainer.insertBefore(this.headerContainer, this.outerContainer), this.updateColumnHeaders();
          }
          updateGridElements() {
            this.updateColumnHeaders(), this.redrawRowElements(), this.updateDragHandlesPosition();
          }
          updateColumnHeaders() {
            let e2 = this.columnHeadersContainer;
            if (e2) {
              for (let t3 = 0; t3 < this.columnNames.length; t3++) {
                let i3 = this.columnNames[t3], s2 = e2.children[t3], n2 = this.overflowHeaderWidths[t3];
                s2.scrollWidth > s2.clientWidth ? (this.overflowHeaderWidths[t3] = s2.scrollWidth, s2.textContent = this.formatHeaderCell(i3).split(" ").map((e3) => e3.length < 4 ? e3 : e3.slice(0, 2) + "...").join(" ")) : g(n2) && n2 <= s2.clientWidth && (this.overflowHeaderWidths[t3] = null, s2.textContent = this.formatHeaderCell(i3));
              }
              this.outerContainer.style.top = e2.clientHeight + "px", e2.lastChild && (e2.lastChild.style.marginRight = this.outerContainer.offsetWidth - this.outerContainer.clientWidth + "px");
            }
          }
          redrawRowElements() {
            if (!this.rowElements.length)
              return;
            let e2 = [], t3 = this.rowElements[0].children;
            for (let i3 = 0; i3 < t3.length; i3++)
              e2.push(t3[i3].style.flex);
            a(this.innerContainer), this.renderInitialRows(), this.updateScrollingLength(), this.updateVisibleCells(true);
            for (let t4 = 0; t4 < this.rowElements.length; t4++) {
              let i3 = this.rowElements[t4];
              for (let t5 = 0; t5 < i3.childElementCount; t5++)
                i3.children[t5].style.flex = e2[t5];
            }
          }
          updateDragHandlesPosition() {
            let e2 = this.columnHeadersContainer, t3 = this.columnDragHandlesContainer;
            if (t3 && e2)
              for (let i3 = 0; i3 < t3.childElementCount - 1; i3++) {
                let s2 = t3.children[i3], n2 = e2.children[i3 + 1];
                s2.style.height = e2.clientHeight + "px", s2.style.left = n2.offsetLeft - 2 + "px";
              }
          }
          renderInitialRows() {
            this.rowElements = [];
            let e2 = this.getNumRowsToDraw();
            for (let t3 = 0; t3 < e2; t3++)
              this.renderRow();
          }
          renderColumnDragHandles() {
            if (!this.columnHeadersContainer)
              return;
            let e2 = this.columnDragHandlesContainer = this.columnDragHandlesContainer || h(`${s.classNamePrefix}col-resize-container`), t3 = this.columnHeadersContainer.children, i3 = this.options.cellHeight;
            a(e2);
            for (let n2 = 1; n2 < t3.length; ++n2) {
              let o2 = t3[n2], r2 = h(`${s.classNamePrefix}col-resize-handle`);
              r2.style.height = i3 + "px", r2.style.left = o2.offsetLeft - 2 + "px", r2.addEventListener("mouseover", () => {
                this.draggedResizeHandle || (r2.style.opacity = "1");
              }), r2.addEventListener("mouseleave", () => {
                this.draggedResizeHandle || (r2.style.opacity = "0");
              }), r2.addEventListener("mousedown", this.onHandleMouseDown.bind(this, r2, n2)), e2.appendChild(r2);
            }
            this.renderColumnResizeCrosshair(e2), document.addEventListener("mouseup", (e3) => {
              this.draggedResizeHandle && this.stopColumnResize(this.draggedResizeHandle, e3);
            }), document.addEventListener("mousemove", (e3) => {
              this.draggedResizeHandle && this.updateColumnResizeDrag(e3);
            }), this.headerContainer && this.headerContainer.appendChild(e2);
          }
          renderColumnResizeCrosshair(e2) {
            let t3 = this.columnResizeCrosshair = this.columnResizeCrosshair || h(`${s.classNamePrefix}col-resize-crosshair`), i3 = this.options.cellHeight;
            t3.style.top = i3 + "px", t3.style.height = this.innerContainer.offsetHeight + "px", e2.appendChild(t3);
          }
          onHandleMouseDown(e2, t3, i3) {
            if (this.draggedResizeHandle)
              return;
            i3.preventDefault(), this.draggedResizeHandle = e2, this.draggedColumnRightIx = t3, this.dragResizeStart = i3.pageX;
            let s2 = this.columnResizeCrosshair;
            s2 && (s2.style.left = e2.offsetLeft + e2.offsetWidth / 2 - s2.offsetWidth / 2 + "px", s2.style.opacity = "1");
          }
          updateColumnResizeDrag(e2) {
            let t3 = this.draggedResizeHandle, i3 = this.columnResizeCrosshair, s2 = this.draggedColumnRightIx, n2 = this.columnHeadersContainer;
            if (!t3 || !i3 || null === s2 || !n2 || !this.dragResizeStart)
              return;
            let o2 = n2.children[s2], r2 = e2.pageX - this.dragResizeStart, l2 = o2.offsetLeft + r2;
            t3.style.left = l2 - t3.offsetWidth / 2 + "px", i3.style.left = l2 - i3.offsetWidth / 2 + "px";
          }
          stopColumnResize(e2, t3) {
            let i3 = this.columnResizeCrosshair, s2 = this.draggedColumnRightIx, n2 = this.columnHeadersContainer;
            if (!i3 || !n2 || !this.dragResizeStart || null === s2)
              return;
            e2.style.opacity = "0", i3.style.opacity = "0";
            let o2 = n2.children[s2 - 1], r2 = n2.children[s2], l2 = t3.pageX - this.dragResizeStart, a2 = o2.offsetWidth + l2, h2 = r2.offsetWidth - l2, d2 = a2 / o2.offsetWidth, u2 = h2 / r2.offsetWidth, f2 = (o2.style.flex ? parseFloat(o2.style.flex) : 1) * d2, m2 = (r2.style.flex ? parseFloat(r2.style.flex) : 1) * u2;
            this.resizeColumn(f2, s2 - 1), this.resizeColumn(m2, s2), this.draggedResizeHandle = null, this.draggedColumnRightIx = null, this.updateGridElements();
          }
          setSize(e2, t3) {
            e2 && (this.innerContainer.style.width = e2 + "px"), t3 && (this.gridContainer.style.height = this.getDataGridSize() + "px", this.outerContainer.style.height = t3 - (this.options.cellHeight + this.getMarginHeight(t3)) + "px"), this.render();
          }
          getMarginHeight(e2) {
            return e2 - this.gridContainer.getBoundingClientRect().height;
          }
        }
        return b.defaultOptions = o, b;
      }), i(t, "Data/DataPoolDefaults.js", [], function() {
        return { connectors: [] };
      }), i(t, "Data/DataPool.js", [t["Data/Connectors/DataConnector.js"], t["Data/DataPoolDefaults.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        class s {
          constructor(e3 = t2) {
            e3.connectors = e3.connectors || [], this.connectors = {}, this.options = e3, this.waiting = {};
          }
          emit(e3) {
            i2.fireEvent(this, e3.type, e3);
          }
          getConnector(e3) {
            let t3 = this.connectors[e3];
            if (t3)
              return Promise.resolve(t3);
            let i3 = this.waiting[e3];
            if (!i3) {
              i3 = this.waiting[e3] = [];
              let t4 = this.getConnectorOptions(e3);
              if (!t4)
                throw Error(`Connector not found. (${e3})`);
              this.loadConnector(t4).then((t5) => {
                delete this.waiting[e3];
                for (let e4 = 0, s2 = i3.length; e4 < s2; ++e4)
                  i3[e4][0](t5);
              }).catch((t5) => {
                delete this.waiting[e3];
                for (let e4 = 0, s2 = i3.length; e4 < s2; ++e4)
                  i3[e4][1](t5);
              });
            }
            return new Promise((e4, t4) => {
              i3.push([e4, t4]);
            });
          }
          getConnectorIds() {
            let e3 = this.options.connectors, t3 = [];
            for (let i3 = 0, s2 = e3.length; i3 < s2; ++i3)
              t3.push(e3[i3].id);
            return t3;
          }
          getConnectorOptions(e3) {
            let t3 = this.options.connectors;
            for (let i3 = 0, s2 = t3.length; i3 < s2; ++i3)
              if (t3[i3].id === e3)
                return t3[i3];
          }
          getConnectorTable(e3) {
            return this.getConnector(e3).then((e4) => e4.table);
          }
          isNewConnector(e3) {
            return !this.connectors[e3];
          }
          loadConnector(t3) {
            return new Promise((i3, s2) => {
              this.emit({ type: "load", options: t3 });
              let n = e2.types[t3.type];
              if (!n)
                throw Error(`Connector type not found. (${t3.type})`);
              new n(t3.options).load().then((e3) => {
                this.connectors[t3.id] = e3, this.emit({ type: "afterLoad", options: t3 }), i3(e3);
              }).catch(s2);
            });
          }
          on(e3, t3) {
            return i2.addEvent(this, e3, t3);
          }
          setConnectorOptions(e3) {
            let t3 = this.options.connectors, i3 = this.connectors;
            this.emit({ type: "setConnectorOptions", options: e3 });
            for (let i4 = 0, s2 = t3.length; i4 < s2; ++i4)
              if (t3[i4].id === e3.id) {
                t3.splice(i4, 1);
                break;
              }
            i3[e3.id] && (i3[e3.id].stopPolling(), delete i3[e3.id]), t3.push(e3), this.emit({ type: "afterSetConnectorOptions", options: e3 });
          }
        }
        return s.version = "1.0.0", s;
      }), i(t, "Data/Converters/DataConverter.js", [t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { addEvent: i2, fireEvent: s, isNumber: n, merge: o } = t2;
        class r {
          constructor(e3) {
            this.dateFormats = { "YYYY/mm/dd": { regex: /^([0-9]{4})([\-\.\/])([0-9]{1,2})\2([0-9]{1,2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[1], e4[3] - 1, +e4[4]) : NaN;
            } }, "dd/mm/YYYY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4], e4[3] - 1, +e4[1]) : NaN;
            }, alternative: "mm/dd/YYYY" }, "mm/dd/YYYY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{4})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4], e4[1] - 1, +e4[3]) : NaN;
            } }, "dd/mm/YY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{2})$/, parser: function(e4) {
              let t4 = /* @__PURE__ */ new Date();
              if (!e4)
                return NaN;
              let i4 = +e4[4];
              return i4 > t4.getFullYear() - 2e3 ? i4 += 1900 : i4 += 2e3, Date.UTC(i4, e4[3] - 1, +e4[1]);
            }, alternative: "mm/dd/YY" }, "mm/dd/YY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{2})$/, parser: function(e4) {
              return e4 ? Date.UTC(+e4[4] + 2e3, e4[1] - 1, +e4[3]) : NaN;
            } } };
            let t3 = o(r.defaultOptions, e3), i3 = t3.decimalPoint;
            ("." === i3 || "," === i3) && (i3 = "." === i3 ? "\\." : ",", this.decimalRegExp = RegExp("^(-?[0-9]+)" + i3 + "([0-9]+)$")), this.options = t3;
          }
          asBoolean(e3) {
            return "boolean" == typeof e3 ? e3 : "string" == typeof e3 ? "" !== e3 && "0" !== e3 && "false" !== e3 : !!this.asNumber(e3);
          }
          asDate(e3) {
            let t3;
            if ("string" == typeof e3)
              t3 = this.parseDate(e3);
            else if ("number" == typeof e3)
              t3 = e3;
            else {
              if (e3 instanceof Date)
                return e3;
              t3 = this.parseDate(this.asString(e3));
            }
            return new Date(t3);
          }
          asGuessedType(e3) {
            return { number: this.asNumber, Date: this.asDate, string: this.asString }[this.guessType(e3)].call(this, e3);
          }
          asNumber(e3) {
            if ("number" == typeof e3)
              return e3;
            if ("boolean" == typeof e3)
              return e3 ? 1 : 0;
            if ("string" == typeof e3) {
              let t3 = this.decimalRegExp;
              if (e3.indexOf(" ") > -1 && (e3 = e3.replace(/\s+/g, "")), t3) {
                if (!t3.test(e3))
                  return NaN;
                e3 = e3.replace(t3, "$1.$2");
              }
              return parseFloat(e3);
            }
            return e3 instanceof Date ? e3.getDate() : e3 ? e3.getRowCount() : NaN;
          }
          asString(e3) {
            return "" + e3;
          }
          deduceDateFormat(e3, t3, i3) {
            let s2 = [], n2 = [], o2 = "YYYY/mm/dd", r2, l = [], a = 0, h = false, d, u;
            for ((!t3 || t3 > e3.length) && (t3 = e3.length); a < t3; a++)
              if (void 0 !== e3[a] && e3[a] && e3[a].length)
                for (u = 0, r2 = e3[a].trim().replace(/[-\.\/]/g, " ").split(" "), l = ["", "", ""]; u < r2.length; u++)
                  u < l.length && (d = parseInt(r2[u], 10)) && (n2[u] = !n2[u] || n2[u] < d ? d : n2[u], void 0 !== s2[u] ? s2[u] !== d && (s2[u] = false) : s2[u] = d, d > 31 ? d < 100 ? l[u] = "YY" : l[u] = "YYYY" : d > 12 && d <= 31 ? (l[u] = "dd", h = true) : l[u].length || (l[u] = "mm"));
            if (h) {
              for (u = 0; u < s2.length; u++)
                false !== s2[u] ? n2[u] > 12 && "YY" !== l[u] && "YYYY" !== l[u] && (l[u] = "YY") : n2[u] > 12 && "mm" === l[u] && (l[u] = "dd");
              3 === l.length && "dd" === l[1] && "dd" === l[2] && (l[2] = "YY"), o2 = l.join("/");
            }
            return i3 && (this.options.dateFormat = o2), o2;
          }
          emit(e3) {
            s(this, e3.type, e3);
          }
          export(e3, t3) {
            throw this.emit({ type: "exportError", columns: [], headers: [] }), Error("Not implemented");
          }
          getTable() {
            throw Error("Not implemented");
          }
          guessType(e3) {
            let t3 = "string";
            if ("string" == typeof e3) {
              let i3 = this.trim(`${e3}`), s2 = this.decimalRegExp, o2 = this.trim(i3, true);
              s2 && (o2 = s2.test(o2) ? o2.replace(s2, "$1.$2") : "");
              let r2 = parseFloat(o2);
              +o2 === r2 ? e3 = r2 : t3 = n(this.parseDate(e3)) ? "Date" : "string";
            }
            return "number" == typeof e3 && (t3 = e3 > 31536e6 ? "Date" : "number"), t3;
          }
          on(e3, t3) {
            return i2(this, e3, t3);
          }
          parse(e3) {
            throw this.emit({ type: "parseError", columns: [], headers: [] }), Error("Not implemented");
          }
          parseDate(e3, t3) {
            let i3 = this.options, s2 = t3 || i3.dateFormat, o2 = NaN, r2, l, a;
            if (i3.parseDate)
              o2 = i3.parseDate(e3);
            else {
              if (s2)
                (l = this.dateFormats[s2]) || (l = this.dateFormats["YYYY/mm/dd"]), (a = e3.match(l.regex)) && (o2 = l.parser(a));
              else
                for (r2 in this.dateFormats)
                  if (l = this.dateFormats[r2], a = e3.match(l.regex)) {
                    s2 = r2, o2 = l.parser(a);
                    break;
                  }
              !a && ("object" == typeof (a = Date.parse(e3)) && null !== a && a.getTime ? o2 = a.getTime() - 6e4 * a.getTimezoneOffset() : n(a) && (o2 = a - 6e4 * new Date(a).getTimezoneOffset(), -1 === e3.indexOf("2001") && 2001 === new Date(o2).getFullYear() && (o2 = NaN)));
            }
            return o2;
          }
          trim(e3, t3) {
            return "string" == typeof e3 && (e3 = e3.replace(/^\s+|\s+$/g, ""), t3 && /^[0-9\s]+$/.test(e3) && (e3 = e3.replace(/\s/g, ""))), e3;
          }
        }
        return r.defaultOptions = { dateFormat: "", alternativeFormat: "", startColumn: 0, endColumn: Number.MAX_VALUE, startRow: 0, endRow: Number.MAX_VALUE, firstRowAsNames: true, switchRowsAndColumns: false }, (r || (r = {})).getTableFromColumns = function(t3 = [], i3 = []) {
          let s2 = new e2();
          for (let e3 = 0, n2 = Math.max(i3.length, t3.length); e3 < n2; ++e3)
            s2.setColumn(i3[e3] || `${e3}`, t3[e3]);
          return s2;
        }, r;
      }), i(t, "Data/Converters/CSVConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: i2 } = t2;
        class s extends e2 {
          constructor(e3) {
            let t3 = i2(s.defaultOptions, e3);
            super(t3), this.columns = [], this.headers = [], this.dataTypes = [], this.options = t3;
          }
          export(e3, t3 = this.options) {
            let { useLocalDecimalPoint: i3, lineDelimiter: s2 } = t3, n = false !== this.options.firstRowAsNames, { decimalPoint: o, itemDelimiter: r } = t3;
            o || (o = "," !== r && i3 ? 1.1.toLocaleString()[1] : "."), r || (r = "," === o ? ";" : ",");
            let l = e3.getSortedColumns(t3.usePresentationOrder), a = Object.keys(l), h = [], d = a.length, u = [];
            n && h.push(a.map((e4) => `"${e4}"`).join(r));
            for (let t4 = 0; t4 < d; t4++) {
              let i4;
              let s3 = a[t4], n2 = l[s3], f = n2.length, m = e3.whatIs(s3);
              m && (i4 = m.dataType);
              for (let e4 = 0; e4 < f; e4++) {
                let s4 = n2[e4];
                if (u[e4] || (u[e4] = []), "string" === i4 ? s4 = '"' + s4 + '"' : "number" == typeof s4 ? s4 = String(s4).replace(".", o) : "string" == typeof s4 && (s4 = `"${s4}"`), u[e4][t4] = s4, t4 === d - 1) {
                  let i5 = t4;
                  for (; u[e4].length > 2 && void 0 === u[e4][i5]; )
                    u[e4].pop(), i5--;
                  h.push(u[e4].join(r));
                }
              }
            }
            return h.join(s2);
          }
          parse(e3, t3) {
            let s2 = this.dataTypes, n = i2(this.options, e3), { beforeParse: o, lineDelimiter: r, firstRowAsNames: l, itemDelimiter: a } = n, h, d = 0, { csv: u, startRow: f, endRow: m } = n, c;
            if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers }), u && o && (u = o(u)), u) {
              if (h = u.replace(/\r\n|\r/g, "\n").split(r || "\n"), (!f || f < 0) && (f = 0), (!m || m >= h.length) && (m = h.length - 1), a || (this.guessedItemDelimiter = this.guessDelimiter(h)), l) {
                let e5 = h[0].split(a || this.guessedItemDelimiter || ",");
                for (let t4 = 0; t4 < e5.length; t4++)
                  e5[t4] = e5[t4].trim().replace(/^["']|["']$/g, "");
                this.headers = e5, f++;
              }
              let e4 = 0;
              for (d = f; d <= m; d++)
                "#" === h[d][0] ? e4++ : this.parseCSVRow(h[d], d - f - e4);
              s2.length && s2[0].length && "date" === s2[0][1] && !this.options.dateFormat && this.deduceDateFormat(this.columns[0], null, true);
              for (let e5 = 0, t4 = this.columns.length; e5 < t4; ++e5) {
                c = this.columns[e5];
                for (let t5 = 0, i3 = c.length; t5 < i3; ++t5)
                  if (c[t5] && "string" == typeof c[t5]) {
                    let i4 = this.asGuessedType(c[t5]);
                    i4 instanceof Date && (i4 = i4.getTime()), this.columns[e5][t5] = i4;
                  }
              }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.headers });
          }
          parseCSVRow(e3, t3) {
            let i3 = this, s2 = i3.columns || [], n = i3.dataTypes, { startColumn: o, endColumn: r } = i3.options, l = i3.options.itemDelimiter || i3.guessedItemDelimiter, { decimalPoint: a } = i3.options;
            a && a !== l || (a = i3.guessedDecimalPoint || ".");
            let h = 0, d = "", u = "", f = 0, m = 0, c = (t4) => {
              d = e3[t4];
            }, p = (e4) => {
              n.length < m + 1 && n.push([e4]), n[m][n[m].length - 1] !== e4 && n[m].push(e4);
            }, g = () => {
              if (o > f || f > r) {
                ++f, u = "";
                return;
              }
              if ("string" == typeof u ? !isNaN(parseFloat(u)) && isFinite(u) ? (u = parseFloat(u), p("number")) : isNaN(Date.parse(u)) ? p("string") : (u = u.replace(/\//g, "-"), p("date")) : p("number"), s2.length < m + 1 && s2.push([]), "number" != typeof u && "number" !== i3.guessType(u) && a) {
                let e4 = u;
                u = u.replace(a, "."), "number" !== i3.guessType(u) && (u = e4);
              }
              s2[m][t3] = u, u = "", ++m, ++f;
            };
            if (e3.trim().length && "#" !== e3.trim()[0]) {
              for (; h < e3.length; h++) {
                if (c(h), "#" === d && !/^#[0-F]{3,3}|[0-F]{6,6}/i.test(e3.substring(h))) {
                  g();
                  return;
                }
                if ('"' === d)
                  for (c(++h); h < e3.length && '"' !== d; )
                    u += d, c(++h);
                else
                  d === l ? g() : u += d;
              }
              g();
            }
          }
          guessDelimiter(e3) {
            let t3 = 0, i3 = 0, s2, n = { ",": 0, ";": 0, "	": 0 }, o = e3.length;
            for (let s3 = 0; s3 < o; s3++) {
              let o2 = false, r, l, a, h = "";
              if (s3 > 13)
                break;
              let d = e3[s3];
              for (let e4 = 0; e4 < d.length && (r = d[e4], l = d[e4 + 1], a = d[e4 - 1], "#" !== r); e4++) {
                if ('"' === r) {
                  if (o2) {
                    if ('"' !== a && '"' !== l) {
                      for (; " " === l && e4 < d.length; )
                        l = d[++e4];
                      void 0 !== n[l] && n[l]++, o2 = false;
                    }
                  } else
                    o2 = true;
                } else
                  void 0 !== n[r] ? (isNaN(Date.parse(h = h.trim())) ? (isNaN(Number(h)) || !isFinite(Number(h))) && n[r]++ : n[r]++, h = "") : h += r;
                "," === r && i3++, "." === r && t3++;
              }
            }
            return n[";"] > n[","] ? s2 = ";" : (n[","], n[";"], s2 = ","), t3 > i3 ? this.guessedDecimalPoint = "." : this.guessedDecimalPoint = ",", s2;
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return s.defaultOptions = { ...e2.defaultOptions, lineDelimiter: "\n" }, s;
      }), i(t, "Data/Connectors/CSVConnector.js", [t["Data/Converters/CSVConverter.js"], t["Data/Connectors/DataConnector.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        let { merge: s } = i2;
        class n extends t2 {
          constructor(t3) {
            let i3 = s(n.defaultOptions, t3);
            super(i3), this.converter = new e2(i3), this.options = i3, i3.enablePolling && this.startPolling(1e3 * Math.max(i3.dataRefreshRate || 0, 1));
          }
          load(e3) {
            let t3 = this, i3 = t3.converter, s2 = t3.table, { csv: n2, csvURL: o, dataModifier: r } = t3.options;
            return t3.emit({ type: "load", csv: n2, detail: e3, table: s2 }), Promise.resolve(o ? fetch(o).then((e4) => e4.text()) : n2 || "").then((e4) => (e4 && (s2.deleteColumns(), i3.parse({ csv: e4 }), s2.setColumns(i3.getTable().getColumns())), t3.setModifierOptions(r).then(() => e4))).then((i4) => (t3.emit({ type: "afterLoad", csv: i4, detail: e3, table: s2 }), t3)).catch((i4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: i4, table: s2 }), i4;
            });
          }
        }
        return n.defaultOptions = { csv: "", csvURL: "", enablePolling: false, dataRefreshRate: 1, firstRowAsNames: true }, t2.registerType("CSV", n), n;
      }), i(t, "Data/Converters/GoogleSheetsConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: i2, uniqueKey: s } = t2;
        class n extends e2 {
          constructor(e3) {
            let t3 = i2(n.defaultOptions, e3);
            super(t3), this.columns = [], this.header = [], this.options = t3;
          }
          parse(e3, t3) {
            let n2;
            let o = i2(this.options, e3), r = (o.json && o.json.values || []).map((e4) => e4.slice());
            if (0 === r.length)
              return false;
            this.header = [], this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.header }), this.columns = r;
            for (let e4 = 0, t4 = r.length; e4 < t4; e4++) {
              n2 = r[e4], this.header[e4] = o.firstRowAsNames ? `${n2.shift()}` : s();
              for (let t5 = 0, i3 = n2.length; t5 < i3; ++t5)
                if (n2[t5] && "string" == typeof n2[t5]) {
                  let i4 = this.asGuessedType(n2[t5]);
                  i4 instanceof Date && (i4 = i4.getTime()), this.columns[e4][t5] = i4;
                }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.header });
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.header);
          }
        }
        return n.defaultOptions = { ...e2.defaultOptions }, n;
      }), i(t, "Data/Connectors/GoogleSheetsConnector.js", [t["Data/Connectors/DataConnector.js"], t["Data/Converters/GoogleSheetsConverter.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        let { merge: s, pick: n } = i2;
        class o extends e2 {
          constructor(e3) {
            let i3 = s(o.defaultOptions, e3);
            super(i3), this.converter = new t2(i3), this.options = i3;
          }
          load(e3) {
            let t3 = this, i3 = t3.converter, s2 = t3.table, { dataModifier: n2, dataRefreshRate: r, enablePolling: l, firstRowAsNames: a, googleAPIKey: h, googleSpreadsheetKey: d } = t3.options, u = o.buildFetchURL(h, d, t3.options);
            return t3.emit({ type: "load", detail: e3, table: s2, url: u }), fetch(u).then((e4) => e4.json()).then((e4) => {
              if ("object" == typeof e4 && e4 && "object" == typeof e4.error && e4.error && "number" == typeof e4.error.code && "string" == typeof e4.error.message && "string" == typeof e4.error.status)
                throw Error(e4.error.message);
              return i3.parse({ firstRowAsNames: a, json: e4 }), s2.deleteColumns(), s2.setColumns(i3.getTable().getColumns()), t3.setModifierOptions(n2);
            }).then(() => (t3.emit({ type: "afterLoad", detail: e3, table: s2, url: u }), l && setTimeout(() => t3.load(), 1e3 * Math.max(r || 0, 1)), t3)).catch((i4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: i4, table: s2 }), i4;
            });
          }
        }
        return o.defaultOptions = { googleAPIKey: "", googleSpreadsheetKey: "", worksheet: 1, enablePolling: false, dataRefreshRate: 2, firstRowAsNames: true }, function(e3) {
          let t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          function i3(e4 = {}) {
            let { endColumn: i4, endRow: s2, googleSpreadsheetRange: o2, startColumn: r, startRow: l } = e4;
            return o2 || (t3[r || 0] || "A") + (Math.max(l || 0, 0) + 1) + ":" + (t3[n(i4, 25)] || "Z") + (s2 ? Math.max(s2, 0) : "Z");
          }
          e3.buildFetchURL = function(e4, t4, s2 = {}) {
            return `https://sheets.googleapis.com/v4/spreadsheets/${t4}/values/` + (s2.onlyColumnNames ? "A1:Z1" : i3(s2)) + "?alt=json" + (s2.onlyColumnNames ? "" : "&dateTimeRenderOption=FORMATTED_STRING&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE") + `&prettyPrint=false&key=${e4}`;
          }, e3.buildQueryRange = i3;
        }(o || (o = {})), e2.registerType("GoogleSheets", o), o;
      }), i(t, "Data/Converters/HTMLTableConverter.js", [t["Data/Converters/DataConverter.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: i2 } = t2;
        class s extends e2 {
          constructor(e3) {
            let t3 = i2(s.defaultOptions, e3);
            super(t3), this.columns = [], this.headers = [], this.options = t3, t3.tableElement && (this.tableElement = t3.tableElement, this.tableElementID = t3.tableElement.id);
          }
          export(e3, t3 = this.options) {
            let i3 = false !== t3.firstRowAsNames, s2 = t3.useMultiLevelHeaders, n = e3.getSortedColumns(t3.usePresentationOrder), o = Object.keys(n), r = [], l = o.length, a = [], h = "";
            if (i3) {
              let e4 = [];
              if (s2) {
                for (let t4 of o) {
                  let i4 = (n[t4].shift() || "").toString();
                  e4.push(i4);
                }
                h = this.getTableHeaderHTML(o, e4, t3);
              } else
                h = this.getTableHeaderHTML(void 0, o, t3);
            }
            for (let e4 = 0; e4 < l; e4++) {
              let t4 = n[o[e4]], i4 = t4.length;
              for (let s3 = 0; s3 < i4; s3++) {
                let i5 = t4[s3];
                a[s3] || (a[s3] = []), "string" == typeof i5 || "number" == typeof i5 || void 0 === i5 || (i5 = (i5 || "").toString()), a[s3][e4] = this.getCellHTMLFromValue(e4 ? "td" : "th", null, e4 ? "" : 'scope="row"', i5), e4 === l - 1 && r.push("<tr>" + a[s3].join("") + "</tr>");
              }
            }
            let d = "";
            return t3.tableCaption && (d = '<caption class="highcharts-table-caption">' + t3.tableCaption + "</caption>"), "<table>" + d + h + "<tbody>" + r.join("") + "</tbody></table>";
          }
          getCellHTMLFromValue(e3, t3, i3, s2, n) {
            let o = s2, r = "text" + (t3 ? " " + t3 : "");
            return "number" == typeof o ? (o = o.toString(), "," === n && (o = o.replace(".", n)), r = "number") : s2 || (o = "", r = "empty"), "<" + e3 + (i3 ? " " + i3 : "") + ' class="' + r + '">' + o + "</" + e3 + ">";
          }
          getTableHeaderHTML(e3 = [], t3 = [], i3 = this.options) {
            let { useMultiLevelHeaders: s2, useRowspanHeaders: n } = i3, o = "<thead>", r = 0, l = t3 && t3.length, a, h = 0, d;
            if (s2 && e3 && t3 && !function(e4, t4) {
              let i4 = e4.length;
              if (t4.length !== i4)
                return false;
              for (; --i4; )
                if (e4[i4] !== t4[i4])
                  return false;
              return true;
            }(e3, t3)) {
              for (o += "<tr>"; r < l; ++r)
                (a = e3[r]) === e3[r + 1] ? ++h : h ? (o += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col" colspan="' + (h + 1) + '"', a), h = 0) : (a === t3[r] ? n ? (d = 2, delete t3[r]) : (d = 1, t3[r] = "") : d = 1, o += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col"' + (d > 1 ? ' valign="top" rowspan="' + d + '"' : ""), a));
              o += "</tr>";
            }
            if (t3) {
              for (o += "<tr>", r = 0, l = t3.length; r < l; ++r)
                void 0 !== t3[r] && (o += this.getCellHTMLFromValue("th", null, 'scope="col"', t3[r]));
              o += "</tr>";
            }
            return o + "</thead>";
          }
          parse(e3, t3) {
            let s2 = [], n = [], o = i2(this.options, e3), { endRow: r, startColumn: l, endColumn: a, firstRowAsNames: h } = o, d = o.tableElement || this.tableElement;
            if (!(d instanceof HTMLElement)) {
              this.emit({ type: "parseError", columns: s2, detail: t3, headers: n, error: "Not a valid HTML Table" });
              return;
            }
            this.tableElement = d, this.tableElementID = d.id, this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers });
            let u = d.getElementsByTagName("tr"), f = u.length, m = 0, c, { startRow: p } = o;
            if (h && f) {
              let e4 = u[0].children, t4 = e4.length;
              for (let i3 = l; i3 < t4 && !(i3 > a); i3++)
                ("TD" === (c = e4[i3]).tagName || "TH" === c.tagName) && n.push(c.innerHTML);
              p++;
            }
            for (; m < f; ) {
              if (m >= p && m <= r) {
                let e4 = u[m].children, t4 = e4.length, i3 = 0;
                for (; i3 < t4; ) {
                  let t5 = i3 - l, n2 = s2[t5];
                  if (("TD" === (c = e4[i3]).tagName || "TH" === c.tagName) && i3 >= l && i3 <= a) {
                    s2[t5] || (s2[t5] = []);
                    let e5 = this.asGuessedType(c.innerHTML);
                    e5 instanceof Date && (e5 = e5.getTime()), s2[t5][m - p] = e5;
                    let i4 = 1;
                    for (; m - p >= i4 && void 0 === n2[m - p - i4]; )
                      n2[m - p - i4] = null, i4++;
                  }
                  i3++;
                }
              }
              m++;
            }
            this.columns = s2, this.headers = n, this.emit({ type: "afterParse", columns: s2, detail: t3, headers: n });
          }
          getTable() {
            return e2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return s.defaultOptions = { ...e2.defaultOptions, useRowspanHeaders: true, useMultiLevelHeaders: true }, s;
      }), i(t, "Data/Connectors/HTMLTableConnector.js", [t["Data/Connectors/DataConnector.js"], t["Core/Globals.js"], t["Data/Converters/HTMLTableConverter.js"], t["Core/Utilities.js"]], function(e2, t2, i2, s) {
        let { win: n } = t2, { merge: o } = s;
        class r extends e2 {
          constructor(e3) {
            let t3 = o(r.defaultOptions, e3);
            super(t3), this.converter = new i2(t3), this.options = t3;
          }
          load(e3) {
            let t3;
            let i3 = this, s2 = i3.converter, r2 = i3.table, { dataModifier: l, table: a } = i3.options;
            if (i3.emit({ type: "load", detail: e3, table: r2, tableElement: i3.tableElement }), "string" == typeof a ? (i3.tableID = a, t3 = n.document.getElementById(a)) : (t3 = a, i3.tableID = t3.id), i3.tableElement = t3 || void 0, !i3.tableElement) {
              let t4 = "HTML table not provided, or element with ID not found";
              return i3.emit({ type: "loadError", detail: e3, error: t4, table: r2 }), Promise.reject(Error(t4));
            }
            return s2.parse(o({ tableElement: i3.tableElement }, i3.options), e3), r2.deleteColumns(), r2.setColumns(s2.getTable().getColumns()), i3.setModifierOptions(l).then(() => (i3.emit({ type: "afterLoad", detail: e3, table: r2, tableElement: i3.tableElement }), i3));
          }
        }
        return r.defaultOptions = { table: "" }, e2.registerType("HTMLTable", r), r;
      }), i(t, "Data/Converters/JSONConverter.js", [t["Data/Converters/DataConverter.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        let { error: s, isArray: n, merge: o, objectEach: r } = i2;
        class l extends e2 {
          constructor(e3) {
            let i3 = o(l.defaultOptions, e3);
            super(i3), this.columns = [], this.headers = [], this.options = i3, this.table = new t2();
          }
          parse(e3, t3) {
            let { beforeParse: i3, orientation: l2, firstRowAsNames: a, columnNames: h } = e3 = o(this.options, e3), d = e3.data;
            if (d) {
              if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: t3, headers: this.headers }), i3 && (d = i3(d)), d = d.slice(), "columns" === l2)
                for (let e4 = 0, t4 = d.length; e4 < t4; e4++) {
                  let t5 = d[e4];
                  if (!(t5 instanceof Array))
                    return;
                  this.headers instanceof Array ? (a ? this.headers.push(`${t5.shift()}`) : h && h instanceof Array && this.headers.push(h[e4]), this.table.setColumn(this.headers[e4] || e4.toString(), t5)) : s("JSONConverter: Invalid `columnNames` option.", false);
                }
              else if ("rows" === l2) {
                a ? this.headers = d.shift() : h && (this.headers = h);
                for (let e4 = 0, t4 = d.length; e4 < t4; e4++) {
                  let t5 = d[e4];
                  if (n(t5))
                    for (let e5 = 0, i4 = t5.length; e5 < i4; e5++)
                      this.columns.length < e5 + 1 && this.columns.push([]), this.columns[e5].push(t5[e5]), this.headers instanceof Array ? this.table.setColumn(this.headers[e5] || e5.toString(), this.columns[e5]) : s("JSONConverter: Invalid `columnNames` option.", false);
                  else {
                    let i4 = this.headers;
                    if (i4 && !(i4 instanceof Array)) {
                      let e5 = {};
                      r(i4, (i5, s2) => {
                        e5[s2] = i5.reduce((e6, t6) => e6[t6], t5);
                      }), t5 = e5;
                    }
                    this.table.setRows([t5], e4);
                  }
                }
              }
              this.emit({ type: "afterParse", columns: this.columns, detail: t3, headers: this.headers });
            }
          }
          getTable() {
            return this.table;
          }
        }
        return l.defaultOptions = { ...e2.defaultOptions, data: [], orientation: "rows" }, l;
      }), i(t, "Data/Connectors/JSONConnector.js", [t["Data/Connectors/DataConnector.js"], t["Core/Utilities.js"], t["Data/Converters/JSONConverter.js"]], function(e2, t2, i2) {
        let { merge: s } = t2;
        class n extends e2 {
          constructor(e3) {
            let t3 = s(n.defaultOptions, e3);
            super(t3), this.converter = new i2(t3), this.options = t3, t3.enablePolling && this.startPolling(1e3 * Math.max(t3.dataRefreshRate || 0, 1));
          }
          load(e3) {
            let t3 = this, i3 = t3.converter, s2 = t3.table, { data: n2, dataUrl: o, dataModifier: r } = t3.options;
            return t3.emit({ type: "load", data: n2, detail: e3, table: s2 }), Promise.resolve(o ? fetch(o).then((e4) => e4.json()) : n2 || []).then((e4) => (e4 && (s2.deleteColumns(), i3.parse({ data: e4 }), s2.setColumns(i3.getTable().getColumns())), t3.setModifierOptions(r).then(() => e4))).then((i4) => (t3.emit({ type: "afterLoad", data: i4, detail: e3, table: s2 }), t3)).catch((i4) => {
              throw t3.emit({ type: "loadError", detail: e3, error: i4, table: s2 }), i4;
            });
          }
        }
        return n.defaultOptions = { data: [], enablePolling: false, dataRefreshRate: 0, firstRowAsNames: true, orientation: "rows" }, e2.registerType("JSON", n), n;
      }), i(t, "Data/Modifiers/ChainModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: i2 } = t2;
        class s extends e2 {
          constructor(t3, ...n) {
            super(), this.chain = n, this.options = i2(s.defaultOptions, t3);
            let o = this.options.chain || [];
            for (let t4 = 0, i3 = o.length, s2, r; t4 < i3; ++t4)
              (s2 = o[t4]).type && (r = e2.types[s2.type]) && n.push(new r(s2));
          }
          add(e3, t3) {
            this.emit({ type: "addModifier", detail: t3, modifier: e3 }), this.chain.push(e3), this.emit({ type: "addModifier", detail: t3, modifier: e3 });
          }
          clear(e3) {
            this.emit({ type: "clearChain", detail: e3 }), this.chain.length = 0, this.emit({ type: "afterClearChain", detail: e3 });
          }
          modify(e3, t3) {
            let i3 = this.options.reverse ? this.chain.slice().reverse() : this.chain.slice();
            e3.modified === e3 && (e3.modified = e3.clone(false, t3));
            let s2 = Promise.resolve(e3);
            for (let e4 = 0, n = i3.length; e4 < n; ++e4) {
              let n2 = i3[e4];
              s2 = s2.then((e5) => n2.modify(e5.modified, t3));
            }
            return (s2 = s2.then((t4) => (e3.modified.deleteColumns(), e3.modified.setColumns(t4.modified.getColumns()), e3))).catch((i4) => {
              throw this.emit({ type: "error", detail: t3, table: e3 }), i4;
            });
          }
          modifyCell(e3, t3, i3, s2, n) {
            let o = this.options.reverse ? this.chain.reverse() : this.chain;
            if (o.length) {
              let r = e3.clone();
              for (let e4 = 0, l = o.length; e4 < l; ++e4)
                o[e4].modifyCell(r, t3, i3, s2, n), r = r.modified;
              e3.modified = r;
            }
            return e3;
          }
          modifyColumns(e3, t3, i3, s2) {
            let n = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (n.length) {
              let o = e3.clone();
              for (let e4 = 0, r = n.length; e4 < r; ++e4)
                n[e4].modifyColumns(o, t3, i3, s2), o = o.modified;
              e3.modified = o;
            }
            return e3;
          }
          modifyRows(e3, t3, i3, s2) {
            let n = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (n.length) {
              let o = e3.clone();
              for (let e4 = 0, r = n.length; e4 < r; ++e4)
                n[e4].modifyRows(o, t3, i3, s2), o = o.modified;
              e3.modified = o;
            }
            return e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let i3 = this.options.reverse ? this.chain.reverse() : this.chain.slice(), s2 = e3.modified;
            for (let e4 = 0, n = i3.length; e4 < n; ++e4)
              s2 = i3[e4].modifyTable(s2, t3).modified;
            return e3.modified = s2, this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
          remove(e3, t3) {
            let i3 = this.chain;
            this.emit({ type: "removeModifier", detail: t3, modifier: e3 }), i3.splice(i3.indexOf(e3), 1), this.emit({ type: "afterRemoveModifier", detail: t3, modifier: e3 });
          }
        }
        return s.defaultOptions = { type: "Chain" }, e2.registerType("Chain", s), s;
      }), i(t, "Data/Modifiers/InvertModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: i2 } = t2;
        class s extends e2 {
          constructor(e3) {
            super(), this.options = i2(s.defaultOptions, e3);
          }
          modifyCell(e3, t3, i3, s2, n) {
            let o = e3.modified, r = o.getRowIndexBy("columnNames", t3);
            return void 0 === r ? o.setColumns(this.modifyTable(e3.clone()).getColumns(), void 0, n) : o.setCell(`${i3}`, r, s2, n), e3;
          }
          modifyColumns(e3, t3, i3, s2) {
            let n = e3.modified, o = n.getColumn("columnNames") || [], r = e3.getColumnNames(), l = e3.getRowCount() !== o.length;
            if (!l) {
              for (let e4 = 0, t4 = r.length; e4 < t4; ++e4)
                if (r[e4] !== o[e4]) {
                  l = true;
                  break;
                }
            }
            if (l)
              return this.modifyTable(e3, s2);
            r = Object.keys(t3);
            for (let e4 = 0, o2 = r.length, l2, a, h; e4 < o2; ++e4) {
              l2 = t3[a = r[e4]], h = n.getRowIndexBy("columnNames", a) || n.getRowCount();
              for (let e5 = 0, t4 = i3, o3 = l2.length; e5 < o3; ++e5, ++t4)
                n.setCell(`${t4}`, h, l2[e5], s2);
            }
            return e3;
          }
          modifyRows(e3, t3, i3, s2) {
            let n = e3.getColumnNames(), o = e3.modified, r = o.getColumn("columnNames") || [], l = e3.getRowCount() !== r.length;
            if (!l) {
              for (let e4 = 0, t4 = n.length; e4 < t4; ++e4)
                if (n[e4] !== r[e4]) {
                  l = true;
                  break;
                }
            }
            if (l)
              return this.modifyTable(e3, s2);
            for (let e4 = 0, r2 = i3, l2 = t3.length, a; e4 < l2; ++e4, ++r2)
              if ((a = t3[e4]) instanceof Array)
                o.setColumn(`${r2}`, a);
              else
                for (let e5 = 0, t4 = n.length; e5 < t4; ++e5)
                  o.setCell(`${r2}`, e5, a[n[e5]], s2);
            return e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let i3 = e3.modified;
            if (e3.hasColumns(["columnNames"])) {
              let t4 = ((e3.deleteColumns(["columnNames"]) || {}).columnNames || []).map((e4) => `${e4}`), s2 = {};
              for (let i4 = 0, n = e3.getRowCount(), o; i4 < n; ++i4)
                (o = e3.getRow(i4)) && (s2[t4[i4]] = o);
              i3.deleteColumns(), i3.setColumns(s2);
            } else {
              let t4 = {};
              for (let i4 = 0, s2 = e3.getRowCount(), n; i4 < s2; ++i4)
                (n = e3.getRow(i4)) && (t4[`${i4}`] = n);
              t4.columnNames = e3.getColumnNames(), i3.deleteColumns(), i3.setColumns(t4);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return s.defaultOptions = { type: "Invert" }, e2.registerType("Invert", s), s;
      }), i(t, "Data/Modifiers/RangeModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Core/Utilities.js"]], function(e2, t2) {
        let { merge: i2 } = t2;
        class s extends e2 {
          constructor(e3) {
            super(), this.options = i2(s.defaultOptions, e3);
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let { additive: i3, ranges: s2, strict: n } = this.options;
            if (s2.length) {
              let t4 = e3.modified, o = e3.getColumns(), r = [];
              for (let l = 0, a = s2.length, h, d; l < a; ++l)
                if (h = s2[l], !n || typeof h.minValue == typeof h.maxValue) {
                  l > 0 && !i3 && (t4.deleteRows(), t4.setRows(r), o = t4.getColumns(), r = []), d = o[h.column] || [];
                  for (let s3 = 0, o2 = d.length, l2, a2; s3 < o2; ++s3) {
                    switch (typeof (l2 = d[s3])) {
                      default:
                        continue;
                      case "boolean":
                      case "number":
                      case "string":
                    }
                    (!n || typeof l2 == typeof h.minValue) && l2 >= h.minValue && l2 <= h.maxValue && (a2 = i3 ? e3.getRow(s3) : t4.getRow(s3)) && r.push(a2);
                  }
                }
              t4.deleteRows(), t4.setRows(r);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return s.defaultOptions = { type: "Range", ranges: [] }, e2.registerType("Range", s), s;
      }), i(t, "Data/Modifiers/SortModifier.js", [t["Data/Modifiers/DataModifier.js"], t["Data/DataTable.js"], t["Core/Utilities.js"]], function(e2, t2, i2) {
        let { merge: s } = i2;
        class n extends e2 {
          static ascending(e3, t3) {
            return (e3 || 0) < (t3 || 0) ? -1 : (e3 || 0) > (t3 || 0) ? 1 : 0;
          }
          static descending(e3, t3) {
            return (t3 || 0) < (e3 || 0) ? -1 : (t3 || 0) > (e3 || 0) ? 1 : 0;
          }
          constructor(e3) {
            super(), this.options = s(n.defaultOptions, e3);
          }
          getRowReferences(e3) {
            let t3 = e3.getRows(), i3 = [];
            for (let e4 = 0, s2 = t3.length; e4 < s2; ++e4)
              i3.push({ index: e4, row: t3[e4] });
            return i3;
          }
          modifyCell(e3, i3, s2, n2, o) {
            let { orderByColumn: r, orderInColumn: l } = this.options;
            return i3 === r && (l ? (e3.modified.setCell(i3, s2, n2), e3.modified.setColumn(l, this.modifyTable(new t2({ columns: e3.getColumns([r, l]) })).modified.getColumn(l))) : this.modifyTable(e3, o)), e3;
          }
          modifyColumns(e3, i3, s2, n2) {
            let { orderByColumn: o, orderInColumn: r } = this.options, l = Object.keys(i3);
            return l.indexOf(o) > -1 && (r && i3[l[0]].length ? (e3.modified.setColumns(i3, s2), e3.modified.setColumn(r, this.modifyTable(new t2({ columns: e3.getColumns([o, r]) })).modified.getColumn(r))) : this.modifyTable(e3, n2)), e3;
          }
          modifyRows(e3, i3, s2, n2) {
            let { orderByColumn: o, orderInColumn: r } = this.options;
            return r && i3.length ? (e3.modified.setRows(i3, s2), e3.modified.setColumn(r, this.modifyTable(new t2({ columns: e3.getColumns([o, r]) })).modified.getColumn(r))) : this.modifyTable(e3, n2), e3;
          }
          modifyTable(e3, t3) {
            this.emit({ type: "modify", detail: t3, table: e3 });
            let i3 = e3.getColumnNames(), s2 = e3.getRowCount(), o = this.getRowReferences(e3), { direction: r, orderByColumn: l, orderInColumn: a } = this.options, h = "asc" === r ? n.ascending : n.descending, d = i3.indexOf(l), u = e3.modified;
            if (-1 !== d && o.sort((e4, t4) => h(e4.row[d], t4.row[d])), a) {
              let e4 = [];
              for (let t4 = 0; t4 < s2; ++t4)
                e4[o[t4].index] = t4;
              u.setColumns({ [a]: e4 });
            } else {
              let e4 = [];
              for (let t4 = 0; t4 < s2; ++t4)
                e4.push(o[t4].row);
              u.setRows(e4, 0);
            }
            return this.emit({ type: "afterModify", detail: t3, table: e3 }), e3;
          }
        }
        return n.defaultOptions = { type: "Sort", direction: "desc", orderByColumn: "y" }, e2.registerType("Sort", n), n;
      }), i(t, "masters/datagrid.src.js", [t["Data/Connectors/DataConnector.js"], t["Data/DataCursor.js"], t["DataGrid/DataGrid.js"], t["Data/Modifiers/DataModifier.js"], t["Data/DataPool.js"], t["Data/DataTable.js"], t["DataGrid/Globals.js"]], function(e2, t2, i2, s, n, o, r) {
        return r.DataConnector = e2, r.DataCursor = t2, r.DataGrid = i2, r.DataModifier = s, r.DataPool = n, r.DataTable = o, r.win.DataGrid || (r.win.DataGrid = r), r;
      }), t["masters/datagrid.src.js"]._modules = t, t["masters/datagrid.src.js"];
    });
  }
});
export default require_datagrid();
//# sourceMappingURL=@highcharts_dashboards_datagrid.js.map
