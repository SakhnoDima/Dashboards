import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/@highcharts/dashboards/dashboards.js
var require_dashboards = __commonJS({
  "node_modules/@highcharts/dashboards/dashboards.js"(exports, module) {
    !/**
    * Highcharts Dashboards v2.0.0 (2024-03-13)
    *
    * (c) 2009-2024 Highsoft AS
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof module && module.exports ? (e.default = e, module.exports = t && t.document ? e(t) : e) : "function" == typeof define && define.amd ? define("dashboards/dashboards", function() {
        return e(t);
      }) : (t.Dashboards && t.Dashboards.error(16, true), t.Dashboards = e(t));
    }("undefined" != typeof window ? window : exports, function(t) {
      "use strict";
      var e = {};
      function s(e2, s2, i, o) {
        e2.hasOwnProperty(s2) || (e2[s2] = o.apply(null, i), "function" == typeof CustomEvent && t.dispatchEvent(new CustomEvent("DashboardsModuleLoaded", { detail: { path: s2, module: e2[s2] } })));
      }
      return s(e, "Core/Globals.js", [], function() {
        var e2, s2;
        return (s2 = e2 || (e2 = {})).SVG_NS = "http://www.w3.org/2000/svg", s2.product = "Highcharts", s2.version = "2.0.0", s2.win = void 0 !== t ? t : {}, s2.doc = s2.win.document, s2.svg = s2.doc && s2.doc.createElementNS && !!s2.doc.createElementNS(s2.SVG_NS, "svg").createSVGRect, s2.userAgent = s2.win.navigator && s2.win.navigator.userAgent || "", s2.isChrome = -1 !== s2.userAgent.indexOf("Chrome"), s2.isFirefox = -1 !== s2.userAgent.indexOf("Firefox"), s2.isMS = /(edge|msie|trident)/i.test(s2.userAgent) && !s2.win.opera, s2.isSafari = !s2.isChrome && -1 !== s2.userAgent.indexOf("Safari"), s2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(s2.userAgent), s2.isWebKit = -1 !== s2.userAgent.indexOf("AppleWebKit"), s2.deg2rad = 2 * Math.PI / 360, s2.hasBidiBug = s2.isFirefox && 4 > parseInt(s2.userAgent.split("Firefox/")[1], 10), s2.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], s2.noop = function() {
        }, s2.supportsPassiveEvents = function() {
          let t2 = false;
          if (!s2.isMS) {
            let e3 = Object.defineProperty({}, "passive", { get: function() {
              t2 = true;
            } });
            s2.win.addEventListener && s2.win.removeEventListener && (s2.win.addEventListener("testPassive", s2.noop, e3), s2.win.removeEventListener("testPassive", s2.noop, e3));
          }
          return t2;
        }(), s2.charts = [], s2.composed = [], s2.dateFormats = {}, s2.seriesTypes = {}, s2.symbolSizes = {}, s2.chartCount = 0, e2;
      }), s(e, "Core/Utilities.js", [e["Core/Globals.js"]], function(t2) {
        let e2;
        let { charts: s2, doc: i, win: o } = t2;
        function n(e3, s3, i2, r2) {
          let a2 = s3 ? "Highcharts error" : "Highcharts warning";
          32 === e3 && (e3 = `${a2}: Deprecated member`);
          let l2 = u(e3), h2 = l2 ? `${a2} #${e3}: www.highcharts.com/errors/${e3}/` : e3.toString();
          if (void 0 !== r2) {
            let t3 = "";
            l2 && (h2 += "?"), v(r2, function(e4, s4) {
              t3 += `
 - ${s4}: ${e4}`, l2 && (h2 += encodeURI(s4) + "=" + encodeURI(e4));
            }), h2 += t3;
          }
          D(t2, "displayError", { chart: i2, code: e3, message: h2, params: r2 }, function() {
            if (s3)
              throw Error(h2);
            o.console && -1 === n.messages.indexOf(h2) && console.warn(h2);
          }), n.messages.push(h2);
        }
        function r(t3, e3) {
          return parseInt(t3, e3 || 10);
        }
        function a(t3) {
          return "string" == typeof t3;
        }
        function l(t3) {
          let e3 = Object.prototype.toString.call(t3);
          return "[object Array]" === e3 || "[object Array Iterator]" === e3;
        }
        function h(t3, e3) {
          return !!t3 && "object" == typeof t3 && (!e3 || !l(t3));
        }
        function d(t3) {
          return h(t3) && "number" == typeof t3.nodeType;
        }
        function c(t3) {
          let e3 = t3 && t3.constructor;
          return !!(h(t3, true) && !d(t3) && e3 && e3.name && "Object" !== e3.name);
        }
        function u(t3) {
          return "number" == typeof t3 && !isNaN(t3) && t3 < 1 / 0 && t3 > -1 / 0;
        }
        function p(t3) {
          return null != t3;
        }
        function m(t3, e3, s3) {
          let i2;
          let o2 = a(e3) && !p(s3), n2 = (e4, s4) => {
            p(e4) ? t3.setAttribute(s4, e4) : o2 ? (i2 = t3.getAttribute(s4)) || "class" !== s4 || (i2 = t3.getAttribute(s4 + "Name")) : t3.removeAttribute(s4);
          };
          return a(e3) ? n2(s3, e3) : v(e3, n2), i2;
        }
        function f(t3) {
          return l(t3) ? t3 : [t3];
        }
        function g(t3, e3) {
          let s3;
          for (s3 in t3 || (t3 = {}), e3)
            t3[s3] = e3[s3];
          return t3;
        }
        function y() {
          let t3 = arguments, e3 = t3.length;
          for (let s3 = 0; s3 < e3; s3++) {
            let e4 = t3[s3];
            if (null != e4)
              return e4;
          }
        }
        function b(t3, e3) {
          g(t3.style, e3);
        }
        function C(t3) {
          return Math.pow(10, Math.floor(Math.log(t3) / Math.LN10));
        }
        function w(t3, e3) {
          return t3 > 1e14 ? t3 : parseFloat(t3.toPrecision(e3 || 14));
        }
        (n || (n = {})).messages = [], Math.easeInOutSine = function(t3) {
          return -0.5 * (Math.cos(Math.PI * t3) - 1);
        };
        let O = Array.prototype.find ? function(t3, e3) {
          return t3.find(e3);
        } : function(t3, e3) {
          let s3;
          let i2 = t3.length;
          for (s3 = 0; s3 < i2; s3++)
            if (e3(t3[s3], s3))
              return t3[s3];
        };
        function v(t3, e3, s3) {
          for (let i2 in t3)
            Object.hasOwnProperty.call(t3, i2) && e3.call(s3 || t3[i2], t3[i2], i2, t3);
        }
        function x(t3, e3, s3) {
          function i2(e4, s4) {
            let i3 = t3.removeEventListener;
            i3 && i3.call(t3, e4, s4, false);
          }
          function o2(s4) {
            let o3, n3;
            t3.nodeName && (e3 ? (o3 = {})[e3] = true : o3 = s4, v(o3, function(t4, e4) {
              if (s4[e4])
                for (n3 = s4[e4].length; n3--; )
                  i2(e4, s4[e4][n3].fn);
            }));
          }
          let n2 = "function" == typeof t3 && t3.prototype || t3;
          if (Object.hasOwnProperty.call(n2, "hcEvents")) {
            let t4 = n2.hcEvents;
            if (e3) {
              let n3 = t4[e3] || [];
              s3 ? (t4[e3] = n3.filter(function(t5) {
                return s3 !== t5.fn;
              }), i2(e3, s3)) : (o2(t4), t4[e3] = []);
            } else
              o2(t4), delete n2.hcEvents;
          }
        }
        function D(e3, s3, o2, n2) {
          if (o2 = o2 || {}, i.createEvent && (e3.dispatchEvent || e3.fireEvent && e3 !== t2)) {
            let t3 = i.createEvent("Events");
            t3.initEvent(s3, true, true), o2 = g(t3, o2), e3.dispatchEvent ? e3.dispatchEvent(o2) : e3.fireEvent(s3, o2);
          } else if (e3.hcEvents) {
            o2.target || g(o2, { preventDefault: function() {
              o2.defaultPrevented = true;
            }, target: e3, type: s3 });
            let t3 = [], i2 = e3, n3 = false;
            for (; i2.hcEvents; )
              Object.hasOwnProperty.call(i2, "hcEvents") && i2.hcEvents[s3] && (t3.length && (n3 = true), t3.unshift.apply(t3, i2.hcEvents[s3])), i2 = Object.getPrototypeOf(i2);
            n3 && t3.sort((t4, e4) => t4.order - e4.order), t3.forEach((t4) => {
              false === t4.fn.call(e3, o2) && o2.preventDefault();
            });
          }
          n2 && !o2.defaultPrevented && n2.call(e3, o2);
        }
        v({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function(e3, s3) {
          t2[s3] = function(t3) {
            return n(32, false, void 0, { [`Highcharts.${s3}`]: `use Array.${e3}` }), Array.prototype[e3].apply(t3, [].slice.call(arguments, 1));
          };
        });
        let T = function() {
          let t3 = Math.random().toString(36).substring(2, 9) + "-", s3 = 0;
          return function() {
            return "highcharts-" + (e2 ? "" : t3) + s3++;
          };
        }();
        return o.jQuery && (o.jQuery.fn.highcharts = function() {
          let e3 = [].slice.call(arguments);
          if (this[0])
            return e3[0] ? (new t2[a(e3[0]) ? e3.shift() : "Chart"](this[0], e3[0], e3[1]), this) : s2[m(this[0], "data-highcharts-chart")];
        }), { addEvent: function(e3, s3, i2, o2 = {}) {
          let n2 = "function" == typeof e3 && e3.prototype || e3;
          Object.hasOwnProperty.call(n2, "hcEvents") || (n2.hcEvents = {});
          let r2 = n2.hcEvents;
          t2.Point && e3 instanceof t2.Point && e3.series && e3.series.chart && (e3.series.chart.runTrackerClick = true);
          let a2 = e3.addEventListener;
          a2 && a2.call(e3, s3, i2, !!t2.supportsPassiveEvents && { passive: void 0 === o2.passive ? -1 !== s3.indexOf("touch") : o2.passive, capture: false }), r2[s3] || (r2[s3] = []);
          let l2 = { fn: i2, order: "number" == typeof o2.order ? o2.order : 1 / 0 };
          return r2[s3].push(l2), r2[s3].sort((t3, e4) => t3.order - e4.order), function() {
            x(e3, s3, i2);
          };
        }, arrayMax: function(t3) {
          let e3 = t3.length, s3 = t3[0];
          for (; e3--; )
            t3[e3] > s3 && (s3 = t3[e3]);
          return s3;
        }, arrayMin: function(t3) {
          let e3 = t3.length, s3 = t3[0];
          for (; e3--; )
            t3[e3] < s3 && (s3 = t3[e3]);
          return s3;
        }, attr: m, clamp: function(t3, e3, s3) {
          return t3 > e3 ? t3 < s3 ? t3 : s3 : e3;
        }, clearTimeout: function(t3) {
          p(t3) && clearTimeout(t3);
        }, correctFloat: w, createElement: function(t3, e3, s3, o2, n2) {
          let r2 = i.createElement(t3);
          return e3 && g(r2, e3), n2 && b(r2, { padding: "0", border: "none", margin: "0" }), s3 && b(r2, s3), o2 && o2.appendChild(r2), r2;
        }, css: b, defined: p, destroyObjectProperties: function(t3, e3, s3) {
          v(t3, function(i2, o2) {
            i2 !== e3 && (i2 == null ? void 0 : i2.destroy) && i2.destroy(), ((i2 == null ? void 0 : i2.destroy) || !s3) && delete t3[o2];
          });
        }, diffObjects: function(t3, e3, s3, i2) {
          let o2 = {};
          return function t4(e4, o3, n2, r2) {
            let a2 = s3 ? o3 : e4;
            v(e4, function(s4, d2) {
              if (!r2 && i2 && i2.indexOf(d2) > -1 && o3[d2]) {
                s4 = f(s4), n2[d2] = [];
                for (let e5 = 0; e5 < Math.max(s4.length, o3[d2].length); e5++)
                  o3[d2][e5] && (void 0 === s4[e5] ? n2[d2][e5] = o3[d2][e5] : (n2[d2][e5] = {}, t4(s4[e5], o3[d2][e5], n2[d2][e5], r2 + 1)));
              } else
                h(s4, true) && !s4.nodeType ? (n2[d2] = l(s4) ? [] : {}, t4(s4, o3[d2] || {}, n2[d2], r2 + 1), 0 !== Object.keys(n2[d2]).length || "colorAxis" === d2 && 0 === r2 || delete n2[d2]) : (e4[d2] !== o3[d2] || d2 in e4 && !(d2 in o3)) && "__proto__" !== d2 && "constructor" !== d2 && (n2[d2] = a2[d2]);
            });
          }(t3, e3, o2, 0), o2;
        }, discardElement: function(t3) {
          t3 && t3.parentElement && t3.parentElement.removeChild(t3);
        }, erase: function(t3, e3) {
          let s3 = t3.length;
          for (; s3--; )
            if (t3[s3] === e3) {
              t3.splice(s3, 1);
              break;
            }
        }, error: n, extend: g, extendClass: function(t3, e3) {
          let s3 = function() {
          };
          return s3.prototype = new t3(), g(s3.prototype, e3), s3;
        }, find: O, fireEvent: D, getClosestDistance: function(t3, e3) {
          let s3, i2, o2, n2;
          let r2 = !e3;
          return t3.forEach((t4) => {
            if (t4.length > 1)
              for (n2 = i2 = t4.length - 1; n2 > 0; n2--)
                (o2 = t4[n2] - t4[n2 - 1]) < 0 && !r2 ? (e3 == null ? void 0 : e3(), e3 = void 0) : o2 && (void 0 === s3 || o2 < s3) && (s3 = o2);
          }), s3;
        }, getMagnitude: C, getNestedProperty: function(t3, e3) {
          let s3 = t3.split(".");
          for (; s3.length && p(e3); ) {
            let t4 = s3.shift();
            if (void 0 === t4 || "__proto__" === t4)
              return;
            if ("this" === t4) {
              let t5;
              return h(e3) && (t5 = e3["@this"]), t5 ?? e3;
            }
            let i2 = e3[t4];
            if (!p(i2) || "function" == typeof i2 || "number" == typeof i2.nodeType || i2 === o)
              return;
            e3 = i2;
          }
          return e3;
        }, getStyle: function t3(e3, s3, i2) {
          let n2;
          if ("width" === s3) {
            let s4 = Math.min(e3.offsetWidth, e3.scrollWidth), i3 = e3.getBoundingClientRect && e3.getBoundingClientRect().width;
            return i3 < s4 && i3 >= s4 - 1 && (s4 = Math.floor(i3)), Math.max(0, s4 - (t3(e3, "padding-left", true) || 0) - (t3(e3, "padding-right", true) || 0));
          }
          if ("height" === s3)
            return Math.max(0, Math.min(e3.offsetHeight, e3.scrollHeight) - (t3(e3, "padding-top", true) || 0) - (t3(e3, "padding-bottom", true) || 0));
          let a2 = o.getComputedStyle(e3, void 0);
          return a2 && (n2 = a2.getPropertyValue(s3), y(i2, "opacity" !== s3) && (n2 = r(n2))), n2;
        }, inArray: function(t3, e3, s3) {
          return n(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" }), e3.indexOf(t3, s3);
        }, insertItem: function(t3, e3) {
          let s3;
          let i2 = t3.options.index, o2 = e3.length;
          for (s3 = t3.options.isInternal ? o2 : 0; s3 < o2 + 1; s3++)
            if (!e3[s3] || u(i2) && i2 < y(e3[s3].options.index, e3[s3]._i) || e3[s3].options.isInternal) {
              e3.splice(s3, 0, t3);
              break;
            }
          return s3;
        }, isArray: l, isClass: c, isDOMElement: d, isFunction: function(t3) {
          return "function" == typeof t3;
        }, isNumber: u, isObject: h, isString: a, keys: function(t3) {
          return n(32, false, void 0, { "Highcharts.keys": "use Object.keys" }), Object.keys(t3);
        }, merge: function() {
          let t3, e3 = arguments, s3 = {}, i2 = function(t4, e4) {
            return "object" != typeof t4 && (t4 = {}), v(e4, function(s4, o3) {
              "__proto__" !== o3 && "constructor" !== o3 && (!h(s4, true) || c(s4) || d(s4) ? t4[o3] = e4[o3] : t4[o3] = i2(t4[o3] || {}, s4));
            }), t4;
          };
          true === e3[0] && (s3 = e3[1], e3 = Array.prototype.slice.call(e3, 2));
          let o2 = e3.length;
          for (t3 = 0; t3 < o2; t3++)
            s3 = i2(s3, e3[t3]);
          return s3;
        }, normalizeTickInterval: function(t3, e3, s3, i2, o2) {
          let n2, r2 = t3;
          s3 = y(s3, C(t3));
          let a2 = t3 / s3;
          for (!e3 && (e3 = o2 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === i2 && (1 === s3 ? e3 = e3.filter(function(t4) {
            return t4 % 1 == 0;
          }) : s3 <= 0.1 && (e3 = [1 / s3]))), n2 = 0; n2 < e3.length && (r2 = e3[n2], (!o2 || !(r2 * s3 >= t3)) && (o2 || !(a2 <= (e3[n2] + (e3[n2 + 1] || e3[n2])) / 2))); n2++)
            ;
          return w(r2 * s3, -Math.round(Math.log(1e-3) / Math.LN10));
        }, objectEach: v, offset: function(t3) {
          let e3 = i.documentElement, s3 = t3.parentElement || t3.parentNode ? t3.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
          return { top: s3.top + (o.pageYOffset || e3.scrollTop) - (e3.clientTop || 0), left: s3.left + (o.pageXOffset || e3.scrollLeft) - (e3.clientLeft || 0), width: s3.width, height: s3.height };
        }, pad: function(t3, e3, s3) {
          return Array((e3 || 2) + 1 - String(t3).replace("-", "").length).join(s3 || "0") + t3;
        }, pick: y, pInt: r, pushUnique: function(t3, e3) {
          return 0 > t3.indexOf(e3) && !!t3.push(e3);
        }, relativeLength: function(t3, e3, s3) {
          return /%$/.test(t3) ? e3 * parseFloat(t3) / 100 + (s3 || 0) : parseFloat(t3);
        }, removeEvent: x, replaceNested: function(t3, ...e3) {
          let s3, i2;
          do
            for (i2 of (s3 = t3, e3))
              t3 = t3.replace(i2[0], i2[1]);
          while (t3 !== s3);
          return t3;
        }, splat: f, stableSort: function(t3, e3) {
          let s3, i2;
          let o2 = t3.length;
          for (i2 = 0; i2 < o2; i2++)
            t3[i2].safeI = i2;
          for (t3.sort(function(t4, i3) {
            return 0 === (s3 = e3(t4, i3)) ? t4.safeI - i3.safeI : s3;
          }), i2 = 0; i2 < o2; i2++)
            delete t3[i2].safeI;
        }, syncTimeout: function(t3, e3, s3) {
          return e3 > 0 ? setTimeout(t3, e3, s3) : (t3.call(0, s3), -1);
        }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, uniqueKey: T, useSerialIds: function(t3) {
          return e2 = y(t3, e2);
        }, wrap: function(t3, e3, s3) {
          let i2 = t3[e3];
          t3[e3] = function() {
            let t4 = arguments, e4 = this;
            return s3.apply(this, [function() {
              return i2.apply(e4, arguments.length ? arguments : t4);
            }].concat([].slice.call(arguments)));
          };
        } };
      }), s(e, "Core/Renderer/HTML/AST.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { SVG_NS: s2, win: i } = t2, { attr: o, createElement: n, css: r, error: a, isFunction: l, isString: h, objectEach: d, splat: c } = e2, { trustedTypes: u } = i, p = u && l(u.createPolicy) && u.createPolicy("highcharts", { createHTML: (t3) => t3 }), m = p ? p.createHTML("") : "", f = function() {
          try {
            return !!new DOMParser().parseFromString(m, "text/html");
          } catch (t3) {
            return false;
          }
        }();
        class g {
          static filterUserAttributes(t3) {
            return d(t3, (e3, s3) => {
              let i2 = true;
              -1 === g.allowedAttributes.indexOf(s3) && (i2 = false), -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(s3) && (i2 = h(e3) && g.allowedReferences.some((t4) => 0 === e3.indexOf(t4))), i2 || (a(33, false, void 0, { "Invalid attribute in config": `${s3}` }), delete t3[s3]), h(e3) && t3[s3] && (t3[s3] = e3.replace(/</g, "&lt;"));
            }), t3;
          }
          static parseStyle(t3) {
            return t3.split(";").reduce((t4, e3) => {
              let s3 = e3.split(":").map((t5) => t5.trim()), i2 = s3.shift();
              return i2 && s3.length && (t4[i2.replace(/-([a-z])/g, (t5) => t5[1].toUpperCase())] = s3.join(":")), t4;
            }, {});
          }
          static setElementHTML(t3, e3) {
            t3.innerHTML = g.emptyHTML, e3 && new g(e3).addToDOM(t3);
          }
          constructor(t3) {
            this.nodes = "string" == typeof t3 ? this.parseMarkup(t3) : t3;
          }
          addToDOM(e3) {
            return function e4(i2, n2) {
              let l2;
              return c(i2).forEach(function(i3) {
                let h2;
                let c2 = i3.tagName, u2 = i3.textContent ? t2.doc.createTextNode(i3.textContent) : void 0, p2 = g.bypassHTMLFiltering;
                if (c2) {
                  if ("#text" === c2)
                    h2 = u2;
                  else if (-1 !== g.allowedTags.indexOf(c2) || p2) {
                    let a2 = "svg" === c2 ? s2 : n2.namespaceURI || s2, l3 = t2.doc.createElementNS(a2, c2), m2 = i3.attributes || {};
                    d(i3, function(t3, e5) {
                      "tagName" !== e5 && "attributes" !== e5 && "children" !== e5 && "style" !== e5 && "textContent" !== e5 && (m2[e5] = t3);
                    }), o(l3, p2 ? m2 : g.filterUserAttributes(m2)), i3.style && r(l3, i3.style), u2 && l3.appendChild(u2), e4(i3.children || [], l3), h2 = l3;
                  } else
                    a(33, false, void 0, { "Invalid tagName in config": c2 });
                }
                h2 && n2.appendChild(h2), l2 = h2;
              }), l2;
            }(this.nodes, e3);
          }
          parseMarkup(t3) {
            let e3;
            let s3 = [];
            if (t3 = t3.trim().replace(/ style=(["'])/g, " data-style=$1"), f)
              e3 = new DOMParser().parseFromString(p ? p.createHTML(t3) : t3, "text/html");
            else {
              let s4 = n("div");
              s4.innerHTML = t3, e3 = { body: s4 };
            }
            let i2 = (t4, e4) => {
              let s4 = t4.nodeName.toLowerCase(), o2 = { tagName: s4 };
              "#text" === s4 && (o2.textContent = t4.textContent || "");
              let n2 = t4.attributes;
              if (n2) {
                let t5 = {};
                [].forEach.call(n2, (e5) => {
                  "data-style" === e5.name ? o2.style = g.parseStyle(e5.value) : t5[e5.name] = e5.value;
                }), o2.attributes = t5;
              }
              if (t4.childNodes.length) {
                let e5 = [];
                [].forEach.call(t4.childNodes, (t5) => {
                  i2(t5, e5);
                }), e5.length && (o2.children = e5);
              }
              e4.push(o2);
            };
            return [].forEach.call(e3.body.childNodes, (t4) => i2(t4, s3)), s3;
          }
        }
        return g.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "markerHeight", "markerWidth", "offset", "opacity", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], g.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], g.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feDropShadow", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], g.emptyHTML = m, g.bypassHTMLFiltering = false, g;
      }), s(e, "Dashboards/CallbackRegistry.js", [], function() {
        return class {
          constructor() {
            this.registry = {};
          }
          addCallback(t2, e2) {
            this.registry[t2] = e2;
          }
          getCallback(t2) {
            return this.registry[t2];
          }
          toJSON() {
            let t2 = {};
            return Object.keys(this.registry).forEach((e2) => {
              let { func: s2, type: i } = this.getCallback(e2);
              t2[e2] = { func: s2.toString(), type: i };
            }), t2;
          }
        };
      }), s(e, "Dashboards/Serializable.js", [], function() {
        var t2;
        return function(t3) {
          let e2 = {}, s2 = {};
          t3.fromJSON = function(t4) {
            let i = t4.$class;
            if ("string" != typeof i)
              throw Error("JSON has no $class property.");
            let o = e2[i];
            if (o)
              return o.fromJSON(t4);
            let n = s2[i];
            if (n)
              return n.fromJSON(t4);
            throw Error(`'${i}' unknown.`);
          }, t3.registerClassPrototype = function(t4, s3) {
            if (e2[t4])
              throw Error("A serializer for '" + t4 + "' is already registered.");
            e2[t4] = s3;
          }, t3.registerHelper = function(t4) {
            if (s2[t4.$class])
              throw Error("A serializer for '" + t4.$class + "' is already registered.");
            s2[t4.$class] = t4;
          }, t3.toJSON = function(t4) {
            let e3;
            if ("function" == typeof t4.fromJSON && "function" == typeof t4.toJSON)
              return t4.toJSON();
            let i = Object.keys(s2), o = i.length;
            for (let n = 0; n < o; ++n)
              if ((e3 = s2[i[n]]).jsonSupportFor(t4))
                return e3.toJSON(t4);
            throw Error("Object is not supported.");
          };
        }(t2 || (t2 = {})), t2;
      }), s(e, "Dashboards/Components/SharedComponentState.js", [e["Dashboards/Serializable.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { addEvent: s2, fireEvent: i, merge: o } = e2;
        class n {
          constructor() {
            this.columnVisibilityMap = {}, this.hiddenRowIndexes = [], this.selection = {};
          }
          emit(t3) {
            i(this, t3.type, t3);
          }
          getColumnOrder() {
            return (this.columnOrder || []).slice();
          }
          getColumnVisibility(t3) {
            return this.columnVisibilityMap[t3];
          }
          getColumnSorter() {
            let t3 = (this.columnOrder || []).slice();
            return t3.length ? (e3, s3) => {
              let i2 = t3.indexOf(e3), o2 = t3.indexOf(s3);
              return i2 > -1 && o2 > -1 ? i2 - o2 : o2 > -1 ? 1 : i2 > -1 ? -1 : 0;
            } : () => 0;
          }
          isSet() {
            return true === this.isModified;
          }
          on(t3, e3) {
            return s2(this, t3, e3);
          }
          setColumnOrder(t3, e3) {
            let s3 = (this.columnOrder || []).slice(), i2 = t3.slice();
            this.emit({ type: "columnOrderChange", detail: e3, newColumnOrder: i2, oldColumnOrder: s3 }), this.columnOrder = i2, this.isModified = true, this.emit({ type: "afterColumnOrderChange", detail: e3, newColumnOrder: i2, oldColumnOrder: s3 });
          }
          setColumnVisibility(t3, e3) {
            this.columnVisibilityMap = o(this.columnVisibilityMap, t3), this.emit({ type: "afterColumnVisibilityChange", visibilityMap: this.columnVisibilityMap, detail: e3 });
          }
          setHiddenRows(t3, e3 = true) {
            t3.forEach((t4) => {
              -1 === this.hiddenRowIndexes.indexOf(t4) && e3 && this.hiddenRowIndexes.push(t4), this.hiddenRowIndexes.indexOf(t4) > -1 && !e3 && this.hiddenRowIndexes.splice(this.hiddenRowIndexes.indexOf(t4), 1);
            }), this.emit({ type: "afterSetHiddenRows", hiddenRows: this.hiddenRowIndexes });
          }
          getHiddenRows() {
            return this.hiddenRowIndexes;
          }
          setHoverPoint(t3, e3) {
            let s3 = e3 && e3.isDataGrid;
            this.hoverPoint = s3 ? void 0 : t3, t3 instanceof HTMLElement && (this.hoverRow = s3 ? t3 : void 0), this.emit({ type: "afterHoverPointChange", hoverPoint: s3 ? void 0 : this.hoverPoint, hoverRow: s3 ? this.hoverRow : void 0, detail: e3 });
          }
          getHoverPoint() {
            return this.hoverPoint;
          }
          getSelection() {
            return this.selection;
          }
          setSelection(t3, e3 = false, s3) {
            Object.keys(t3).forEach((e4) => {
              this.selection[e4] = t3[e4];
            }), this.emit({ type: "afterSelectionChange", selection: this.selection, reset: e3, detail: s3 });
          }
          fromJSON(t3) {
            let e3 = new n(), { columnOrder: s3, visibilityMap: i2, selection: o2, hoverpoint: r } = t3;
            return s3 && e3.setColumnOrder(s3), i2 && e3.setColumnVisibility(i2), o2 && e3.setSelection(o2), r && e3.setHoverPoint(r), e3;
          }
          toJSON() {
            let t3 = { $class: "Dashboards.SharedComponentState" };
            if (this.columnOrder && (t3.columnOrder = this.columnOrder.slice()), this.hoverPoint) {
              let { x: e3, y: s3, id: i2 } = this.hoverPoint;
              t3.hoverPoint = { x: e3, y: s3, id: i2 };
            }
            return this.selection && (t3.selection = this.selection), this.columnVisibilityMap && (t3.columnVisibility = this.columnVisibilityMap), t3;
          }
        }
        return t2.registerClassPrototype("Dashboards.SharedComponentState", n.prototype), n;
      }), s(e, "Dashboards/Components/ComponentGroup.js", [e["Dashboards/Components/SharedComponentState.js"]], function(t2) {
        class e2 {
          static getComponentGroup(t3) {
            if (this.componentGroups[t3])
              return this.componentGroups[t3];
          }
          static addComponentGroup(t3) {
            let { id: e3 } = t3;
            this.componentGroups[e3] || (this.componentGroups[e3] = t3);
          }
          static getGroupsFromComponent(t3) {
            return Object.keys(this.componentGroups).reduce((e3, s2) => {
              let i = this.getComponentGroup(s2);
              return i && i.components.indexOf(t3) > -1 && e3.push(i), e3;
            }, []);
          }
          constructor(s2) {
            this.state = new t2(), this.components = [], this.id = s2, e2.addComponentGroup(this);
          }
          addComponents(t3) {
            for (; t3.length; ) {
              let e3 = t3.pop();
              if (!e3)
                break;
              -1 === this.components.indexOf(e3) && this.components.push(e3);
            }
          }
          removeComponents(t3) {
            for (; t3.length; ) {
              let e3 = t3.pop();
              if (!e3)
                break;
              let s2 = this.components.indexOf(e3);
              s2 > -1 && this.components.splice(s2, 1);
            }
          }
          getSharedState() {
            return this.state;
          }
          on() {
            throw Error("Method not implemented.");
          }
          emit() {
            throw Error("Method not implemented.");
          }
        }
        return e2.componentGroups = {}, e2;
      }), s(e, "Dashboards/Components/EditableOptions.js", [], function() {
        class t2 {
          constructor(e2, s2 = t2.defaultBindings) {
            this.component = e2, this.bindings = s2;
          }
          getOptions() {
            let t3 = this.component.options.editableOptions;
            if (!t3)
              return [];
            for (let e2 = 0, s2 = t3.length; e2 < s2; e2++) {
              let s3 = t3[e2];
              if ("connectorName" === s3.name) {
                let t4 = this.component.board, e3 = t4 ? t4.dataPool.getConnectorIds().map((t5) => ({ name: t5 })) : [];
                s3.selectOptions = e3;
              }
            }
            return t3;
          }
        }
        return t2.defaultBindings = { keyMap: { color: "colorPicker", title: "text", caption: "text", style: "textarea" }, typeMap: { string: "text", number: "input", boolean: "toggle" }, skipRedraw: [] }, t2.defaultTypeMap = { string: "text", number: "input", boolean: "toggle" }, t2;
      }), s(e, "Dashboards/Components/Sync/Emitter.js", [], function() {
        class t2 {
          static register(t3) {
            let { id: e2 } = t3;
            this.registry[e2] = t3;
          }
          static get(t3) {
            return this.registry[t3];
          }
          constructor(e2, s2) {
            this.id = e2, this.func = s2, t2.register(this);
          }
          create(t3) {
            this.callback = this.func.call(t3);
          }
          remove() {
            this.callback && this.callback();
          }
        }
        return t2.registry = {}, t2;
      }), s(e, "Dashboards/Components/Sync/Handler.js", [], function() {
        class t2 {
          static register(t3) {
            let { id: e2 } = t3;
            this.registry[e2] = t3;
          }
          static get(t3) {
            return this.registry[t3];
          }
          constructor(e2, s2) {
            this.id = e2, this.func = s2, t2.register(this);
          }
          register(t3) {
            let { func: e2 } = this;
            this.callback = e2.call(t3);
          }
          remove() {
            this.callback && this.callback();
          }
        }
        return t2.registry = {}, t2;
      }), s(e, "Dashboards/Components/Sync/Sync.js", [e["Dashboards/Components/Sync/Emitter.js"], e["Dashboards/Components/Sync/Handler.js"]], function(t2, e2) {
        class s2 {
          constructor(t3, e3 = s2.defaultHandlers) {
            this.component = t3, this.syncConfig = e3, this.registeredSyncHandlers = {}, this.registeredSyncEmitters = {}, this.isSyncing = false, this.listeners = [];
          }
          registerSyncEmitter(t3) {
            let { id: e3 } = t3;
            this.registeredSyncEmitters[e3] = t3;
          }
          isRegisteredEmitter(t3) {
            return !!this.registeredSyncEmitters[t3];
          }
          registerSyncHandler(t3) {
            let { id: e3 } = t3;
            this.registeredSyncHandlers[e3] = t3;
          }
          isRegisteredHandler(t3) {
            return !!this.registeredSyncHandlers[t3];
          }
          start() {
            let { syncConfig: i, component: o } = this;
            for (let n of Object.keys(i)) {
              let r = i[n];
              if (!r)
                continue;
              let { emitter: a, handler: l } = r;
              if (l) {
                "boolean" == typeof l && (l = s2.defaultHandlers[n].handler);
                let t3 = new e2(n, l);
                this.isRegisteredHandler(t3.id) || (this.registerSyncHandler(t3), t3.register(o));
              }
              if (a) {
                "boolean" == typeof a && (a = s2.defaultHandlers[n].emitter);
                let e3 = new t2(n, a);
                this.isRegisteredEmitter(e3.id) || (this.registerSyncEmitter(e3), e3.create(o));
              }
            }
            this.isSyncing = true, this.listeners.push(o.on("update", () => this.stop()));
          }
          stop() {
            let { component: t3, listeners: e3, registeredSyncHandlers: s3, registeredSyncEmitters: i } = this;
            Object.keys(s3).forEach((t4) => {
              s3[t4].remove(), delete s3[t4];
            }), Object.keys(i).forEach((t4) => {
              i[t4].remove(), delete i[t4];
            }), this.isSyncing = false;
            for (let t4 = 0, s4 = e3.length; t4 < s4; ++t4)
              e3[t4]();
            this.listeners.length = 0, this.listeners.push(t3.on("afterUpdate", () => {
              this.start();
            }));
          }
        }
        return s2.defaultHandlers = {}, (s2 || (s2 = {})).defaultSyncOptions = { crossfilter: { affectNavigator: false }, highlight: { highlightPoint: true, showTooltip: true, showCrosshair: true } }, s2;
      }), s(e, "Dashboards/Globals.js", [], function() {
        var e2, s2;
        return (s2 = e2 || (e2 = {})).classNamePrefix = "highcharts-dashboards-", s2.classNames = { layout: s2.classNamePrefix + "layout", cell: s2.classNamePrefix + "cell", cellHover: s2.classNamePrefix + "cell-state-hover", cellActive: s2.classNamePrefix + "cell-state-active", cellLoading: s2.classNamePrefix + "cell-state-loading", row: s2.classNamePrefix + "row", layoutsWrapper: s2.classNamePrefix + "layouts-wrapper", boardContainer: s2.classNamePrefix + "wrapper" }, s2.guiElementType = { row: "row", cell: "cell", layout: "layout" }, s2.boards = [], s2.win = t, e2;
      }), s(e, "Dashboards/Components/ComponentUtilities.js", [], function() {
        var e2;
        return function(e3) {
          function s2(e4, s3) {
            let i2 = t.getComputedStyle(e4);
            return s3.map((t2) => i2[t2]);
          }
          function i(t2, e4) {
            return e4 && (t2 += "number" == typeof e4 ? e4 : parseFloat(e4)), t2;
          }
          e3.getMargins = function(t2, e4 = true) {
            let o = { x: ["borderLeft", "borderRight"], y: ["borderTop", "borderBottom"] };
            return { y: s2(t2, ["marginTop", "marginBottom", ...e4 ? o.y : []]).reduce(i, 0), x: s2(t2, ["marginLeft", "marginTop", ...e4 ? o.x : []]).reduce(i, 0) };
          }, e3.getPaddings = function(t2) {
            return { x: s2(t2, ["paddingLeft", "paddingRight"]).reduce(i, 0), y: s2(t2, ["paddingTop", "paddingBottom"]).reduce(i, 0) };
          }, e3.getStyles = s2, e3.sumPixels = i;
        }(e2 || (e2 = {})), e2;
      }), s(e, "Dashboards/Utilities.js", [e["Core/Utilities.js"]], function(t2) {
        let { error: e2, isClass: s2, isDOMElement: i, isObject: o, objectEach: n, uniqueKey: r } = t2;
        return { error: function(t3, s3) {
          if (16 === t3) {
            console.warn("Dashboard error: Dashboards library loaded more than once.This may cause undefined behavior.");
            return;
          }
          e2(t3, s3);
        }, merge: function() {
          let t3, e3 = arguments, r2 = 0, a = {}, l = Error("Recursive copy depth > 100"), h = (t4, e4) => {
            if ("object" != typeof t4 && (t4 = {}), ++r2 > 100)
              throw l;
            return n(e4, (n2, r3) => {
              "__proto__" !== r3 && "constructor" !== r3 && (!o(n2, true) || s2(n2) || i(n2) ? t4[r3] = e4[r3] : t4[r3] = h(t4[r3] || {}, n2));
            }), --r2, t4;
          };
          true === e3[0] && (a = e3[1], e3 = Array.prototype.slice.call(e3, 2));
          let d = e3.length;
          for (t3 = 0; t3 < d; t3++)
            a = h(a, e3[t3]);
          return a;
        }, uniqueKey: function() {
          return `dashboard-${r().replace("highcharts-", "")}`;
        } };
      }), s(e, "Dashboards/Components/Component.js", [e["Dashboards/CallbackRegistry.js"], e["Dashboards/Components/ComponentGroup.js"], e["Dashboards/Components/EditableOptions.js"], e["Dashboards/Components/Sync/Sync.js"], e["Dashboards/Globals.js"], e["Core/Utilities.js"], e["Dashboards/Components/ComponentUtilities.js"], e["Dashboards/Utilities.js"]], function(e2, s2, i, o, n, r, a, l) {
        let { classNamePrefix: h } = n, { createElement: d, isArray: c, merge: u, fireEvent: p, addEvent: m, objectEach: f, isFunction: g, isObject: y, getStyle: b, diffObjects: C } = r, { getMargins: w, getPaddings: O } = a, { uniqueKey: v } = l;
        class x {
          static createTextElement(t2, e3, s3) {
            if ("object" == typeof s3) {
              let { className: i2, text: o2, style: n2 } = s3;
              return d(t2, { className: i2 || `${h}component-${e3}`, textContent: o2 }, n2);
            }
            if ("string" == typeof s3)
              return d(t2, { className: `${h}component-${e3}`, textContent: s3 }, {});
          }
          constructor(t2, s3, o2) {
            var _a, _b;
            this.callbackRegistry = new e2(), this.tableEvents = [], this.cellListeners = [], this.resizeTimeouts = [], this.innerResizeTimeouts = [];
            let n2 = s3.renderTo || s3.cell;
            this.board = o2 || ((_b = (_a = t2 == null ? void 0 : t2.row) == null ? void 0 : _a.layout) == null ? void 0 : _b.board) || {}, this.parentElement = (t2 == null ? void 0 : t2.container) || document.querySelector("#" + n2), this.cell = t2, this.options = u(x.defaultOptions, s3), this.id = this.options.id && this.options.id.length ? this.options.id : v(), this.editableOptions = new i(this, s3.editableOptionsBindings), this.presentationModifier = this.options.presentationModifier, this.dimensions = { width: null, height: null }, this.element = d("div", { className: this.options.className }, {}, this.parentElement), Number(b(this.element, "padding")) || (this.element.style.padding = "0.1px"), this.contentElement = d("div", { className: `${this.options.className}-content` }, {}, this.element, true), this.filterAndAssignSyncOptions(), this.setupEventListeners(), t2 && (this.attachCellListeners(), this.on("tableChanged", () => {
              this.onTableChanged();
            }), this.on("update", () => {
              this.cell.setLoadingState();
            }), this.on("afterRender", () => {
              this.cell.setLoadingState(false);
            }));
          }
          getOptionsOnDrop(t2) {
            return {};
          }
          async initConnector() {
            var _a, _b;
            let t2 = (_a = this.options.connector) == null ? void 0 : _a.id, e3 = this.board.dataPool;
            if (t2 && (this.connectorId !== t2 || e3.isNewConnector(t2))) {
              (_b = this.cell) == null ? void 0 : _b.setLoadingState();
              let s3 = await e3.getConnector(t2);
              this.setConnector(s3);
            }
            return this;
          }
          filterAndAssignSyncOptions(t2 = this.constructor.syncHandlers) {
            let e3 = this.options.sync || {}, s3 = Object.keys(e3).reduce((s4, i2) => {
              if (i2) {
                let n2 = t2[i2], r2 = o.defaultSyncOptions[i2], a2 = e3[i2];
                if (s4[i2] = u(r2 || {}, { enabled: y(a2) ? a2.enabled : a2 }, y(a2) ? a2 : {}), n2 && s4[i2].enabled)
                  for (let t3 of ["emitter", "handler"])
                    (true === s4[i2][t3] || void 0 === s4[i2][t3]) && (s4[i2][t3] = n2[t3]);
              }
              return s4;
            }, {});
            this.sync && (this.sync.syncConfig = s3), this.syncHandlers = s3;
          }
          attachCellListeners() {
            for (; this.cellListeners.length; ) {
              let t2 = this.cellListeners.pop();
              t2 && t2();
            }
            if (this.cell && Object.keys(this.cell).length) {
              let t2 = this.cell.row.layout.board;
              this.cellListeners.push(m(t2, "cellResize", () => {
                this.resizeTo(this.parentElement);
              }), m(this.cell.row, "cellChange", (t3) => {
                let { row: e3 } = t3;
                e3 && this.cell && void 0 === e3.getCellIndex(this.cell) && this.cell && this.setCell(this.cell);
              }));
            }
          }
          setCell(t2, e3 = false) {
            this.cell = t2, t2.container && (this.parentElement = t2.container), this.attachCellListeners(), e3 && this.resizeTo(this.parentElement);
          }
          setupTableListeners(t2) {
            let e3 = this.connector;
            e3 && (t2 && ["afterDeleteColumns", "afterDeleteRows", "afterSetCell", "afterSetConnector", "afterSetColumns", "afterSetRows"].forEach((e4) => {
              this.tableEvents.push(t2.on(e4, (t3) => {
                clearTimeout(this.tableEventTimeout), this.tableEventTimeout = n.win.setTimeout(() => {
                  this.emit({ ...t3, type: "tableChanged" }), this.tableEventTimeout = void 0;
                });
              }));
            }), this.tableEvents.push(e3.on("afterLoad", () => {
              clearTimeout(this.tableEventTimeout), this.tableEventTimeout = n.win.setTimeout(() => {
                this.emit({ target: this, type: "tableChanged" }), this.tableEventTimeout = void 0;
              });
            })));
          }
          clearTableListeners() {
            let t2 = this.connector, e3 = this.tableEvents;
            e3.length && e3.forEach((t3) => t3()), t2 && e3.push(t2.table.on("afterSetModifier", (t3) => {
              "afterSetModifier" === t3.type && (clearTimeout(this.tableEventTimeout), this.tableEventTimeout = n.win.setTimeout(() => {
                this.emit({ ...t3, type: "tableChanged" }), this.tableEventTimeout = void 0;
              }));
            }));
          }
          setConnector(t2) {
            for (p(this, "setConnector", { connector: t2 }); this.tableEvents.length; ) {
              let t3 = this.tableEvents.pop();
              "function" == typeof t3 && t3();
            }
            if (this.connector = t2, t2) {
              this.clearTableListeners(), this.setupTableListeners(t2.table), t2.table.on("setModifier", () => this.clearTableListeners()), t2.table.on("afterSetModifier", (t3) => {
                "afterSetModifier" === t3.type && t3.modified && this.setupTableListeners(t3.modified);
              });
              let e3 = t2.table.id;
              s2.getComponentGroup(e3) || s2.addComponentGroup(new s2(e3));
              let i2 = s2.getComponentGroup(e3);
              i2 && (i2.addComponents([this.id]), this.activeGroup = i2);
            }
            return p(this, "afterSetConnector", { connector: t2 }), this;
          }
          setActiveGroup(t2) {
            "string" == typeof t2 && (t2 = s2.getComponentGroup(t2) || null), t2 instanceof s2 && (this.activeGroup = t2), null === t2 && (this.activeGroup = void 0), this.activeGroup && this.activeGroup.addComponents([this.id]);
          }
          getContentHeight() {
            return (this.titleElement ? this.titleElement.clientHeight + w(this.titleElement).y : 0) + (this.captionElement ? this.captionElement.clientHeight + w(this.captionElement).y : 0);
          }
          resize(t2, e3) {
            if (e3) {
              let t3 = O(this.element).y + w(this.element).y;
              this.element.style.height = "calc(100% - " + t3 + "px)", this.contentElement.style.height = "calc(100% - " + this.getContentHeight() + "px)";
            } else
              null === e3 && (this.dimensions.height = null, this.element.style.removeProperty("height"));
            p(this, "resize", { width: t2, height: e3 });
          }
          resizeTo(t2) {
            for (; this.resizeTimeouts.length; ) {
              let t3 = this.resizeTimeouts.pop();
              t3 && cancelAnimationFrame(t3);
            }
            let e3 = requestAnimationFrame(() => {
              let { width: e4, height: s3 } = t2.getBoundingClientRect(), i2 = O(t2), o2 = w(t2);
              this.resize(e4 - i2.x - o2.x, s3 - i2.y - o2.y);
            });
            this.resizeTimeouts.push(e3);
          }
          async update(t2, e3 = true) {
            var _a;
            let s3 = { options: t2, shouldForceRerender: false };
            if (p(this, "update", s3), this.options = u(this.options, t2), ((_a = this.options.connector) == null ? void 0 : _a.id) && this.connectorId !== this.options.connector.id) {
              let t3 = await this.board.dataPool.getConnector(this.options.connector.id);
              this.setConnector(t3);
            }
            this.options = u(this.options, t2), (e3 || s3.shouldForceRerender) && this.render();
          }
          setupEventListeners() {
            let e3 = this.options.events;
            e3 && (Object.keys(e3).forEach((t2) => {
              let s4 = e3[t2];
              s4 && this.callbackRegistry.addCallback(t2, { type: "component", func: s4 });
            }), f(e3, (t2, e4) => {
              g(t2) && this.on(e4, t2);
            }));
            let s3 = () => {
              this.resizeTo(this.parentElement);
            };
            if ("function" == typeof ResizeObserver)
              this.resizeObserver = new ResizeObserver(s3), this.resizeObserver.observe(this.element);
            else {
              let e4 = m(t, "resize", s3);
              m(this, "destroy", e4);
            }
          }
          setTitle(t2) {
            let e3 = this.titleElement;
            if (t2 && ("string" == typeof t2 || t2.text)) {
              let s3 = x.createTextElement("h2", "title", t2);
              s3 && (e3 ? e3.replaceWith(s3) : this.element.insertBefore(s3, this.element.firstChild), this.titleElement = s3);
            } else if (e3) {
              e3.remove(), delete this.titleElement;
              return;
            }
          }
          setCaption(t2) {
            let e3 = this.captionElement;
            if (t2 && ("string" == typeof t2 || t2.text)) {
              let s3 = x.createTextElement("div", "caption", t2);
              s3 && (e3 ? e3.replaceWith(s3) : this.element.appendChild(s3), this.captionElement = s3);
            } else if (e3) {
              e3.remove(), delete this.captionElement;
              return;
            }
          }
          async load() {
            return await this.initConnector(), this.render(), this;
          }
          render() {
            return this.emit({ type: "render" }), this.setTitle(this.options.title), this.setCaption(this.options.caption), this.resizeTo(this.parentElement), this;
          }
          destroy() {
            for (this.sync.stop(); this.element.firstChild; )
              this.element.firstChild.remove();
            p(this, "unmount"), this.tableEvents.forEach((t2) => t2()), this.element.remove();
          }
          on(t2, e3) {
            return m(this, t2, e3);
          }
          emit(t2) {
            t2.target || (t2.target = this), p(this, t2.type, t2);
          }
          toJSON() {
            let t2 = { width: 0, height: 0 };
            return f(this.dimensions, function(e3, s3) {
              null !== e3 && (t2[s3] = e3);
            }), { $class: this.options.type, options: { renderTo: this.options.renderTo, parentElement: this.parentElement.id, dimensions: t2, id: this.id, type: this.type } };
          }
          getOptions() {
            return C(this.options, x.defaultOptions);
          }
          getEditableOptions() {
            return u(this.options);
          }
          getEditableOptionValue(t2) {
            if (!t2)
              return;
            let e3 = this.getEditableOptions();
            for (let s3 = 0, i2 = t2.length; s3 < i2; s3++) {
              if (c(e3) && (e3 = e3[0]), !e3)
                return;
              e3 = e3[t2[s3]];
            }
            return e3;
          }
        }
        return x.Sync = o, x.defaultOptions = { className: `${h}component`, id: "", title: false, caption: false, sync: o.defaultHandlers, editableOptions: [{ name: "connectorName", propertyPath: ["connector", "id"], type: "select" }, { name: "title", propertyPath: ["title"], type: "input" }, { name: "caption", propertyPath: ["caption"], type: "input" }] }, x.syncHandlers = {}, x;
      }), s(e, "Dashboards/Components/HTMLComponent/HTMLComponentDefaults.js", [], function() {
        return { type: "HTML", elements: [] };
      }), s(e, "Dashboards/Components/HTMLComponent/HTMLComponent.js", [e["Core/Renderer/HTML/AST.js"], e["Dashboards/Components/Component.js"], e["Dashboards/Components/HTMLComponent/HTMLComponentDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i) {
        let { merge: o, diffObjects: n } = i;
        t2.allowedTags = [...t2.allowedTags, "option", "select", "label", "input", "textarea"], t2.allowedAttributes = [...t2.allowedAttributes, "for", "value", "checked", "src", "name", "selected"], t2.allowedReferences = [...t2.allowedReferences, "data:image/"];
        class r extends e2 {
          static fromJSON(t3, e3) {
            let s3 = new r(e3, o(t3.options, { elements: t3.elements ? t3.elements.map((t4) => JSON.parse(t4)) : [] }));
            return s3.emit({ type: "fromJSON", json: t3 }), s3;
          }
          constructor(t3, s3) {
            super(t3, s3 = o(r.defaultOptions, s3)), this.options = s3, this.type = "HTML", this.elements = [], this.sync = new e2.Sync(this, this.syncHandlers);
          }
          async load() {
            var _a;
            this.emit({ type: "load" }), await super.load();
            let e3 = this.options, s3 = false;
            if (((_a = e3.elements) == null ? void 0 : _a.length) ? this.elements = e3.elements.map(function(e4) {
              return "string" == typeof e4 ? new t2(e4).nodes[0] : (e4.textContent || e4.tagName || !e4.attributes || (s3 = true), e4);
            }) : e3.html && (this.elements = this.getElementsFromString(e3.html)), this.constructTree(), this.emit({ type: "afterLoad" }), s3)
              throw Error("Missing tagName param in component: " + e3.cell);
            return this;
          }
          render() {
            return super.render(), this.constructTree(), this.sync.start(), this.emit({ type: "afterRender" }), this;
          }
          resize(t3, e3) {
            return super.resize(t3, e3), this;
          }
          async update(t3) {
            await super.update(t3), this.emit({ type: "afterUpdate" });
          }
          getOptionsOnDrop() {
            return { cell: "", type: "HTML", elements: [{ tagName: "img", attributes: { src: "https://www.highcharts.com/samples/graphics/stock-dark.svg" } }] };
          }
          constructTree() {
            for (; this.contentElement.firstChild; )
              this.contentElement.firstChild.remove();
            new t2(this.elements).addToDOM(this.contentElement);
          }
          getElementsFromString(e3) {
            return new t2(e3).nodes;
          }
          toJSON() {
            let t3 = (this.options.elements || []).map((t4) => JSON.stringify(t4)), e3 = o(super.toJSON(), { elements: t3, options: this.options });
            return this.emit({ type: "toJSON", json: e3 }), e3;
          }
          getOptions() {
            return { ...n(this.options, r.defaultOptions), type: "HTML" };
          }
          onTableChanged(t3) {
            var _a;
            ((_a = t3.detail) == null ? void 0 : _a.sender) !== this.id && this.render();
          }
        }
        return r.defaultOptions = o(e2.defaultOptions, s2), r;
      }), s(e, "Data/DataTable.js", [e["Core/Utilities.js"]], function(t2) {
        let { addEvent: e2, fireEvent: s2, uniqueKey: i } = t2;
        class o {
          static isNull(t3) {
            if (t3 === o.NULL)
              return true;
            if (t3 instanceof Array) {
              if (!t3.length)
                return false;
              for (let e3 = 0, s3 = t3.length; e3 < s3; ++e3)
                if (null !== t3[e3])
                  return false;
            } else {
              let e3 = Object.keys(t3);
              if (!e3.length)
                return false;
              for (let s3 = 0, i2 = e3.length; s3 < i2; ++s3)
                if (null !== t3[e3[s3]])
                  return false;
            }
            return true;
          }
          constructor(t3 = {}) {
            this.aliases = t3.aliases ? JSON.parse(JSON.stringify(t3.aliases)) : {}, this.autoId = !t3.id, this.columns = {}, this.id = t3.id || i(), this.modified = this, this.rowCount = 0, this.versionTag = i();
            let e3 = t3.columns || {}, s3 = Object.keys(e3), o2 = this.columns, n = 0;
            for (let t4 = 0, i2 = s3.length, r2, a2; t4 < i2; ++t4)
              r2 = e3[a2 = s3[t4]].slice(), o2[a2] = r2, n = Math.max(n, r2.length);
            for (let t4 = 0, e4 = s3.length; t4 < e4; ++t4)
              o2[s3[t4]].length = n;
            this.rowCount = n;
            let r = t3.aliases || {}, a = Object.keys(r), l = this.aliases;
            for (let t4 = 0, e4 = a.length, s4; t4 < e4; ++t4)
              l[s4 = a[t4]] = r[s4];
          }
          clone(t3, e3) {
            let s3 = {};
            this.emit({ type: "cloneTable", detail: e3 }), t3 || (s3.aliases = this.aliases, s3.columns = this.columns), this.autoId || (s3.id = this.id);
            let i2 = new o(s3);
            return t3 || (i2.versionTag = this.versionTag), this.emit({ type: "afterCloneTable", detail: e3, tableClone: i2 }), i2;
          }
          deleteColumnAlias(t3) {
            let e3 = this.aliases[t3], s3 = this.modifier;
            return e3 && (delete this.aliases[t3], s3 && s3.modifyColumns(this, { [e3]: Array(this.rowCount) }, 0)), e3;
          }
          deleteColumns(t3, e3) {
            let s3 = this.columns, i2 = {}, o2 = {}, n = this.modifier, r = this.rowCount;
            if ((t3 = t3 || Object.keys(s3)).length) {
              this.emit({ type: "deleteColumns", columnNames: t3, detail: e3 });
              for (let e4 = 0, n2 = t3.length, a, l; e4 < n2; ++e4)
                (a = s3[l = t3[e4]]) && (i2[l] = a, o2[l] = Array(r)), delete s3[l];
              return Object.keys(s3).length || (this.rowCount = 0), n && n.modifyColumns(this, o2, 0, e3), this.emit({ type: "afterDeleteColumns", columns: i2, columnNames: t3, detail: e3 }), i2;
            }
          }
          deleteRows(t3, e3 = 1, s3) {
            let i2 = [], o2 = [], n = this.modifier;
            if (this.emit({ type: "deleteRows", detail: s3, rowCount: e3, rowIndex: t3 || 0 }), void 0 === t3 && (t3 = 0, e3 = this.rowCount), e3 > 0 && t3 < this.rowCount) {
              let s4 = this.columns, n2 = Object.keys(s4);
              for (let r = 0, a = n2.length, l, h; r < a; ++r) {
                h = (l = s4[n2[r]]).splice(t3, e3), r || (this.rowCount = l.length);
                for (let t4 = 0, e4 = h.length; t4 < e4; ++t4)
                  i2[t4] = i2[t4] || [], i2[t4][r] = h[t4];
                o2.push(Array(a));
              }
            }
            return n && n.modifyRows(this, o2, t3 || 0, s3), this.emit({ type: "afterDeleteRows", detail: s3, rowCount: e3, rowIndex: t3 || 0, rows: i2 }), i2;
          }
          emit(t3) {
            switch (t3.type) {
              case "afterDeleteColumns":
              case "afterDeleteRows":
              case "afterSetCell":
              case "afterSetColumns":
              case "afterSetRows":
                this.versionTag = i();
            }
            s2(this, t3.type, t3);
          }
          getCell(t3, e3) {
            t3 = this.aliases[t3] || t3;
            let s3 = this.columns[t3];
            if (s3)
              return s3[e3];
          }
          getCellAsBoolean(t3, e3) {
            t3 = this.aliases[t3] || t3;
            let s3 = this.columns[t3];
            return !!(s3 && s3[e3]);
          }
          getCellAsNumber(t3, e3, s3) {
            t3 = this.aliases[t3] || t3;
            let i2 = this.columns[t3], o2 = i2 && i2[e3];
            switch (typeof o2) {
              case "boolean":
                return o2 ? 1 : 0;
              case "number":
                return isNaN(o2) && !s3 ? null : o2;
            }
            return isNaN(o2 = parseFloat(`${o2}`)) && !s3 ? null : o2;
          }
          getCellAsString(t3, e3) {
            t3 = this.aliases[t3] || t3;
            let s3 = this.columns[t3];
            return `${s3 && s3[e3]}`;
          }
          getColumn(t3, e3) {
            return this.getColumns([t3], e3)[t3];
          }
          getColumnAsNumbers(t3, e3) {
            let s3 = this.columns[t3 = this.aliases[t3] || t3], i2 = [];
            if (s3) {
              let o2 = s3.length;
              if (e3)
                for (let e4 = 0; e4 < o2; ++e4)
                  i2.push(this.getCellAsNumber(t3, e4, true));
              else {
                for (let t4 = 0, e4; t4 < o2; ++t4) {
                  if ("number" == typeof (e4 = s3[t4]))
                    return s3.slice();
                  if (null != e4)
                    break;
                }
                for (let e4 = 0; e4 < o2; ++e4)
                  i2.push(this.getCellAsNumber(t3, e4));
              }
            }
            return i2;
          }
          getColumnNames() {
            return Object.keys(this.columns);
          }
          getColumns(t3, e3) {
            let s3 = this.aliases, i2 = this.columns, o2 = {};
            t3 = t3 || Object.keys(i2);
            for (let n = 0, r = t3.length, a, l; n < r; ++n)
              (a = i2[s3[l = t3[n]] || l]) && (o2[l] = e3 ? a : a.slice());
            return o2;
          }
          getModifier() {
            return this.modifier;
          }
          getRow(t3, e3) {
            return this.getRows(t3, 1, e3)[0];
          }
          getRowCount() {
            return this.rowCount;
          }
          getRowIndexBy(t3, e3, s3) {
            t3 = this.aliases[t3] || t3;
            let i2 = this.columns[t3];
            if (i2) {
              let t4 = i2.indexOf(e3, s3);
              if (-1 !== t4)
                return t4;
            }
          }
          getRowObject(t3, e3) {
            return this.getRowObjects(t3, 1, e3)[0];
          }
          getRowObjects(t3 = 0, e3 = this.rowCount - t3, s3) {
            let i2 = this.aliases, o2 = this.columns, n = Array(e3);
            s3 = s3 || Object.keys(o2);
            for (let r = t3, a = 0, l = Math.min(this.rowCount, t3 + e3), h, d; r < l; ++r, ++a)
              for (let t4 of (d = n[a] = {}, s3))
                h = o2[i2[t4] || t4], d[t4] = h ? h[r] : void 0;
            return n;
          }
          getRows(t3 = 0, e3 = this.rowCount - t3, s3) {
            let i2 = this.aliases, o2 = this.columns, n = Array(e3);
            s3 = s3 || Object.keys(o2);
            for (let r = t3, a = 0, l = Math.min(this.rowCount, t3 + e3), h, d; r < l; ++r, ++a)
              for (let t4 of (d = n[a] = [], s3))
                h = o2[i2[t4] || t4], d.push(h ? h[r] : void 0);
            return n;
          }
          getVersionTag() {
            return this.versionTag;
          }
          hasColumns(t3) {
            let e3 = this.aliases, s3 = this.columns;
            for (let i2 = 0, o2 = t3.length, n; i2 < o2; ++i2)
              if (!s3[n = t3[i2]] && !e3[n])
                return false;
            return true;
          }
          hasRowWith(t3, e3) {
            t3 = this.aliases[t3] || t3;
            let s3 = this.columns[t3];
            return !!s3 && -1 !== s3.indexOf(e3);
          }
          on(t3, s3) {
            return e2(this, t3, s3);
          }
          renameColumn(t3, e3) {
            let s3 = this.columns;
            if (s3[t3]) {
              if (t3 !== e3) {
                let i2 = this.aliases;
                i2[e3] && delete i2[e3], s3[e3] = s3[t3], delete s3[t3];
              }
              return true;
            }
            return false;
          }
          setCell(t3, e3, s3, i2) {
            let o2 = this.columns, n = this.modifier, r = o2[t3 = this.aliases[t3] || t3];
            r && r[e3] === s3 || (this.emit({ type: "setCell", cellValue: s3, columnName: t3, detail: i2, rowIndex: e3 }), r || (r = o2[t3] = Array(this.rowCount)), e3 >= this.rowCount && (this.rowCount = e3 + 1), r[e3] = s3, n && n.modifyCell(this, t3, e3, s3), this.emit({ type: "afterSetCell", cellValue: s3, columnName: t3, detail: i2, rowIndex: e3 }));
          }
          setColumn(t3, e3 = [], s3 = 0, i2) {
            this.setColumns({ [t3]: e3 }, s3, i2);
          }
          setColumns(t3, e3, s3) {
            let i2 = this.columns, o2 = this.modifier, n = void 0 === e3, r = Object.keys(t3);
            this.emit({ type: "setColumns", columns: t3, columnNames: r, detail: s3, rowIndex: e3 });
            for (let s4 = 0, o3 = r.length, a2, l; s4 < o3; ++s4)
              if (a2 = t3[l = r[s4]], l = this.aliases[l] || l, n)
                i2[l] = a2.slice(), this.rowCount = a2.length;
              else {
                let t4 = i2[l] ? i2[l] : i2[l] = Array(this.rowCount);
                for (let s5 = e3 || 0, i3 = a2.length; s5 < i3; ++s5)
                  t4[s5] = a2[s5];
                this.rowCount = Math.max(this.rowCount, t4.length);
              }
            let a = Object.keys(i2);
            for (let t4 = 0, e4 = a.length; t4 < e4; ++t4)
              i2[a[t4]].length = this.rowCount;
            o2 && o2.modifyColumns(this, t3, e3 || 0), this.emit({ type: "afterSetColumns", columns: t3, columnNames: r, detail: s3, rowIndex: e3 });
          }
          setModifier(t3, e3) {
            let s3 = this;
            return s3.emit({ type: "setModifier", detail: e3, modifier: t3, modified: s3.modified }), s3.modified = s3, s3.modifier = t3, (t3 ? t3.modify(s3) : Promise.resolve(s3)).then((s4) => (s4.emit({ type: "afterSetModifier", detail: e3, modifier: t3, modified: s4.modified }), s4)).catch((e4) => {
              throw s3.emit({ type: "setModifierError", error: e4, modifier: t3, modified: s3.modified }), e4;
            });
          }
          setRow(t3, e3, s3) {
            this.setRows([t3], e3, s3);
          }
          setRows(t3, e3 = this.rowCount, s3) {
            let i2 = this.aliases, n = this.columns, r = Object.keys(n), a = this.modifier, l = t3.length;
            this.emit({ type: "setRows", detail: s3, rowCount: l, rowIndex: e3, rows: t3 });
            for (let s4 = 0, a2 = e3, h2; s4 < l; ++s4, ++a2)
              if ((h2 = t3[s4]) === o.NULL)
                for (let t4 = 0, e4 = r.length; t4 < e4; ++t4)
                  n[r[t4]][a2] = null;
              else if (h2 instanceof Array)
                for (let t4 = 0, e4 = r.length; t4 < e4; ++t4)
                  n[r[t4]][a2] = h2[t4];
              else {
                let t4 = Object.keys(h2);
                for (let e4 = 0, s5 = t4.length, o2; e4 < s5; ++e4)
                  n[o2 = i2[o2 = t4[e4]] || o2] || (n[o2] = Array(a2 + 1)), n[o2][a2] = h2[o2];
              }
            let h = e3 + l;
            if (h > this.rowCount) {
              this.rowCount = h;
              for (let t4 = 0, e4 = r.length; t4 < e4; ++t4)
                n[r[t4]].length = h;
            }
            a && a.modifyRows(this, t3, e3), this.emit({ type: "afterSetRows", detail: s3, rowCount: l, rowIndex: e3, rows: t3 });
          }
        }
        return o.NULL = {}, o.version = "1.0.0", o;
      }), s(e, "Data/Converters/DataConverter.js", [e["Data/DataTable.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { addEvent: s2, fireEvent: i, isNumber: o, merge: n } = e2;
        class r {
          constructor(t3) {
            this.dateFormats = { "YYYY/mm/dd": { regex: /^([0-9]{4})([\-\.\/])([0-9]{1,2})\2([0-9]{1,2})$/, parser: function(t4) {
              return t4 ? Date.UTC(+t4[1], t4[3] - 1, +t4[4]) : NaN;
            } }, "dd/mm/YYYY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{4})$/, parser: function(t4) {
              return t4 ? Date.UTC(+t4[4], t4[3] - 1, +t4[1]) : NaN;
            }, alternative: "mm/dd/YYYY" }, "mm/dd/YYYY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{4})$/, parser: function(t4) {
              return t4 ? Date.UTC(+t4[4], t4[1] - 1, +t4[3]) : NaN;
            } }, "dd/mm/YY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{2})$/, parser: function(t4) {
              let e4 = /* @__PURE__ */ new Date();
              if (!t4)
                return NaN;
              let s4 = +t4[4];
              return s4 > e4.getFullYear() - 2e3 ? s4 += 1900 : s4 += 2e3, Date.UTC(s4, t4[3] - 1, +t4[1]);
            }, alternative: "mm/dd/YY" }, "mm/dd/YY": { regex: /^([0-9]{1,2})([\-\.\/])([0-9]{1,2})\2([0-9]{2})$/, parser: function(t4) {
              return t4 ? Date.UTC(+t4[4] + 2e3, t4[1] - 1, +t4[3]) : NaN;
            } } };
            let e3 = n(r.defaultOptions, t3), s3 = e3.decimalPoint;
            ("." === s3 || "," === s3) && (s3 = "." === s3 ? "\\." : ",", this.decimalRegExp = RegExp("^(-?[0-9]+)" + s3 + "([0-9]+)$")), this.options = e3;
          }
          asBoolean(t3) {
            return "boolean" == typeof t3 ? t3 : "string" == typeof t3 ? "" !== t3 && "0" !== t3 && "false" !== t3 : !!this.asNumber(t3);
          }
          asDate(t3) {
            let e3;
            if ("string" == typeof t3)
              e3 = this.parseDate(t3);
            else if ("number" == typeof t3)
              e3 = t3;
            else {
              if (t3 instanceof Date)
                return t3;
              e3 = this.parseDate(this.asString(t3));
            }
            return new Date(e3);
          }
          asGuessedType(t3) {
            return { number: this.asNumber, Date: this.asDate, string: this.asString }[this.guessType(t3)].call(this, t3);
          }
          asNumber(t3) {
            if ("number" == typeof t3)
              return t3;
            if ("boolean" == typeof t3)
              return t3 ? 1 : 0;
            if ("string" == typeof t3) {
              let e3 = this.decimalRegExp;
              if (t3.indexOf(" ") > -1 && (t3 = t3.replace(/\s+/g, "")), e3) {
                if (!e3.test(t3))
                  return NaN;
                t3 = t3.replace(e3, "$1.$2");
              }
              return parseFloat(t3);
            }
            return t3 instanceof Date ? t3.getDate() : t3 ? t3.getRowCount() : NaN;
          }
          asString(t3) {
            return "" + t3;
          }
          deduceDateFormat(t3, e3, s3) {
            let i2 = [], o2 = [], n2 = "YYYY/mm/dd", r2, a = [], l = 0, h = false, d, c;
            for ((!e3 || e3 > t3.length) && (e3 = t3.length); l < e3; l++)
              if (void 0 !== t3[l] && t3[l] && t3[l].length)
                for (c = 0, r2 = t3[l].trim().replace(/[-\.\/]/g, " ").split(" "), a = ["", "", ""]; c < r2.length; c++)
                  c < a.length && (d = parseInt(r2[c], 10)) && (o2[c] = !o2[c] || o2[c] < d ? d : o2[c], void 0 !== i2[c] ? i2[c] !== d && (i2[c] = false) : i2[c] = d, d > 31 ? d < 100 ? a[c] = "YY" : a[c] = "YYYY" : d > 12 && d <= 31 ? (a[c] = "dd", h = true) : a[c].length || (a[c] = "mm"));
            if (h) {
              for (c = 0; c < i2.length; c++)
                false !== i2[c] ? o2[c] > 12 && "YY" !== a[c] && "YYYY" !== a[c] && (a[c] = "YY") : o2[c] > 12 && "mm" === a[c] && (a[c] = "dd");
              3 === a.length && "dd" === a[1] && "dd" === a[2] && (a[2] = "YY"), n2 = a.join("/");
            }
            return s3 && (this.options.dateFormat = n2), n2;
          }
          emit(t3) {
            i(this, t3.type, t3);
          }
          export(t3, e3) {
            throw this.emit({ type: "exportError", columns: [], headers: [] }), Error("Not implemented");
          }
          getTable() {
            throw Error("Not implemented");
          }
          guessType(t3) {
            let e3 = "string";
            if ("string" == typeof t3) {
              let s3 = this.trim(`${t3}`), i2 = this.decimalRegExp, n2 = this.trim(s3, true);
              i2 && (n2 = i2.test(n2) ? n2.replace(i2, "$1.$2") : "");
              let r2 = parseFloat(n2);
              +n2 === r2 ? t3 = r2 : e3 = o(this.parseDate(t3)) ? "Date" : "string";
            }
            return "number" == typeof t3 && (e3 = t3 > 31536e6 ? "Date" : "number"), e3;
          }
          on(t3, e3) {
            return s2(this, t3, e3);
          }
          parse(t3) {
            throw this.emit({ type: "parseError", columns: [], headers: [] }), Error("Not implemented");
          }
          parseDate(t3, e3) {
            let s3 = this.options, i2 = e3 || s3.dateFormat, n2 = NaN, r2, a, l;
            if (s3.parseDate)
              n2 = s3.parseDate(t3);
            else {
              if (i2)
                (a = this.dateFormats[i2]) || (a = this.dateFormats["YYYY/mm/dd"]), (l = t3.match(a.regex)) && (n2 = a.parser(l));
              else
                for (r2 in this.dateFormats)
                  if (a = this.dateFormats[r2], l = t3.match(a.regex)) {
                    i2 = r2, n2 = a.parser(l);
                    break;
                  }
              !l && ("object" == typeof (l = Date.parse(t3)) && null !== l && l.getTime ? n2 = l.getTime() - 6e4 * l.getTimezoneOffset() : o(l) && (n2 = l - 6e4 * new Date(l).getTimezoneOffset(), -1 === t3.indexOf("2001") && 2001 === new Date(n2).getFullYear() && (n2 = NaN)));
            }
            return n2;
          }
          trim(t3, e3) {
            return "string" == typeof t3 && (t3 = t3.replace(/^\s+|\s+$/g, ""), e3 && /^[0-9\s]+$/.test(t3) && (t3 = t3.replace(/\s/g, ""))), t3;
          }
        }
        return r.defaultOptions = { dateFormat: "", alternativeFormat: "", startColumn: 0, endColumn: Number.MAX_VALUE, startRow: 0, endRow: Number.MAX_VALUE, firstRowAsNames: true, switchRowsAndColumns: false }, (r || (r = {})).getTableFromColumns = function(e3 = [], s3 = []) {
          let i2 = new t2();
          for (let t3 = 0, o2 = Math.max(s3.length, e3.length); t3 < o2; ++t3)
            i2.setColumn(s3[t3] || `${t3}`, e3[t3]);
          return i2;
        }, r;
      }), s(e, "Data/Converters/CSVConverter.js", [e["Data/Converters/DataConverter.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { merge: s2 } = e2;
        class i extends t2 {
          constructor(t3) {
            let e3 = s2(i.defaultOptions, t3);
            super(e3), this.columns = [], this.headers = [], this.dataTypes = [], this.options = e3;
          }
          export(t3, e3 = this.options) {
            let { useLocalDecimalPoint: s3, lineDelimiter: i2 } = e3, o = false !== this.options.firstRowAsNames, { decimalPoint: n, itemDelimiter: r } = e3;
            n || (n = "," !== r && s3 ? 1.1.toLocaleString()[1] : "."), r || (r = "," === n ? ";" : ",");
            let a = t3.getSortedColumns(e3.usePresentationOrder), l = Object.keys(a), h = [], d = l.length, c = [];
            o && h.push(l.map((t4) => `"${t4}"`).join(r));
            for (let e4 = 0; e4 < d; e4++) {
              let s4;
              let i3 = l[e4], o2 = a[i3], u = o2.length, p = t3.whatIs(i3);
              p && (s4 = p.dataType);
              for (let t4 = 0; t4 < u; t4++) {
                let i4 = o2[t4];
                if (c[t4] || (c[t4] = []), "string" === s4 ? i4 = '"' + i4 + '"' : "number" == typeof i4 ? i4 = String(i4).replace(".", n) : "string" == typeof i4 && (i4 = `"${i4}"`), c[t4][e4] = i4, e4 === d - 1) {
                  let s5 = e4;
                  for (; c[t4].length > 2 && void 0 === c[t4][s5]; )
                    c[t4].pop(), s5--;
                  h.push(c[t4].join(r));
                }
              }
            }
            return h.join(i2);
          }
          parse(t3, e3) {
            let i2 = this.dataTypes, o = s2(this.options, t3), { beforeParse: n, lineDelimiter: r, firstRowAsNames: a, itemDelimiter: l } = o, h, d = 0, { csv: c, startRow: u, endRow: p } = o, m;
            if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: e3, headers: this.headers }), c && n && (c = n(c)), c) {
              if (h = c.replace(/\r\n|\r/g, "\n").split(r || "\n"), (!u || u < 0) && (u = 0), (!p || p >= h.length) && (p = h.length - 1), l || (this.guessedItemDelimiter = this.guessDelimiter(h)), a) {
                let t5 = h[0].split(l || this.guessedItemDelimiter || ",");
                for (let e4 = 0; e4 < t5.length; e4++)
                  t5[e4] = t5[e4].trim().replace(/^["']|["']$/g, "");
                this.headers = t5, u++;
              }
              let t4 = 0;
              for (d = u; d <= p; d++)
                "#" === h[d][0] ? t4++ : this.parseCSVRow(h[d], d - u - t4);
              i2.length && i2[0].length && "date" === i2[0][1] && !this.options.dateFormat && this.deduceDateFormat(this.columns[0], null, true);
              for (let t5 = 0, e4 = this.columns.length; t5 < e4; ++t5) {
                m = this.columns[t5];
                for (let e5 = 0, s3 = m.length; e5 < s3; ++e5)
                  if (m[e5] && "string" == typeof m[e5]) {
                    let s4 = this.asGuessedType(m[e5]);
                    s4 instanceof Date && (s4 = s4.getTime()), this.columns[t5][e5] = s4;
                  }
              }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: e3, headers: this.headers });
          }
          parseCSVRow(t3, e3) {
            let s3 = this, i2 = s3.columns || [], o = s3.dataTypes, { startColumn: n, endColumn: r } = s3.options, a = s3.options.itemDelimiter || s3.guessedItemDelimiter, { decimalPoint: l } = s3.options;
            l && l !== a || (l = s3.guessedDecimalPoint || ".");
            let h = 0, d = "", c = "", u = 0, p = 0, m = (e4) => {
              d = t3[e4];
            }, f = (t4) => {
              o.length < p + 1 && o.push([t4]), o[p][o[p].length - 1] !== t4 && o[p].push(t4);
            }, g = () => {
              if (n > u || u > r) {
                ++u, c = "";
                return;
              }
              if ("string" == typeof c ? !isNaN(parseFloat(c)) && isFinite(c) ? (c = parseFloat(c), f("number")) : isNaN(Date.parse(c)) ? f("string") : (c = c.replace(/\//g, "-"), f("date")) : f("number"), i2.length < p + 1 && i2.push([]), "number" != typeof c && "number" !== s3.guessType(c) && l) {
                let t4 = c;
                c = c.replace(l, "."), "number" !== s3.guessType(c) && (c = t4);
              }
              i2[p][e3] = c, c = "", ++p, ++u;
            };
            if (t3.trim().length && "#" !== t3.trim()[0]) {
              for (; h < t3.length; h++) {
                if (m(h), "#" === d && !/^#[0-F]{3,3}|[0-F]{6,6}/i.test(t3.substring(h))) {
                  g();
                  return;
                }
                if ('"' === d)
                  for (m(++h); h < t3.length && '"' !== d; )
                    c += d, m(++h);
                else
                  d === a ? g() : c += d;
              }
              g();
            }
          }
          guessDelimiter(t3) {
            let e3 = 0, s3 = 0, i2, o = { ",": 0, ";": 0, "	": 0 }, n = t3.length;
            for (let i3 = 0; i3 < n; i3++) {
              let n2 = false, r, a, l, h = "";
              if (i3 > 13)
                break;
              let d = t3[i3];
              for (let t4 = 0; t4 < d.length && (r = d[t4], a = d[t4 + 1], l = d[t4 - 1], "#" !== r); t4++) {
                if ('"' === r) {
                  if (n2) {
                    if ('"' !== l && '"' !== a) {
                      for (; " " === a && t4 < d.length; )
                        a = d[++t4];
                      void 0 !== o[a] && o[a]++, n2 = false;
                    }
                  } else
                    n2 = true;
                } else
                  void 0 !== o[r] ? (isNaN(Date.parse(h = h.trim())) ? (isNaN(Number(h)) || !isFinite(Number(h))) && o[r]++ : o[r]++, h = "") : h += r;
                "," === r && s3++, "." === r && e3++;
              }
            }
            return o[";"] > o[","] ? i2 = ";" : (o[","], o[";"], i2 = ","), e3 > s3 ? this.guessedDecimalPoint = "." : this.guessedDecimalPoint = ",", i2;
          }
          getTable() {
            return t2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return i.defaultOptions = { ...t2.defaultOptions, lineDelimiter: "\n" }, i;
      }), s(e, "Data/Modifiers/DataModifier.js", [e["Core/Utilities.js"]], function(e2) {
        var s2;
        let { addEvent: i, fireEvent: o, merge: n } = e2;
        class r {
          benchmark(e3, s3) {
            let i2 = [], o2 = this, r2 = () => {
              o2.modifyTable(e3), o2.emit({ type: "afterBenchmarkIteration" });
            }, { iterations: a } = n({ iterations: 1 }, s3);
            o2.on("afterBenchmarkIteration", () => {
              if (i2.length === a) {
                o2.emit({ type: "afterBenchmark", results: i2 });
                return;
              }
              r2();
            });
            let l = { startTime: 0, endTime: 0 };
            return o2.on("modify", () => {
              l.startTime = t.performance.now();
            }), o2.on("afterModify", () => {
              l.endTime = t.performance.now(), i2.push(l.endTime - l.startTime);
            }), r2(), i2;
          }
          emit(t2) {
            o(this, t2.type, t2);
          }
          modify(t2, e3) {
            let s3 = this;
            return new Promise((i2, o2) => {
              t2.modified === t2 && (t2.modified = t2.clone(false, e3));
              try {
                i2(s3.modifyTable(t2, e3));
              } catch (i3) {
                s3.emit({ type: "error", detail: e3, table: t2 }), o2(i3);
              }
            });
          }
          modifyCell(t2, e3, s3, i2, o2) {
            return this.modifyTable(t2);
          }
          modifyColumns(t2, e3, s3, i2) {
            return this.modifyTable(t2);
          }
          modifyRows(t2, e3, s3, i2) {
            return this.modifyTable(t2);
          }
          on(t2, e3) {
            return i(this, t2, e3);
          }
        }
        return (s2 = r || (r = {})).types = {}, s2.registerType = function(t2, e3) {
          return !!t2 && !s2.types[t2] && !!(s2.types[t2] = e3);
        }, r;
      }), s(e, "Data/Connectors/DataConnector.js", [e["Data/Modifiers/DataModifier.js"], e["Data/DataTable.js"], e["Core/Utilities.js"]], function(e2, s2, i) {
        var o;
        let { addEvent: n, fireEvent: r, merge: a, pick: l } = i;
        class h {
          constructor(t2 = {}) {
            this.table = new s2(t2.dataTable), this.metadata = t2.metadata || { columns: {} };
          }
          get polling() {
            return !!this.polling;
          }
          describeColumn(t2, e3) {
            let s3 = this.metadata.columns;
            s3[t2] = a(s3[t2] || {}, e3);
          }
          describeColumns(t2) {
            let e3;
            let s3 = Object.keys(t2);
            for (; "string" == typeof (e3 = s3.pop()); )
              this.describeColumn(e3, t2[e3]);
          }
          emit(t2) {
            r(this, t2.type, t2);
          }
          getColumnOrder(t2) {
            let e3 = this.metadata.columns, s3 = Object.keys(e3 || {});
            if (s3.length)
              return s3.sort((t3, s4) => l(e3[t3].index, 0) - l(e3[s4].index, 0));
          }
          getSortedColumns(t2) {
            return this.table.getColumns(this.getColumnOrder(t2));
          }
          load() {
            return r(this, "afterLoad", { table: this.table }), Promise.resolve(this);
          }
          on(t2, e3) {
            return n(this, t2, e3);
          }
          save() {
            return r(this, "saveError", { table: this.table }), Promise.reject(Error("Not implemented"));
          }
          setColumnOrder(t2) {
            for (let e3 = 0, s3 = t2.length; e3 < s3; ++e3)
              this.describeColumn(t2[e3], { index: e3 });
          }
          setModifierOptions(t2) {
            let s3 = t2 && e2.types[t2.type];
            return this.table.setModifier(s3 ? new s3(t2) : void 0).then(() => this);
          }
          startPolling(e3 = 1e3) {
            let s3 = this;
            t.clearTimeout(s3._polling), s3._polling = t.setTimeout(() => s3.load().catch((t2) => s3.emit({ type: "loadError", error: t2, table: s3.table })).then(() => {
              s3._polling && s3.startPolling(e3);
            }), e3);
          }
          stopPolling() {
            t.clearTimeout(this._polling), delete this._polling;
          }
          whatIs(t2) {
            return this.metadata.columns[t2];
          }
        }
        return (o = h || (h = {})).types = {}, o.registerType = function(t2, e3) {
          return !!t2 && !o.types[t2] && !!(o.types[t2] = e3);
        }, h;
      }), s(e, "Data/Connectors/CSVConnector.js", [e["Data/Converters/CSVConverter.js"], e["Data/Connectors/DataConnector.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        let { merge: i } = s2;
        class o extends e2 {
          constructor(e3) {
            let s3 = i(o.defaultOptions, e3);
            super(s3), this.converter = new t2(s3), this.options = s3, s3.enablePolling && this.startPolling(1e3 * Math.max(s3.dataRefreshRate || 0, 1));
          }
          load(t3) {
            let e3 = this, s3 = e3.converter, i2 = e3.table, { csv: o2, csvURL: n, dataModifier: r } = e3.options;
            return e3.emit({ type: "load", csv: o2, detail: t3, table: i2 }), Promise.resolve(n ? fetch(n).then((t4) => t4.text()) : o2 || "").then((t4) => (t4 && (i2.deleteColumns(), s3.parse({ csv: t4 }), i2.setColumns(s3.getTable().getColumns())), e3.setModifierOptions(r).then(() => t4))).then((s4) => (e3.emit({ type: "afterLoad", csv: s4, detail: t3, table: i2 }), e3)).catch((s4) => {
              throw e3.emit({ type: "loadError", detail: t3, error: s4, table: i2 }), s4;
            });
          }
        }
        return o.defaultOptions = { csv: "", csvURL: "", enablePolling: false, dataRefreshRate: 1, firstRowAsNames: true }, e2.registerType("CSV", o), o;
      }), s(e, "Data/Converters/GoogleSheetsConverter.js", [e["Data/Converters/DataConverter.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { merge: s2, uniqueKey: i } = e2;
        class o extends t2 {
          constructor(t3) {
            let e3 = s2(o.defaultOptions, t3);
            super(e3), this.columns = [], this.header = [], this.options = e3;
          }
          parse(t3, e3) {
            let o2;
            let n = s2(this.options, t3), r = (n.json && n.json.values || []).map((t4) => t4.slice());
            if (0 === r.length)
              return false;
            this.header = [], this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: e3, headers: this.header }), this.columns = r;
            for (let t4 = 0, e4 = r.length; t4 < e4; t4++) {
              o2 = r[t4], this.header[t4] = n.firstRowAsNames ? `${o2.shift()}` : i();
              for (let e5 = 0, s3 = o2.length; e5 < s3; ++e5)
                if (o2[e5] && "string" == typeof o2[e5]) {
                  let s4 = this.asGuessedType(o2[e5]);
                  s4 instanceof Date && (s4 = s4.getTime()), this.columns[t4][e5] = s4;
                }
            }
            this.emit({ type: "afterParse", columns: this.columns, detail: e3, headers: this.header });
          }
          getTable() {
            return t2.getTableFromColumns(this.columns, this.header);
          }
        }
        return o.defaultOptions = { ...t2.defaultOptions }, o;
      }), s(e, "Data/Connectors/GoogleSheetsConnector.js", [e["Data/Connectors/DataConnector.js"], e["Data/Converters/GoogleSheetsConverter.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        let { merge: i, pick: o } = s2;
        class n extends t2 {
          constructor(t3) {
            let s3 = i(n.defaultOptions, t3);
            super(s3), this.converter = new e2(s3), this.options = s3;
          }
          load(t3) {
            let e3 = this, s3 = e3.converter, i2 = e3.table, { dataModifier: o2, dataRefreshRate: r, enablePolling: a, firstRowAsNames: l, googleAPIKey: h, googleSpreadsheetKey: d } = e3.options, c = n.buildFetchURL(h, d, e3.options);
            return e3.emit({ type: "load", detail: t3, table: i2, url: c }), fetch(c).then((t4) => t4.json()).then((t4) => {
              if ("object" == typeof t4 && t4 && "object" == typeof t4.error && t4.error && "number" == typeof t4.error.code && "string" == typeof t4.error.message && "string" == typeof t4.error.status)
                throw Error(t4.error.message);
              return s3.parse({ firstRowAsNames: l, json: t4 }), i2.deleteColumns(), i2.setColumns(s3.getTable().getColumns()), e3.setModifierOptions(o2);
            }).then(() => (e3.emit({ type: "afterLoad", detail: t3, table: i2, url: c }), a && setTimeout(() => e3.load(), 1e3 * Math.max(r || 0, 1)), e3)).catch((s4) => {
              throw e3.emit({ type: "loadError", detail: t3, error: s4, table: i2 }), s4;
            });
          }
        }
        return n.defaultOptions = { googleAPIKey: "", googleSpreadsheetKey: "", worksheet: 1, enablePolling: false, dataRefreshRate: 2, firstRowAsNames: true }, function(t3) {
          let e3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          function s3(t4 = {}) {
            let { endColumn: s4, endRow: i2, googleSpreadsheetRange: n2, startColumn: r, startRow: a } = t4;
            return n2 || (e3[r || 0] || "A") + (Math.max(a || 0, 0) + 1) + ":" + (e3[o(s4, 25)] || "Z") + (i2 ? Math.max(i2, 0) : "Z");
          }
          t3.buildFetchURL = function(t4, e4, i2 = {}) {
            return `https://sheets.googleapis.com/v4/spreadsheets/${e4}/values/` + (i2.onlyColumnNames ? "A1:Z1" : s3(i2)) + "?alt=json" + (i2.onlyColumnNames ? "" : "&dateTimeRenderOption=FORMATTED_STRING&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE") + `&prettyPrint=false&key=${t4}`;
          }, t3.buildQueryRange = s3;
        }(n || (n = {})), t2.registerType("GoogleSheets", n), n;
      }), s(e, "Data/Converters/HTMLTableConverter.js", [e["Data/Converters/DataConverter.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { merge: s2 } = e2;
        class i extends t2 {
          constructor(t3) {
            let e3 = s2(i.defaultOptions, t3);
            super(e3), this.columns = [], this.headers = [], this.options = e3, e3.tableElement && (this.tableElement = e3.tableElement, this.tableElementID = e3.tableElement.id);
          }
          export(t3, e3 = this.options) {
            let s3 = false !== e3.firstRowAsNames, i2 = e3.useMultiLevelHeaders, o = t3.getSortedColumns(e3.usePresentationOrder), n = Object.keys(o), r = [], a = n.length, l = [], h = "";
            if (s3) {
              let t4 = [];
              if (i2) {
                for (let e4 of n) {
                  let s4 = (o[e4].shift() || "").toString();
                  t4.push(s4);
                }
                h = this.getTableHeaderHTML(n, t4, e3);
              } else
                h = this.getTableHeaderHTML(void 0, n, e3);
            }
            for (let t4 = 0; t4 < a; t4++) {
              let e4 = o[n[t4]], s4 = e4.length;
              for (let i3 = 0; i3 < s4; i3++) {
                let s5 = e4[i3];
                l[i3] || (l[i3] = []), "string" == typeof s5 || "number" == typeof s5 || void 0 === s5 || (s5 = (s5 || "").toString()), l[i3][t4] = this.getCellHTMLFromValue(t4 ? "td" : "th", null, t4 ? "" : 'scope="row"', s5), t4 === a - 1 && r.push("<tr>" + l[i3].join("") + "</tr>");
              }
            }
            let d = "";
            return e3.tableCaption && (d = '<caption class="highcharts-table-caption">' + e3.tableCaption + "</caption>"), "<table>" + d + h + "<tbody>" + r.join("") + "</tbody></table>";
          }
          getCellHTMLFromValue(t3, e3, s3, i2, o) {
            let n = i2, r = "text" + (e3 ? " " + e3 : "");
            return "number" == typeof n ? (n = n.toString(), "," === o && (n = n.replace(".", o)), r = "number") : i2 || (n = "", r = "empty"), "<" + t3 + (s3 ? " " + s3 : "") + ' class="' + r + '">' + n + "</" + t3 + ">";
          }
          getTableHeaderHTML(t3 = [], e3 = [], s3 = this.options) {
            let { useMultiLevelHeaders: i2, useRowspanHeaders: o } = s3, n = "<thead>", r = 0, a = e3 && e3.length, l, h = 0, d;
            if (i2 && t3 && e3 && !function(t4, e4) {
              let s4 = t4.length;
              if (e4.length !== s4)
                return false;
              for (; --s4; )
                if (t4[s4] !== e4[s4])
                  return false;
              return true;
            }(t3, e3)) {
              for (n += "<tr>"; r < a; ++r)
                (l = t3[r]) === t3[r + 1] ? ++h : h ? (n += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col" colspan="' + (h + 1) + '"', l), h = 0) : (l === e3[r] ? o ? (d = 2, delete e3[r]) : (d = 1, e3[r] = "") : d = 1, n += this.getCellHTMLFromValue("th", "highcharts-table-topheading", 'scope="col"' + (d > 1 ? ' valign="top" rowspan="' + d + '"' : ""), l));
              n += "</tr>";
            }
            if (e3) {
              for (n += "<tr>", r = 0, a = e3.length; r < a; ++r)
                void 0 !== e3[r] && (n += this.getCellHTMLFromValue("th", null, 'scope="col"', e3[r]));
              n += "</tr>";
            }
            return n + "</thead>";
          }
          parse(t3, e3) {
            let i2 = [], o = [], n = s2(this.options, t3), { endRow: r, startColumn: a, endColumn: l, firstRowAsNames: h } = n, d = n.tableElement || this.tableElement;
            if (!(d instanceof HTMLElement)) {
              this.emit({ type: "parseError", columns: i2, detail: e3, headers: o, error: "Not a valid HTML Table" });
              return;
            }
            this.tableElement = d, this.tableElementID = d.id, this.emit({ type: "parse", columns: this.columns, detail: e3, headers: this.headers });
            let c = d.getElementsByTagName("tr"), u = c.length, p = 0, m, { startRow: f } = n;
            if (h && u) {
              let t4 = c[0].children, e4 = t4.length;
              for (let s3 = a; s3 < e4 && !(s3 > l); s3++)
                ("TD" === (m = t4[s3]).tagName || "TH" === m.tagName) && o.push(m.innerHTML);
              f++;
            }
            for (; p < u; ) {
              if (p >= f && p <= r) {
                let t4 = c[p].children, e4 = t4.length, s3 = 0;
                for (; s3 < e4; ) {
                  let e5 = s3 - a, o2 = i2[e5];
                  if (("TD" === (m = t4[s3]).tagName || "TH" === m.tagName) && s3 >= a && s3 <= l) {
                    i2[e5] || (i2[e5] = []);
                    let t5 = this.asGuessedType(m.innerHTML);
                    t5 instanceof Date && (t5 = t5.getTime()), i2[e5][p - f] = t5;
                    let s4 = 1;
                    for (; p - f >= s4 && void 0 === o2[p - f - s4]; )
                      o2[p - f - s4] = null, s4++;
                  }
                  s3++;
                }
              }
              p++;
            }
            this.columns = i2, this.headers = o, this.emit({ type: "afterParse", columns: i2, detail: e3, headers: o });
          }
          getTable() {
            return t2.getTableFromColumns(this.columns, this.headers);
          }
        }
        return i.defaultOptions = { ...t2.defaultOptions, useRowspanHeaders: true, useMultiLevelHeaders: true }, i;
      }), s(e, "Data/Connectors/HTMLTableConnector.js", [e["Data/Connectors/DataConnector.js"], e["Core/Globals.js"], e["Data/Converters/HTMLTableConverter.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i) {
        let { win: o } = e2, { merge: n } = i;
        class r extends t2 {
          constructor(t3) {
            let e3 = n(r.defaultOptions, t3);
            super(e3), this.converter = new s2(e3), this.options = e3;
          }
          load(t3) {
            let e3;
            let s3 = this, i2 = s3.converter, r2 = s3.table, { dataModifier: a, table: l } = s3.options;
            if (s3.emit({ type: "load", detail: t3, table: r2, tableElement: s3.tableElement }), "string" == typeof l ? (s3.tableID = l, e3 = o.document.getElementById(l)) : (e3 = l, s3.tableID = e3.id), s3.tableElement = e3 || void 0, !s3.tableElement) {
              let e4 = "HTML table not provided, or element with ID not found";
              return s3.emit({ type: "loadError", detail: t3, error: e4, table: r2 }), Promise.reject(Error(e4));
            }
            return i2.parse(n({ tableElement: s3.tableElement }, s3.options), t3), r2.deleteColumns(), r2.setColumns(i2.getTable().getColumns()), s3.setModifierOptions(a).then(() => (s3.emit({ type: "afterLoad", detail: t3, table: r2, tableElement: s3.tableElement }), s3));
          }
        }
        return r.defaultOptions = { table: "" }, t2.registerType("HTMLTable", r), r;
      }), s(e, "Data/Converters/JSONConverter.js", [e["Data/Converters/DataConverter.js"], e["Data/DataTable.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        let { error: i, isArray: o, merge: n, objectEach: r } = s2;
        class a extends t2 {
          constructor(t3) {
            let s3 = n(a.defaultOptions, t3);
            super(s3), this.columns = [], this.headers = [], this.options = s3, this.table = new e2();
          }
          parse(t3, e3) {
            let { beforeParse: s3, orientation: a2, firstRowAsNames: l, columnNames: h } = t3 = n(this.options, t3), d = t3.data;
            if (d) {
              if (this.columns = [], this.emit({ type: "parse", columns: this.columns, detail: e3, headers: this.headers }), s3 && (d = s3(d)), d = d.slice(), "columns" === a2)
                for (let t4 = 0, e4 = d.length; t4 < e4; t4++) {
                  let e5 = d[t4];
                  if (!(e5 instanceof Array))
                    return;
                  this.headers instanceof Array ? (l ? this.headers.push(`${e5.shift()}`) : h && h instanceof Array && this.headers.push(h[t4]), this.table.setColumn(this.headers[t4] || t4.toString(), e5)) : i("JSONConverter: Invalid `columnNames` option.", false);
                }
              else if ("rows" === a2) {
                l ? this.headers = d.shift() : h && (this.headers = h);
                for (let t4 = 0, e4 = d.length; t4 < e4; t4++) {
                  let e5 = d[t4];
                  if (o(e5))
                    for (let t5 = 0, s4 = e5.length; t5 < s4; t5++)
                      this.columns.length < t5 + 1 && this.columns.push([]), this.columns[t5].push(e5[t5]), this.headers instanceof Array ? this.table.setColumn(this.headers[t5] || t5.toString(), this.columns[t5]) : i("JSONConverter: Invalid `columnNames` option.", false);
                  else {
                    let s4 = this.headers;
                    if (s4 && !(s4 instanceof Array)) {
                      let t5 = {};
                      r(s4, (s5, i2) => {
                        t5[i2] = s5.reduce((t6, e6) => t6[e6], e5);
                      }), e5 = t5;
                    }
                    this.table.setRows([e5], t4);
                  }
                }
              }
              this.emit({ type: "afterParse", columns: this.columns, detail: e3, headers: this.headers });
            }
          }
          getTable() {
            return this.table;
          }
        }
        return a.defaultOptions = { ...t2.defaultOptions, data: [], orientation: "rows" }, a;
      }), s(e, "Data/Connectors/JSONConnector.js", [e["Data/Connectors/DataConnector.js"], e["Core/Utilities.js"], e["Data/Converters/JSONConverter.js"]], function(t2, e2, s2) {
        let { merge: i } = e2;
        class o extends t2 {
          constructor(t3) {
            let e3 = i(o.defaultOptions, t3);
            super(e3), this.converter = new s2(e3), this.options = e3, e3.enablePolling && this.startPolling(1e3 * Math.max(e3.dataRefreshRate || 0, 1));
          }
          load(t3) {
            let e3 = this, s3 = e3.converter, i2 = e3.table, { data: o2, dataUrl: n, dataModifier: r } = e3.options;
            return e3.emit({ type: "load", data: o2, detail: t3, table: i2 }), Promise.resolve(n ? fetch(n).then((t4) => t4.json()) : o2 || []).then((t4) => (t4 && (i2.deleteColumns(), s3.parse({ data: t4 }), i2.setColumns(s3.getTable().getColumns())), e3.setModifierOptions(r).then(() => t4))).then((s4) => (e3.emit({ type: "afterLoad", data: s4, detail: t3, table: i2 }), e3)).catch((s4) => {
              throw e3.emit({ type: "loadError", detail: t3, error: s4, table: i2 }), s4;
            });
          }
        }
        return o.defaultOptions = { data: [], enablePolling: false, dataRefreshRate: 0, firstRowAsNames: true, orientation: "rows" }, t2.registerType("JSON", o), o;
      }), s(e, "Data/Modifiers/ChainModifier.js", [e["Data/Modifiers/DataModifier.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { merge: s2 } = e2;
        class i extends t2 {
          constructor(e3, ...o) {
            super(), this.chain = o, this.options = s2(i.defaultOptions, e3);
            let n = this.options.chain || [];
            for (let e4 = 0, s3 = n.length, i2, r; e4 < s3; ++e4)
              (i2 = n[e4]).type && (r = t2.types[i2.type]) && o.push(new r(i2));
          }
          add(t3, e3) {
            this.emit({ type: "addModifier", detail: e3, modifier: t3 }), this.chain.push(t3), this.emit({ type: "addModifier", detail: e3, modifier: t3 });
          }
          clear(t3) {
            this.emit({ type: "clearChain", detail: t3 }), this.chain.length = 0, this.emit({ type: "afterClearChain", detail: t3 });
          }
          modify(t3, e3) {
            let s3 = this.options.reverse ? this.chain.slice().reverse() : this.chain.slice();
            t3.modified === t3 && (t3.modified = t3.clone(false, e3));
            let i2 = Promise.resolve(t3);
            for (let t4 = 0, o = s3.length; t4 < o; ++t4) {
              let o2 = s3[t4];
              i2 = i2.then((t5) => o2.modify(t5.modified, e3));
            }
            return (i2 = i2.then((e4) => (t3.modified.deleteColumns(), t3.modified.setColumns(e4.modified.getColumns()), t3))).catch((s4) => {
              throw this.emit({ type: "error", detail: e3, table: t3 }), s4;
            });
          }
          modifyCell(t3, e3, s3, i2, o) {
            let n = this.options.reverse ? this.chain.reverse() : this.chain;
            if (n.length) {
              let r = t3.clone();
              for (let t4 = 0, a = n.length; t4 < a; ++t4)
                n[t4].modifyCell(r, e3, s3, i2, o), r = r.modified;
              t3.modified = r;
            }
            return t3;
          }
          modifyColumns(t3, e3, s3, i2) {
            let o = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (o.length) {
              let n = t3.clone();
              for (let t4 = 0, r = o.length; t4 < r; ++t4)
                o[t4].modifyColumns(n, e3, s3, i2), n = n.modified;
              t3.modified = n;
            }
            return t3;
          }
          modifyRows(t3, e3, s3, i2) {
            let o = this.options.reverse ? this.chain.reverse() : this.chain.slice();
            if (o.length) {
              let n = t3.clone();
              for (let t4 = 0, r = o.length; t4 < r; ++t4)
                o[t4].modifyRows(n, e3, s3, i2), n = n.modified;
              t3.modified = n;
            }
            return t3;
          }
          modifyTable(t3, e3) {
            this.emit({ type: "modify", detail: e3, table: t3 });
            let s3 = this.options.reverse ? this.chain.reverse() : this.chain.slice(), i2 = t3.modified;
            for (let t4 = 0, o = s3.length; t4 < o; ++t4)
              i2 = s3[t4].modifyTable(i2, e3).modified;
            return t3.modified = i2, this.emit({ type: "afterModify", detail: e3, table: t3 }), t3;
          }
          remove(t3, e3) {
            let s3 = this.chain;
            this.emit({ type: "removeModifier", detail: e3, modifier: t3 }), s3.splice(s3.indexOf(t3), 1), this.emit({ type: "afterRemoveModifier", detail: e3, modifier: t3 });
          }
        }
        return i.defaultOptions = { type: "Chain" }, t2.registerType("Chain", i), i;
      }), s(e, "Data/Modifiers/InvertModifier.js", [e["Data/Modifiers/DataModifier.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { merge: s2 } = e2;
        class i extends t2 {
          constructor(t3) {
            super(), this.options = s2(i.defaultOptions, t3);
          }
          modifyCell(t3, e3, s3, i2, o) {
            let n = t3.modified, r = n.getRowIndexBy("columnNames", e3);
            return void 0 === r ? n.setColumns(this.modifyTable(t3.clone()).getColumns(), void 0, o) : n.setCell(`${s3}`, r, i2, o), t3;
          }
          modifyColumns(t3, e3, s3, i2) {
            let o = t3.modified, n = o.getColumn("columnNames") || [], r = t3.getColumnNames(), a = t3.getRowCount() !== n.length;
            if (!a) {
              for (let t4 = 0, e4 = r.length; t4 < e4; ++t4)
                if (r[t4] !== n[t4]) {
                  a = true;
                  break;
                }
            }
            if (a)
              return this.modifyTable(t3, i2);
            r = Object.keys(e3);
            for (let t4 = 0, n2 = r.length, a2, l, h; t4 < n2; ++t4) {
              a2 = e3[l = r[t4]], h = o.getRowIndexBy("columnNames", l) || o.getRowCount();
              for (let t5 = 0, e4 = s3, n3 = a2.length; t5 < n3; ++t5, ++e4)
                o.setCell(`${e4}`, h, a2[t5], i2);
            }
            return t3;
          }
          modifyRows(t3, e3, s3, i2) {
            let o = t3.getColumnNames(), n = t3.modified, r = n.getColumn("columnNames") || [], a = t3.getRowCount() !== r.length;
            if (!a) {
              for (let t4 = 0, e4 = o.length; t4 < e4; ++t4)
                if (o[t4] !== r[t4]) {
                  a = true;
                  break;
                }
            }
            if (a)
              return this.modifyTable(t3, i2);
            for (let t4 = 0, r2 = s3, a2 = e3.length, l; t4 < a2; ++t4, ++r2)
              if ((l = e3[t4]) instanceof Array)
                n.setColumn(`${r2}`, l);
              else
                for (let t5 = 0, e4 = o.length; t5 < e4; ++t5)
                  n.setCell(`${r2}`, t5, l[o[t5]], i2);
            return t3;
          }
          modifyTable(t3, e3) {
            this.emit({ type: "modify", detail: e3, table: t3 });
            let s3 = t3.modified;
            if (t3.hasColumns(["columnNames"])) {
              let e4 = ((t3.deleteColumns(["columnNames"]) || {}).columnNames || []).map((t4) => `${t4}`), i2 = {};
              for (let s4 = 0, o = t3.getRowCount(), n; s4 < o; ++s4)
                (n = t3.getRow(s4)) && (i2[e4[s4]] = n);
              s3.deleteColumns(), s3.setColumns(i2);
            } else {
              let e4 = {};
              for (let s4 = 0, i2 = t3.getRowCount(), o; s4 < i2; ++s4)
                (o = t3.getRow(s4)) && (e4[`${s4}`] = o);
              e4.columnNames = t3.getColumnNames(), s3.deleteColumns(), s3.setColumns(e4);
            }
            return this.emit({ type: "afterModify", detail: e3, table: t3 }), t3;
          }
        }
        return i.defaultOptions = { type: "Invert" }, t2.registerType("Invert", i), i;
      }), s(e, "Data/Modifiers/RangeModifier.js", [e["Data/Modifiers/DataModifier.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { merge: s2 } = e2;
        class i extends t2 {
          constructor(t3) {
            super(), this.options = s2(i.defaultOptions, t3);
          }
          modifyTable(t3, e3) {
            this.emit({ type: "modify", detail: e3, table: t3 });
            let { additive: s3, ranges: i2, strict: o } = this.options;
            if (i2.length) {
              let e4 = t3.modified, n = t3.getColumns(), r = [];
              for (let a = 0, l = i2.length, h, d; a < l; ++a)
                if (h = i2[a], !o || typeof h.minValue == typeof h.maxValue) {
                  a > 0 && !s3 && (e4.deleteRows(), e4.setRows(r), n = e4.getColumns(), r = []), d = n[h.column] || [];
                  for (let i3 = 0, n2 = d.length, a2, l2; i3 < n2; ++i3) {
                    switch (typeof (a2 = d[i3])) {
                      default:
                        continue;
                      case "boolean":
                      case "number":
                      case "string":
                    }
                    (!o || typeof a2 == typeof h.minValue) && a2 >= h.minValue && a2 <= h.maxValue && (l2 = s3 ? t3.getRow(i3) : e4.getRow(i3)) && r.push(l2);
                  }
                }
              e4.deleteRows(), e4.setRows(r);
            }
            return this.emit({ type: "afterModify", detail: e3, table: t3 }), t3;
          }
        }
        return i.defaultOptions = { type: "Range", ranges: [] }, t2.registerType("Range", i), i;
      }), s(e, "Data/Modifiers/SortModifier.js", [e["Data/Modifiers/DataModifier.js"], e["Data/DataTable.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        let { merge: i } = s2;
        class o extends t2 {
          static ascending(t3, e3) {
            return (t3 || 0) < (e3 || 0) ? -1 : (t3 || 0) > (e3 || 0) ? 1 : 0;
          }
          static descending(t3, e3) {
            return (e3 || 0) < (t3 || 0) ? -1 : (e3 || 0) > (t3 || 0) ? 1 : 0;
          }
          constructor(t3) {
            super(), this.options = i(o.defaultOptions, t3);
          }
          getRowReferences(t3) {
            let e3 = t3.getRows(), s3 = [];
            for (let t4 = 0, i2 = e3.length; t4 < i2; ++t4)
              s3.push({ index: t4, row: e3[t4] });
            return s3;
          }
          modifyCell(t3, s3, i2, o2, n) {
            let { orderByColumn: r, orderInColumn: a } = this.options;
            return s3 === r && (a ? (t3.modified.setCell(s3, i2, o2), t3.modified.setColumn(a, this.modifyTable(new e2({ columns: t3.getColumns([r, a]) })).modified.getColumn(a))) : this.modifyTable(t3, n)), t3;
          }
          modifyColumns(t3, s3, i2, o2) {
            let { orderByColumn: n, orderInColumn: r } = this.options, a = Object.keys(s3);
            return a.indexOf(n) > -1 && (r && s3[a[0]].length ? (t3.modified.setColumns(s3, i2), t3.modified.setColumn(r, this.modifyTable(new e2({ columns: t3.getColumns([n, r]) })).modified.getColumn(r))) : this.modifyTable(t3, o2)), t3;
          }
          modifyRows(t3, s3, i2, o2) {
            let { orderByColumn: n, orderInColumn: r } = this.options;
            return r && s3.length ? (t3.modified.setRows(s3, i2), t3.modified.setColumn(r, this.modifyTable(new e2({ columns: t3.getColumns([n, r]) })).modified.getColumn(r))) : this.modifyTable(t3, o2), t3;
          }
          modifyTable(t3, e3) {
            this.emit({ type: "modify", detail: e3, table: t3 });
            let s3 = t3.getColumnNames(), i2 = t3.getRowCount(), n = this.getRowReferences(t3), { direction: r, orderByColumn: a, orderInColumn: l } = this.options, h = "asc" === r ? o.ascending : o.descending, d = s3.indexOf(a), c = t3.modified;
            if (-1 !== d && n.sort((t4, e4) => h(t4.row[d], e4.row[d])), l) {
              let t4 = [];
              for (let e4 = 0; e4 < i2; ++e4)
                t4[n[e4].index] = e4;
              c.setColumns({ [l]: t4 });
            } else {
              let t4 = [];
              for (let e4 = 0; e4 < i2; ++e4)
                t4.push(n[e4].row);
              c.setRows(t4, 0);
            }
            return this.emit({ type: "afterModify", detail: e3, table: t3 }), t3;
          }
        }
        return o.defaultOptions = { type: "Sort", direction: "desc", orderByColumn: "y" }, t2.registerType("Sort", o), o;
      }), s(e, "Dashboards/Components/ComponentRegistry.js", [], function() {
        var t2, e2;
        return (e2 = t2 || (t2 = {})).types = {}, e2.registerComponent = function(t3, s2) {
          return !!t3 && !e2.types[t3] && !!(e2.types[t3] = s2);
        }, t2;
      }), s(e, "Dashboards/Actions/Bindings.js", [e["Dashboards/Components/ComponentRegistry.js"], e["Dashboards/Globals.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        var i;
        let { addEvent: o, fireEvent: n, error: r } = s2;
        return function(s3) {
          function i2(t3) {
            let e3;
            let s4 = "string" == typeof t3 ? document.getElementById(t3) : t3;
            return null !== s4 && n(s4, "bindedGUIElement", {}, function(t4) {
              e3 = t4.guiElement;
            }), e3;
          }
          async function a(i3, a2, l) {
            var _a;
            let h = i3.states, d = i3.events, c = i3.renderTo || i3.cell;
            if (!c) {
              r("The `renderTo` option is required to render the component.");
              return;
            }
            l = l || s3.getCell(c);
            let u = (l == null ? void 0 : l.container) || document.querySelector("#" + c);
            if (!u || !i3.type) {
              r("The component is misconfigured and is unable to find theHTML cell element ${renderTo} to render the content.");
              return;
            }
            let p = t2.types[i3.type];
            !p && (r(`The component's type ${i3.type} does not exist.`), l && (p = t2.types.HTML, i3.title = { text: ((_a = a2.editMode) == null ? void 0 : _a.lang.errorMessage) || "Something went wrong", className: e2.classNamePrefix + "component-title-error " + e2.classNamePrefix + "component-title" }));
            let m = new p(l, i3, a2), f = m.load().catch((t3) => {
              var _a2;
              console.error(t3), m.update({ connector: { id: "" }, title: { text: ((_a2 = a2.editMode) == null ? void 0 : _a2.lang.errorMessage) || "Something went wrong", className: e2.classNamePrefix + "component-title-error " + e2.classNamePrefix + "component-title" } });
            });
            return l && (m.setCell(l), l.mountedComponent = m), a2.mountedComponents.push({ options: i3, component: m, cell: l || { id: c, container: u, mountedComponent: m } }), n(m, "mount"), d && d.click && o(u, "click", () => {
              d.click(), l && m && u && h && h.active && l.setActiveState();
            }), (h == null ? void 0 : h.hover) && u.classList.add(e2.classNames.cellHover), n(m, "afterLoad"), f;
          }
          s3.addComponent = a, s3.componentFromJSON = function(e3) {
            let i3 = t2.types[e3.$class];
            if (!i3)
              return;
            let o2 = s3.getCell(e3.options.renderTo || "");
            if (!o2)
              return;
            let n2 = i3.fromJSON(e3, o2);
            return n2 && n2.render(), n2;
          }, s3.getCell = function(t3) {
            let e3 = i2(t3);
            if (e3 && "cell" === e3.getType())
              return e3;
          }, s3.getRow = function(t3) {
            let e3 = i2(t3);
            if (e3 && "row" === e3.getType())
              return e3;
          }, s3.getLayout = function(t3) {
            let e3 = i2(t3);
            if (e3 && "layout" === e3.getType())
              return e3;
          };
        }(i || (i = {})), i;
      }), s(e, "Dashboards/Accessibility/DashboardsAccessibility.js", [], function() {
        return class {
          constructor(t2) {
            this.board = t2, this.addTabIndexToCells();
          }
          addTabIndexToCells() {
            let t2;
            let e2 = this.board.mountedComponents;
            for (let s2 = 0, i = e2.length; s2 < i; ++s2)
              (t2 = e2[s2].cell) && t2.container && t2.container.setAttribute("tabindex", -1);
          }
        };
      }), s(e, "Data/DataCursor.js", [], function() {
        class t2 {
          constructor(t3 = {}) {
            this.emittingRegister = [], this.listenerMap = {}, this.stateMap = t3;
          }
          addListener(t3, e2, s2) {
            let i = this.listenerMap[t3] = this.listenerMap[t3] || {};
            return (i[e2] = i[e2] || []).push(s2), this;
          }
          buildEmittingTag(t3) {
            return ("position" === t3.cursor.type ? [t3.table.id, t3.cursor.column, t3.cursor.row, t3.cursor.state, t3.cursor.type] : [t3.table.id, t3.cursor.columns, t3.cursor.firstRow, t3.cursor.lastRow, t3.cursor.state, t3.cursor.type]).join("\0");
          }
          emitCursor(e2, s2, i, o, n) {
            let r = "object" == typeof s2 ? s2 : i, a = "object" == typeof o ? o : i, l = "string" == typeof s2 ? s2 : void 0, h = e2.id, d = r.state, c = this.listenerMap[h] && this.listenerMap[h][d];
            if (n = n || true === o, c) {
              let s3 = this.stateMap[h] = this.stateMap[h] || {}, i2 = s3[r.state] || [];
              n && (i2.length || (s3[r.state] = i2), -1 === t2.getIndex(r, i2) && i2.push(r));
              let o2 = { cursor: r, cursors: i2, table: e2 };
              a && (o2.event = a), l && (o2.group = l);
              let d2 = this.emittingRegister, u = this.buildEmittingTag(o2);
              if (d2.indexOf(u) >= 0)
                return this;
              try {
                this.emittingRegister.push(u);
                for (let t3 = 0, e3 = c.length; t3 < e3; ++t3)
                  c[t3].call(this, o2);
              } finally {
                let t3 = this.emittingRegister.indexOf(u);
                t3 >= 0 && this.emittingRegister.splice(t3, 1);
              }
            }
            return this;
          }
          remitCursor(e2, s2) {
            let i = this.stateMap[e2] && this.stateMap[e2][s2.state];
            if (i) {
              let e3 = t2.getIndex(s2, i);
              e3 >= 0 && i.splice(e3, 1);
            }
            return this;
          }
          removeListener(t3, e2, s2) {
            let i = this.listenerMap[t3] && this.listenerMap[t3][e2];
            if (i) {
              let t4 = i.indexOf(s2);
              t4 && i.splice(t4, 1);
            }
            return this;
          }
        }
        return t2.version = "1.0.0", function(t3) {
          function e2(t4, e3) {
            if ("range" === t4.type)
              return t4;
            let s2 = { type: "range", firstRow: t4.row ?? (e3 && e3.firstRow) ?? 0, lastRow: t4.row ?? (e3 && e3.lastRow) ?? Number.MAX_VALUE, state: t4.state };
            return void 0 !== t4.column && (s2.columns = [t4.column]), s2;
          }
          t3.getIndex = function(t4, e3) {
            if ("position" === t4.type) {
              for (let s2, i = 0, o = e3.length; i < o; ++i)
                if ("position" === (s2 = e3[i]).type && s2.state === t4.state && s2.column === t4.column && s2.row === t4.row)
                  return i;
            } else {
              let s2 = JSON.stringify(t4.columns);
              for (let i, o = 0, n = e3.length; o < n; ++o)
                if ("range" === (i = e3[o]).type && i.state === t4.state && i.firstRow === t4.firstRow && i.lastRow === t4.lastRow && JSON.stringify(i.columns) === s2)
                  return o;
            }
            return -1;
          }, t3.isEqual = function(t4, e3) {
            return "position" === t4.type && "position" === e3.type ? t4.column === e3.column && t4.row === e3.row && t4.state === e3.state : "range" === t4.type && "range" === e3.type && t4.firstRow === e3.firstRow && t4.lastRow === e3.lastRow && JSON.stringify(t4.columns) === JSON.stringify(e3.columns);
          }, t3.isInRange = function(t4, s2) {
            "position" === s2.type && (s2 = e2(s2)), "position" === t4.type && (t4 = e2(t4, s2));
            let i = t4.columns, o = s2.columns;
            return t4.firstRow >= s2.firstRow && t4.lastRow <= s2.lastRow && (!i || !o || i.every((t5) => o.indexOf(t5) >= 0));
          }, t3.toPositions = function(t4) {
            if ("position" === t4.type)
              return [t4];
            let e3 = t4.columns || [], s2 = [], i = t4.state;
            for (let o = t4.firstRow, n = t4.lastRow; o < n; ++o) {
              if (!e3.length) {
                s2.push({ type: "position", row: o, state: i });
                continue;
              }
              for (let t5 = 0, n2 = e3.length; t5 < n2; ++t5)
                s2.push({ type: "position", column: e3[t5], row: o, state: i });
            }
            return s2;
          }, t3.toRange = e2;
        }(t2 || (t2 = {})), t2;
      }), s(e, "Dashboards/SerializeHelper/DataCursorHelper.js", [e["Data/DataCursor.js"], e["Dashboards/Serializable.js"]], function(t2, e2) {
        let s2 = { $class: "Data.DataCursor", fromJSON: function(e3) {
          return new t2(e3.stateMap);
        }, jsonSupportFor: function(e3) {
          return e3 instanceof t2;
        }, toJSON: function(t3) {
          let e3, s3, i, o, n;
          let r = t3.stateMap, a = {}, l = Object.keys(t3.stateMap);
          for (let t4 = 0, h = l.length; t4 < h; ++t4) {
            n = Object.keys(r[i = l[t4]]), a[i] = {};
            for (let t5 = 0, l2 = n.length; t5 < l2; ++t5) {
              o = n[t5], e3 = r[i][o], a[i][o] = s3 = [];
              for (let t6 = 0, i2 = e3.length; t6 < i2; ++t6)
                s3.push({ ...e3[t6] });
            }
          }
          return { $class: "Data.DataCursor", stateMap: a };
        } };
        return e2.registerHelper(s2), s2;
      }), s(e, "Data/DataPoolDefaults.js", [], function() {
        return { connectors: [] };
      }), s(e, "Data/DataPool.js", [e["Data/Connectors/DataConnector.js"], e["Data/DataPoolDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        class i {
          constructor(t3 = e2) {
            t3.connectors = t3.connectors || [], this.connectors = {}, this.options = t3, this.waiting = {};
          }
          emit(t3) {
            s2.fireEvent(this, t3.type, t3);
          }
          getConnector(t3) {
            let e3 = this.connectors[t3];
            if (e3)
              return Promise.resolve(e3);
            let s3 = this.waiting[t3];
            if (!s3) {
              s3 = this.waiting[t3] = [];
              let e4 = this.getConnectorOptions(t3);
              if (!e4)
                throw Error(`Connector not found. (${t3})`);
              this.loadConnector(e4).then((e5) => {
                delete this.waiting[t3];
                for (let t4 = 0, i2 = s3.length; t4 < i2; ++t4)
                  s3[t4][0](e5);
              }).catch((e5) => {
                delete this.waiting[t3];
                for (let t4 = 0, i2 = s3.length; t4 < i2; ++t4)
                  s3[t4][1](e5);
              });
            }
            return new Promise((t4, e4) => {
              s3.push([t4, e4]);
            });
          }
          getConnectorIds() {
            let t3 = this.options.connectors, e3 = [];
            for (let s3 = 0, i2 = t3.length; s3 < i2; ++s3)
              e3.push(t3[s3].id);
            return e3;
          }
          getConnectorOptions(t3) {
            let e3 = this.options.connectors;
            for (let s3 = 0, i2 = e3.length; s3 < i2; ++s3)
              if (e3[s3].id === t3)
                return e3[s3];
          }
          getConnectorTable(t3) {
            return this.getConnector(t3).then((t4) => t4.table);
          }
          isNewConnector(t3) {
            return !this.connectors[t3];
          }
          loadConnector(e3) {
            return new Promise((s3, i2) => {
              this.emit({ type: "load", options: e3 });
              let o = t2.types[e3.type];
              if (!o)
                throw Error(`Connector type not found. (${e3.type})`);
              new o(e3.options).load().then((t3) => {
                this.connectors[e3.id] = t3, this.emit({ type: "afterLoad", options: e3 }), s3(t3);
              }).catch(i2);
            });
          }
          on(t3, e3) {
            return s2.addEvent(this, t3, e3);
          }
          setConnectorOptions(t3) {
            let e3 = this.options.connectors, s3 = this.connectors;
            this.emit({ type: "setConnectorOptions", options: t3 });
            for (let s4 = 0, i2 = e3.length; s4 < i2; ++s4)
              if (e3[s4].id === t3.id) {
                e3.splice(s4, 1);
                break;
              }
            s3[t3.id] && (s3[t3.id].stopPolling(), delete s3[t3.id]), e3.push(t3), this.emit({ type: "afterSetConnectorOptions", options: t3 });
          }
        }
        return i.version = "1.0.0", i;
      }), s(e, "Dashboards/EditMode/EditGlobals.js", [e["Dashboards/Globals.js"]], function(t2) {
        let e2 = t2.classNamePrefix + "edit-";
        return { classNames: { resizeSnap: e2 + "resize-snap", resizeSnapX: e2 + "resize-snap-x", resizeSnapY: e2 + "resize-snap-y", separator: e2 + "separator", contextMenuBtn: e2 + "context-menu-btn", contextMenuBtnText: e2 + "context-menu-btn-text", contextMenu: e2 + "context-menu", contextMenuItem: e2 + "context-menu-item", editModeEnabled: e2 + "enabled", editToolbar: e2 + "toolbar", editToolbarCellOutline: e2 + "toolbar-cell-outline", editToolbarRowOutline: e2 + "toolbar-row-outline", editToolbarItem: e2 + "toolbar-item", editToolbarRow: e2 + "toolbar-row", editToolbarCell: e2 + "toolbar-cell", editSidebar: e2 + "sidebar", editSidebarShow: e2 + "sidebar-show", editSidebarHide: e2 + "sidebar-hide", editSidebarTitle: e2 + "sidebar-title", editSidebarMenuItem: e2 + "sidebar-item", rowContextHighlight: e2 + "row-context-highlight", cellEditHighlight: e2 + "cell-highlight", dashboardCellEditHighlightActive: e2 + "cell-highlight-active", dragMock: e2 + "drag-mock", dropPointer: e2 + "drop-pointer", contextDetectionPointer: e2 + "ctx-detection-pointer", resizePointer: e2 + "resize-pointer", currentEditedElement: e2 + "unmask", maskElement: e2 + "mask", menuItem: e2 + "menu-item", menu: e2 + "menu", menuVerticalSeparator: e2 + "menu-vertical-separator", menuHorizontalSeparator: e2 + "menu-horizontal-separator", menuDestroy: e2 + "menu-destroy", editSidebarWrapper: e2 + "sidebar-wrapper", customSelect: e2 + "custom-select", customSelectButton: e2 + "custom-option-button", toggleContainer: e2 + "toggle-container", toggleWrapper: e2 + "toggle-wrapper", toggleSlider: e2 + "toggle-slider", toggleWrapperColored: e2 + "toggle-wrapper-colored", toggleLabels: e2 + "toggle-labels", button: e2 + "button", sidebarNavButton: e2 + "sidebar-button-nav", labelText: e2 + "label-text", editSidebarTabBtn: e2 + "sidebar-tab-btn", editToolsBtn: e2 + "tools-btn", editTools: e2 + "tools", editGridItems: e2 + "grid-items", confirmationPopup: e2 + "confirmation-popup", popupButtonContainer: e2 + "confirmation-popup-button-container", popupContentContainer: e2 + "confirmation-popup-content", popupCancelBtn: e2 + "confirmation-popup-cancel-btn", popupConfirmBtn: e2 + "confirmation-popup-confirm-btn", popupCloseButton: e2 + "popup-close", editOverlay: e2 + "overlay", editOverlayActive: e2 + "overlay-active", resizerMenuBtnActive: e2 + "resizer-menu-btn-active", sidebarCloseButton: e2 + "close-btn", editSidebarTabBtnWrapper: e2 + "tabs-buttons-wrapper", editSidebarRight: e2 + "sidebar-right", editSidebarRightShow: e2 + "sidebar-right-show", viewFullscreen: e2 + "view-fullscreen", accordionMenu: e2 + "accordion-menu", accordionContainer: e2 + "accordion", accordionHeader: e2 + "accordion-header", accordionHeaderBtn: e2 + "accordion-header-btn", accordionHeaderIcon: e2 + "accordion-header-icon", accordionContent: e2 + "accordion-content", accordionNestedWrapper: e2 + "accordion-nested", accordionMenuButtonsContainer: e2 + "accordion-menu-buttons-container", accordionMenuButton: e2 + "accordion-menu-button", hiddenElement: e2 + "hidden-element", collapsableContentHeader: e2 + "collapsable-content-header", collapsedElement: e2 + "collapsed-element", dropdown: e2 + "dropdown", dropdownContent: e2 + "dropdown-content", dropdownButton: e2 + "dropdown-button", dropdownButtonContent: e2 + "dropdown-button-content", dropdownIcon: e2 + "pointer", icon: e2 + "icon" }, lang: { accessibility: { contextMenu: { button: "Context menu" }, editMode: { editMode: "Edit mode toggle button" } }, addComponent: "Add component", cancelButton: "Cancel", caption: "Caption", chartClassName: "Chart class name", chartConfig: "Chart configuration", chartID: "Chart ID", chartOptions: "Chart options", chartType: "Chart type", connectorName: "Connector name", confirmButton: "Confirm", confirmDestroyCell: "Do you really want to destroy the cell?", confirmDestroyRow: "Do you really want to destroy the row?", dataLabels: "Data labels", editMode: "Edit mode", errorMessage: "Something went wrong", exitFullscreen: "Exit full screen", id: "Id", off: "off", on: "on", pointFormat: "Point format", settings: "Settings", style: "Styles", title: "Title", viewFullscreen: "View in full screen", sidebar: { HTML: "HTML", layout: "Layout", Highcharts: "Highcharts", DataGrid: "DataGrid", KPI: "KPI" } } };
      }), s(e, "Dashboards/Layout/GUIElement.js", [e["Core/Utilities.js"], e["Dashboards/Globals.js"]], function(t2, e2) {
        let { addEvent: s2, createElement: i, uniqueKey: o, objectEach: n, error: r } = t2;
        return class {
          static getOffsets(t3, e3) {
            let s3 = { left: 0, top: 0, right: 0, bottom: 0 };
            if (t3.container) {
              let i2 = t3.container.getBoundingClientRect(), o2 = e3 ? e3.getBoundingClientRect() : { left: 0, top: 0 };
              s3.left = i2.left - o2.left, s3.top = i2.top - o2.top, s3.right = i2.right - o2.left, s3.bottom = i2.bottom - o2.top;
            }
            return s3;
          }
          static getDimFromOffsets(t3) {
            return { width: t3.right - t3.left, height: t3.bottom - t3.top };
          }
          static createElementId(t3) {
            return e2.classNamePrefix + t3 + "-" + o().slice(11);
          }
          static getPercentageWidth(t3) {
            let e3;
            let s3 = /^([0-9]{1})[\-\/\.]([0-9]{1,2})$/;
            if (s3.test(t3)) {
              let i2 = t3.match(s3) || [];
              e3 = ((e3 = 100 * +i2[1] / +i2[2]) <= 100 ? e3 : 100) + "%";
            } else if (-1 !== t3.indexOf("%")) {
              let s4 = parseFloat(t3);
              e3 = (s4 <= 100 ? s4 >= 0 ? s4 : 0 : 100) + "%";
            }
            return e3;
          }
          getElementContainer(t3) {
            let e3;
            let o2 = this;
            if (t3.render)
              t3.attribs && !t3.attribs.id && delete t3.attribs.id;
            else if ("string" == typeof t3.elementId) {
              let e4 = document.getElementById(t3.elementId);
              e4 ? o2.container = e4 : r("Element " + t3.elementId + " does not exist");
            }
            return t3.element instanceof HTMLElement ? e3 = t3.element : e3 = i("div", t3.attribs || {}, t3.style || {}, t3.parentContainer), o2.removeBindedEventFn = s2(e3, "bindedGUIElement", function(t4) {
              t4.guiElement = o2, t4.stopImmediatePropagation();
            }), e3;
          }
          destroy() {
            let t3 = this;
            t3.removeBindedEventFn && t3.removeBindedEventFn(), t3.container && t3.container.parentNode && t3.container.parentNode.removeChild(t3.container), n(t3, function(e3, s3) {
              delete t3[s3];
            });
          }
          getType() {
            return this.type;
          }
          changeVisibility(t3 = true, e3) {
            let s3 = this.isVisible && !t3 || !this.isVisible && t3;
            this.container && s3 && (this.container.style.display = t3 ? e3 || "block" : "none", this.isVisible = t3);
          }
          hide() {
            this.changeVisibility(false);
          }
          show() {
            this.changeVisibility();
          }
        };
      }), s(e, "Dashboards/Layout/Cell.js", [e["Dashboards/Actions/Bindings.js"], e["Dashboards/EditMode/EditGlobals.js"], e["Dashboards/Globals.js"], e["Dashboards/Layout/GUIElement.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i, o) {
        let { componentFromJSON: n } = t2, { merge: r, fireEvent: a } = o;
        class l extends i {
          static fromJSON(t3, e3) {
            if (e3) {
              let s3 = t3.options, i2 = s3.containerId;
              return e3.layout.copyId && (i2 = i2 + "_" + e3.layout.copyId), new l(e3, { id: i2, parentContainerId: e3.container && e3.container.id || s3.parentContainerId, mountedComponentJSON: s3.mountedComponentJSON, style: s3.style, layoutJSON: s3.layoutJSON, width: s3.width, height: s3.height });
            }
          }
          constructor(t3, e3, i2) {
            let o2;
            super(), this.type = s2.guiElementType.cell, this.id = e3.id, this.options = e3, this.row = t3, this.isVisible = true;
            let n2 = document.getElementById(e3.parentContainerId || "") || t3.container, a2 = t3.layout.options || {}, l2 = t3.options || {}, h = a2.cellClassName || "";
            if (e3.height && (o2 = "number" == typeof e3.height ? e3.height + "px" : e3.height), this.container = this.getElementContainer({ render: t3.layout.board.guiEnabled, parentContainer: n2, attribs: { id: e3.id, className: s2.classNames.cell + " " + h }, element: i2, elementId: e3.id, style: r(a2.style, l2.style, e3.style, { height: o2 }) }), this.options.mountedComponentJSON && this.mountComponentFromJSON(this.options.mountedComponentJSON), this.options.layout && this.setNestedLayout(), this.options.layoutJSON) {
              let t4 = this.row.layout, e4 = t4.board, s3 = t4.constructor.fromJSON;
              this.nestedLayout = s3(r(this.options.layoutJSON, { parentContainerId: this.options.id }), e4, this);
            }
          }
          setNestedLayout() {
            let t3 = this.row.layout.board, e3 = this.row.layout.constructor, s3 = t3.options.gui;
            this.nestedLayout = new e3(t3, r({}, s3 && s3.layoutOptions, this.options.layout, { parentContainerId: this.options.id }), this);
          }
          mountComponentFromJSON(t3) {
            this.id !== t3.options.parentElement && (t3.options.parentElement = this.id);
            let e3 = n(t3);
            return !!e3 && (this.mountedComponent = e3, true);
          }
          destroy() {
            var _a, _b, _c;
            let { row: t3 } = this;
            (_a = this.mountedComponent) == null ? void 0 : _a.destroy(), (_b = this.nestedLayout) == null ? void 0 : _b.destroy(), t3.unmountCell(this);
            let e3 = ((_c = t3.cells) == null ? void 0 : _c.length) === 0;
            super.destroy(), e3 && t3.destroy();
          }
          toJSON() {
            let t3 = (this.row.container || {}).id || "";
            return { $class: "Dashboards.Layout.Cell", options: { containerId: this.container.id, parentContainerId: t3, width: this.options.width, height: this.options.height, mountedComponentJSON: this.mountedComponent && this.mountedComponent.toJSON(), style: this.options.style, layoutJSON: this.nestedLayout && this.nestedLayout.toJSON() } };
          }
          getOptions() {
            return this.options;
          }
          changeVisibility(t3 = true) {
            super.changeVisibility(t3);
            let e3 = this, s3 = e3.row;
            e3.row.getVisibleCells().length ? e3.isVisible && !s3.isVisible && e3.row.show() : e3.row.hide(), setTimeout(() => {
              a(s3, "cellChange", { row: s3, cell: e3 });
            }, 0);
          }
          getParentCell(t3) {
            let e3;
            if (t3 <= this.row.layout.level) {
              if (this.row.layout.level === t3)
                return this;
              if (this.row.layout.level - 1 >= 0 && (e3 = this.row.layout.parentCell))
                return e3.getParentCell(t3);
            }
          }
          getOverlappingLevels(t3, e3, s3) {
            let o2 = this.row.layout.parentCell, n2 = [this.row.layout.level];
            if (o2) {
              let r2 = s3 || i.getOffsets(this)[t3], a2 = i.getOffsets(o2)[t3];
              Math.abs(r2 - a2) < e3 && (n2 = [...n2, ...o2.getOverlappingLevels(t3, e3, a2)]);
            }
            return n2;
          }
          setSize(t3, e3) {
            let s3 = this.row.layout.board.editMode;
            if (this.container) {
              if (t3) {
                if ("auto" === t3 && "1 1 0%" !== this.container.style.flex)
                  this.container.style.flex = "1 1 0%";
                else {
                  let e4 = this.convertWidthToValue(t3);
                  e4 && this.container.style.flex !== "0 0 " + e4 && (this.container.style.flex = "0 0 " + e4), this.options.width = e4;
                }
              }
              e3 && (this.options.height = this.container.style.height = e3 + "px"), s3 && (s3.hideContextPointer(), s3.cellToolbar && s3.cellToolbar.isVisible && (s3.cellToolbar.cell === this ? s3.cellToolbar.showToolbar(this) : s3.cellToolbar.hide())), a(this.row.layout.board, "cellResize", { cell: this }), a(this.row, "cellChange", { cell: this, row: this.row });
            }
          }
          setHighlight(t3) {
            let s3 = this.row.layout.board.editMode;
            if (this.container && s3) {
              let s4 = this.container, i2 = s4.classList.contains(e2.classNames.cellEditHighlight);
              t3 || i2 ? t3 && i2 && (s4.classList.remove(e2.classNames.cellEditHighlight), this.row.layout.board.container.classList.remove(e2.classNames.dashboardCellEditHighlightActive), this.isHighlighted = false) : (s4.classList.add(e2.classNames.cellEditHighlight), this.row.layout.board.container.classList.add(e2.classNames.dashboardCellEditHighlightActive), this.isHighlighted = true);
            }
          }
          setActiveState() {
            this.row.layout.board.mountedComponents.forEach((t3) => {
              t3.cell.container && t3.cell.container.classList.remove(s2.classNames.cellActive);
            }), this.container && this.container.classList.add(s2.classNames.cellActive);
          }
          setLoadingState(t3 = true) {
            var _a, _b;
            (_b = (_a = this.container) == null ? void 0 : _a.classList) == null ? void 0 : _b.toggle(s2.classNames.cellLoading, t3);
          }
          convertWidthToValue(t3) {
            return "number" == typeof t3 ? t3 + "px" : /px/.test(t3) ? t3 : i.getPercentageWidth(t3) || "";
          }
        }
        return l;
      }), s(e, "Dashboards/Layout/Row.js", [e["Dashboards/Globals.js"], e["Dashboards/Layout/Cell.js"], e["Dashboards/Layout/GUIElement.js"], e["Core/Utilities.js"], e["Dashboards/EditMode/EditGlobals.js"]], function(t2, e2, s2, i, o) {
        let { pick: n, defined: r, merge: a, objectEach: l, fireEvent: h } = i;
        class d extends s2 {
          static fromJSON(t3, e3) {
            if (e3) {
              let s3 = t3.options, i2 = s3.containerId || "";
              return i2 && e3.copyId && (i2 = i2 + "_" + e3.copyId), new d(e3, { id: i2, parentContainerId: e3.container && e3.container.id || s3.parentContainerId, cellsJSON: s3.cells, style: s3.style });
            }
          }
          static setContainerHeight(t3, e3) {
            e3 && (t3.style.height = e3 + "px");
          }
          constructor(e3, s3, i2) {
            super(), this.type = t2.guiElementType.row, this.layout = e3, this.cells = [], this.options = s3, this.isVisible = true;
            let o2 = document.getElementById(s3.parentContainerId || "") || e3.container, n2 = e3.options || {}, r2 = n2.rowClassName || "";
            this.container = this.getElementContainer({ render: e3.board.guiEnabled, parentContainer: o2, attribs: { id: s3.id, className: t2.classNames.row + " " + r2 }, element: i2, elementId: s3.id, style: a(n2.style, s3.style) }), this.options.cells && this.setCells(), s3.cellsJSON && !this.cells.length && this.setCellsFromJSON(s3.cellsJSON);
          }
          setCells() {
            let t3, e3, s3;
            let i2 = (this.layout.options || {}).cellClassName || "", o2 = n(this.options.cells, this.container && this.container.getElementsByClassName(i2)) || [];
            for (e3 = 0, s3 = o2.length; e3 < s3; ++e3)
              t3 = o2[e3], this.addCell(this.layout.board.guiEnabled ? t3 : { id: "" }, t3 instanceof HTMLElement ? t3 : void 0);
          }
          setCellsFromJSON(t3) {
            let s3, i2;
            let o2 = [];
            for (let n2 = 0, r2 = t3.length; n2 < r2; ++n2)
              i2 = t3[n2], (s3 = e2.fromJSON({ $class: i2.$class, options: { containerId: i2.options.containerId, parentContainerId: i2.options.parentContainerId, width: i2.options.width, height: i2.options.height, style: i2.options.style, layoutJSON: i2.options.layoutJSON, mountedComponentJSON: void 0 } }, this)) && (this.cells.push(s3), i2.options.mountedComponentJSON && o2.push({ cell: s3, mountedComponentJSON: i2.options.mountedComponentJSON }));
            for (let t4 = 0, e3 = o2.length; t4 < e3; ++t4)
              o2[t4].cell.mountComponentFromJSON(o2[t4].mountedComponentJSON);
          }
          addCell(t3, s3, i2) {
            let o2 = new e2(this, t3, s3);
            return r(i2) ? this.mountCell(o2, i2) : this.cells.push(o2), this.layout.board.editMode && this.layout.board.editMode.setCellEvents(o2), o2;
          }
          destroy() {
            var _a;
            let { layout: t3 } = this, e3 = [...this.cells];
            for (let t4 = 0, s3 = e3 == null ? void 0 : e3.length; t4 < s3; ++t4)
              e3[t4] && e3[t4].destroy();
            this.layout && (this.layout.unmountRow(this), super.destroy(), ((_a = t3.rows) == null ? void 0 : _a.length) === 0 && t3.destroy());
          }
          toJSON() {
            let t3 = (this.layout.container || {}).id || "", e3 = [];
            for (let t4 = 0, s3 = this.cells.length; t4 < s3; ++t4)
              e3.push(this.cells[t4].toJSON());
            return { $class: "Dashboards.Layout.Row", options: { containerId: this.container.id, parentContainerId: t3, cells: e3, style: this.options.style } };
          }
          getOptions() {
            let t3 = [];
            for (let e3 = 0, s3 = this.cells.length; e3 < s3; ++e3)
              t3.push(this.cells[e3].getOptions());
            return { id: this.options.id, style: this.options.style, cells: t3 };
          }
          setSize(t3) {
            d.setContainerHeight(this.container, t3);
          }
          getCellIndex(t3) {
            var _a;
            for (let e3 = 0, s3 = (_a = this.cells) == null ? void 0 : _a.length; e3 < s3; ++e3)
              if (this.cells[e3].id === t3.id)
                return e3;
          }
          mountCell(t3, e3 = 0) {
            let s3 = this, i2 = s3.cells[e3], o2 = s3.cells[e3 - 1];
            t3.container && (i2 && i2.container ? i2.container.parentNode.insertBefore(t3.container, i2.container) : o2 && o2.container ? o2.container.parentNode.insertBefore(t3.container, o2.container.nextSibling) : o2 || i2 || !s3.container || s3.container.appendChild(t3.container), s3.cells.splice(e3, 0, t3), t3.row = s3, setTimeout(() => {
              h(s3, "cellChange", { row: s3, cell: t3 });
            }, 0));
          }
          unmountCell(t3) {
            let e3 = this.getCellIndex(t3);
            r(e3) && this.cells.splice(e3, 1), setTimeout(() => {
              h(this, "cellChange", { row: this, cell: t3 });
            }, 0);
          }
          getVisibleCells() {
            let t3 = [];
            for (let e3 = 0, s3 = this.cells.length; e3 < s3; ++e3)
              this.cells[e3].isVisible && t3.push(this.cells[e3]);
            return t3;
          }
          changeVisibility(t3 = true, e3) {
            super.changeVisibility(t3, e3), this.layout.getVisibleRows().length ? this.isVisible && !this.layout.isVisible && this.layout.show() : this.layout.hide();
          }
          show() {
            this.changeVisibility(true, "flex");
          }
          setHighlight(t3) {
            if (this.container) {
              let e3 = this.container, s3 = e3.classList.contains(o.classNames.rowContextHighlight);
              t3 || s3 ? t3 && s3 && e3.classList.remove(o.classNames.rowContextHighlight) : e3.classList.add(o.classNames.rowContextHighlight);
            }
          }
          getRowLevels() {
            let t3, e3;
            let i2 = {}, o2 = [];
            for (let o3 = 0, n2 = this.cells.length; o3 < n2; ++o3)
              (t3 = this.cells[o3]).isVisible && (i2[(e3 = s2.getOffsets(t3)).top] || (i2[e3.top] = { top: e3.top, bottom: e3.bottom, cells: [] }), i2[e3.top].bottom < e3.bottom && (i2[e3.top].bottom = e3.bottom), i2[e3.top].cells.push(t3));
            return l(i2, (t4) => {
              o2.push(t4);
            }), o2;
          }
          getRowLevelInfo(t3) {
            let e3;
            let s3 = this.getRowLevels();
            for (let i2 = 0, o2 = s3.length; i2 < o2; ++i2)
              s3[i2].top <= t3 && s3[i2].bottom > t3 && (e3 = { index: i2, rowLevels: s3, rowLevel: s3[i2] });
            return e3;
          }
        }
        return d;
      }), s(e, "Dashboards/Layout/Layout.js", [e["Dashboards/Utilities.js"], e["Core/Utilities.js"], e["Dashboards/Layout/Row.js"], e["Dashboards/Layout/GUIElement.js"], e["Dashboards/Globals.js"]], function(t2, e2, s2, i, o) {
        let { uniqueKey: n } = t2, { pick: r, defined: a } = e2;
        class l extends i {
          static fromJSON(t3, e3, s3) {
            let i2 = t3.options, o2 = document.getElementById(t3.options.containerId), r2 = new l(e3, { id: i2.containerId, copyId: o2 ? n() : "", parentContainerId: i2.parentContainerId || e3.container.id, rowsJSON: i2.rows, style: i2.style }, s3);
            return r2 && !s3 && e3.layouts.push(r2), r2;
          }
          static importLocal(t3, e3) {
            let s3;
            let i2 = localStorage.getItem(o.classNamePrefix + t3);
            return i2 && (s3 = l.fromJSON(JSON.parse(i2), e3)), s3;
          }
          constructor(t3, e3, s3) {
            super(), this.type = o.guiElementType.layout, this.board = t3, this.rows = [], this.options = e3, this.isVisible = true;
            let i2 = s3 ? s3.container : document.getElementById(e3.parentContainerId || "") || t3.layoutsWrapper;
            s3 ? (this.parentCell = s3, this.level = s3.row.layout.level + 1) : this.level = 0, e3.copyId && (this.copyId = e3.copyId);
            let n2 = (this.options || {}).rowClassName || "";
            this.container = this.getElementContainer({ render: t3.guiEnabled, parentContainer: i2, attribs: { id: (e3.id || "") + (this.copyId ? "_" + this.copyId : ""), className: o.classNames.layout + " " + n2 }, elementId: e3.id, style: this.options.style }), this.options.rows && this.setRows(), e3.rowsJSON && !this.rows.length && this.setRowsFromJSON(e3.rowsJSON);
          }
          setRows() {
            let t3, e3, s3;
            let i2 = r(this.options.rows, this.container && this.container.getElementsByClassName(this.options.rowClassName || "")) || [];
            for (e3 = 0, s3 = i2.length; e3 < s3; ++e3)
              t3 = i2[e3], this.addRow(this.board.guiEnabled ? t3 : {}, t3 instanceof HTMLElement ? t3 : void 0);
          }
          setRowsFromJSON(t3) {
            let e3;
            for (let i2 = 0, o2 = t3.length; i2 < o2; ++i2)
              (e3 = s2.fromJSON(t3[i2], this)) && this.rows.push(e3);
          }
          addRow(t3, e3, i2) {
            let o2 = new s2(this, t3, e3);
            return a(i2) ? this.mountRow(o2, i2) : this.rows.push(o2), this.board.editMode && this.board.editMode.setRowEvents(o2), o2;
          }
          destroy() {
            for (let t3 = this.board.layouts.length - 1; t3 >= 0; t3--)
              this.board.layouts[t3] === this && this.board.layouts.splice(t3, 1);
            this.parentCell && delete this.parentCell.nestedLayout;
            for (let t3 = this.rows.length - 1; t3 >= 0; t3--)
              this.rows[t3].destroy();
            this.parentCell && this.parentCell.destroy(), super.destroy();
          }
          exportLocal() {
            localStorage.setItem(o.classNamePrefix + this.options.id, JSON.stringify(this.toJSON()));
          }
          getRowIndex(t3) {
            for (let e3 = 0, s3 = this.rows.length; e3 < s3; ++e3)
              if (this.rows[e3] === t3)
                return e3;
          }
          mountRow(t3, e3) {
            let s3 = this.rows[e3], i2 = this.rows[e3 - 1];
            t3.container && (s3 && s3.container ? s3.container.parentNode.insertBefore(t3.container, s3.container) : i2 && i2.container && i2.container.parentNode.insertBefore(t3.container, i2.container.nextSibling), this.rows.splice(e3, 0, t3), t3.layout = this);
          }
          unmountRow(t3) {
            let e3 = this.getRowIndex(t3);
            a(e3) && this.rows.splice(e3, 1);
          }
          getVisibleRows() {
            let t3 = [];
            for (let e3 = 0, s3 = this.rows.length; e3 < s3; ++e3)
              this.rows[e3].isVisible && t3.push(this.rows[e3]);
            return t3;
          }
          changeVisibility(t3 = true) {
            super.changeVisibility(t3), this.parentCell && (this.isVisible && !this.parentCell.isVisible ? this.parentCell.show() : !this.isVisible && this.parentCell.isVisible && this.parentCell.hide());
          }
          toJSON() {
            let t3 = (this.board.container || {}).id || "", e3 = [];
            for (let t4 = 0, s3 = this.rows.length; t4 < s3; ++t4)
              e3.push(this.rows[t4].toJSON());
            return { $class: "Dashboards.Layout", options: { containerId: this.container.id, parentContainerId: t3, rows: e3, style: this.options.style } };
          }
          getOptions() {
            let t3 = [];
            for (let e3 = 0, s3 = this.rows.length; e3 < s3; ++e3)
              t3.push(this.rows[e3].getOptions());
            return { id: this.options.id, layoutClassName: this.options.layoutClassName, rowClassName: this.options.rowClassName, cellClassName: this.options.cellClassName, style: this.options.style, rows: t3 };
          }
        }
        return l;
      }), s(e, "Dashboards/Board.js", [e["Dashboards/Actions/Bindings.js"], e["Dashboards/Components/ComponentRegistry.js"], e["Dashboards/Accessibility/DashboardsAccessibility.js"], e["Data/DataCursor.js"], e["Dashboards/SerializeHelper/DataCursorHelper.js"], e["Data/DataPool.js"], e["Dashboards/Globals.js"], e["Dashboards/Layout/Layout.js"], e["Dashboards/Serializable.js"], e["Dashboards/Components/HTMLComponent/HTMLComponent.js"], e["Core/Utilities.js"]], function(e2, s2, i, o, n, r, a, l, h, d, c) {
        var u;
        let { merge: p, addEvent: m, error: f, objectEach: g, uniqueKey: y, createElement: b } = c;
        class C {
          static board(t2, e3, s3) {
            return new C(t2, e3).init(s3);
          }
          constructor(t2, e3) {
            var _a, _b, _c, _d;
            this.componentTypes = s2.types, this.options = p(C.defaultOptions, e3), this.dataPool = new r(e3.dataPool), this.id = y(), this.guiEnabled = !!e3.gui && ((_b = (_a = this.options) == null ? void 0 : _a.gui) == null ? void 0 : _b.enabled), this.editModeEnabled = !!e3.editMode && ((_d = (_c = this.options) == null ? void 0 : _c.editMode) == null ? void 0 : _d.enabled), this.layouts = [], this.mountedComponents = [], this.initContainer(t2), this.guiEnabled && this.initLayout(), this.dataCursor = new o(), this.index = a.boards.length, a.boards.push(this), this.a11y = new i(this);
          }
          init(t2) {
            let e3 = this.options, s3 = e3.components ? this.setComponents(e3.components) : [];
            return (this.initEvents(), t2) ? Promise.all(s3).then(() => this) : this;
          }
          initEvents() {
            let e3 = this, s3 = () => {
              e3.reflow();
            };
            if ("function" == typeof ResizeObserver)
              this.resizeObserver = new ResizeObserver(s3), this.resizeObserver.observe(e3.container);
            else {
              let e4 = m(t, "resize", s3);
              m(this, "destroy", e4);
            }
          }
          initContainer(e3) {
            "string" == typeof e3 && (e3 = t.document.getElementById(e3)), e3 || f(13, true), this.guiEnabled ? (e3.innerHTML = "", this.boardWrapper = e3, this.container = b("div", { className: a.classNames.boardContainer }, {}, this.boardWrapper)) : this.container = e3;
          }
          initLayout() {
            let t2 = this.options;
            if (Dashboards.EditMode)
              this.layoutsWrapper = b("div", { className: a.classNames.layoutsWrapper }, {}, this.container), t2.gui && this.setLayouts(t2.gui), t2.layoutsJSON && !this.layouts.length && this.setLayoutsFromJSON(t2.layoutsJSON), this.editModeEnabled && (this.editMode = new Dashboards.EditMode(this, this.options.editMode), this.fullscreen = new Dashboards.FullScreen(this));
            else
              throw Error("Missing layout.js module");
          }
          setLayouts(t2) {
            let e3 = t2.layouts;
            for (let s3 = 0, i2 = e3.length; s3 < i2; ++s3)
              this.layouts.push(new l(this, p({}, t2.layoutOptions, e3[s3])));
          }
          setLayoutsFromJSON(t2) {
            let e3;
            for (let s3 = 0, i2 = t2.length; s3 < i2; ++s3)
              (e3 = l.fromJSON(t2[s3], this)) && this.layouts.push(e3);
          }
          setComponents(t2) {
            let s3 = [];
            for (let i2 = 0, o2 = t2.length; i2 < o2; ++i2)
              s3.push(e2.addComponent(t2[i2], this));
            return s3;
          }
          destroy() {
            var _a, _b, _c;
            let t2 = this;
            for (let e3 = 0, s3 = (_a = t2.layouts) == null ? void 0 : _a.length; e3 < s3; ++e3)
              t2.layouts[e3].destroy();
            (_b = this.resizeObserver) == null ? void 0 : _b.unobserve(t2.container), (_c = t2.container) == null ? void 0 : _c.remove(), g(t2, function(e3, s3) {
              delete t2[s3];
            }), a.boards[this.index] = void 0;
          }
          exportLocal() {
            localStorage.setItem(a.classNamePrefix + "1", JSON.stringify(this.toJSON()));
          }
          importLayoutLocal(t2) {
            return l.importLocal(t2, this);
          }
          reflow() {
            if (this.editMode) {
              let t2 = this.editMode.tools;
              this.editMode.hideToolbars(["cell", "row"]), this.editMode.hideContextPointer(), t2.contextMenu && t2.contextMenu.updatePosition(t2.contextButtonElement);
            }
          }
          fromJSON(t2) {
            let e3 = t2.options, s3 = new C(e3.containerId, { componentOptions: e3.componentOptions, dataPool: e3.dataPool, layoutsJSON: e3.layouts });
            return s3.dataCursor = n.fromJSON(t2.dataCursor), s3;
          }
          toJSON() {
            let t2 = [];
            for (let e3 = 0, s3 = this.layouts.length; e3 < s3; ++e3)
              t2.push(this.layouts[e3].toJSON());
            return { $class: "Board", dataCursor: n.toJSON(this.dataCursor), options: { containerId: this.container.id, dataPool: this.options.dataPool, guiEnabled: this.guiEnabled, layouts: t2, componentOptions: this.options.componentOptions } };
          }
          getOptions() {
            let t2 = [], e3 = [];
            for (let e4 = 0, s3 = this.layouts.length; e4 < s3; ++e4)
              t2.push(this.layouts[e4].getOptions());
            for (let t3 = 0, s3 = this.mountedComponents.length; t3 < s3; ++t3)
              this.mountedComponents[t3].cell && this.mountedComponents[t3].cell.mountedComponent && e3.push(this.mountedComponents[t3].component.getOptions());
            return { ...this.options, gui: { layouts: t2 }, components: e3 };
          }
        }
        return (u = C || (C = {})).defaultOptions = { gui: { enabled: true, layoutOptions: { rowClassName: void 0, cellClassName: void 0 }, layouts: [] }, components: [] }, u.importLocal = function() {
          let t2 = localStorage.getItem(a.classNamePrefix + "1");
          if (t2)
            try {
              return h.fromJSON(JSON.parse(t2));
            } catch (t3) {
            }
        }, h.registerClassPrototype("Board", C.prototype), s2.registerComponent("HTML", d), C;
      }), s(e, "Dashboards/Components/DataGridComponent/DataGridSyncHandlers.js", [e["Core/Utilities.js"]], function(t2) {
        let { addEvent: e2, removeEvent: s2 } = t2, i = { emitters: { highlightEmitter: function() {
          if ("DataGrid" !== this.type)
            return;
          let { dataGrid: t3, board: i2 } = this, o = this.sync.syncConfig.highlight;
          if (!i2 || !t3 || !o.enabled)
            return;
          let { dataCursor: n } = i2, r = (t4) => {
            let e3 = this.connector && this.connector.table;
            if (e3) {
              let s3 = t4.row, i3 = s3.querySelector(`.highcharts-datagrid-cell[data-original-data="${s3.dataset.rowXIndex}"]`);
              n.emitCursor(e3, { type: "position", row: parseInt(s3.dataset.rowIndex, 10), column: i3 ? i3.dataset.columnName : void 0, state: "dataGrid.hoverRow" });
            }
          }, a = () => {
            let t4 = this.connector && this.connector.table;
            t4 && n.emitCursor(t4, { type: "position", state: "dataGrid.hoverOut" });
          };
          return e2(t3.container, "dataGridHover", r), e2(t3.container, "mouseout", a), function() {
            s2(t3.container, "dataGridHover", r), s2(t3.container, "mouseout", a);
          };
        } }, handlers: { highlightHandler: function() {
          let { board: t3 } = this;
          if (!this.sync.syncConfig.highlight.enabled)
            return;
          let e3 = (t4) => {
            let e4 = t4.cursor;
            if ("position" === e4.type) {
              let { row: t5 } = e4, { dataGrid: s4 } = this;
              if (void 0 !== t5 && s4) {
                let e5 = s4.container.querySelector(`.highcharts-datagrid-row[data-row-index="${t5}"]`);
                e5 && (s4.toggleRowHighlight(e5), s4.hoveredRow = e5);
              }
            }
          }, s3 = () => {
            let { dataGrid: t4 } = this;
            t4 && t4.toggleRowHighlight(void 0);
          };
          if (t3)
            return (() => {
              let { dataCursor: i2 } = t3;
              if (!i2)
                return;
              let o = this.connector && this.connector.table;
              o && (i2.addListener(o.id, "point.mouseOver", e3), i2.addListener(o.id, "point.mouseOut", s3));
            })(), () => {
              let i2 = t3.dataCursor, o = this.connector && this.connector.table;
              o && (i2.removeListener(o.id, "point.mouseOver", e3), i2.removeListener(o.id, "point.mouseOut", s3));
            };
        }, extremesHandler: function() {
          let { board: t3 } = this, e3 = (t4) => {
            let e4 = t4.cursor;
            if ("position" === e4.type && this.dataGrid && "number" == typeof (e4 == null ? void 0 : e4.row)) {
              let { row: t5 } = e4;
              this.dataGrid.scrollToRow(t5);
            }
          };
          if (t3)
            return (() => {
              let { dataCursor: s3 } = t3;
              if (!s3)
                return;
              let i2 = this.connector && this.connector.table;
              i2 && s3.addListener(i2.id, "xAxis.extremes.min", e3);
            })(), () => {
              let s3 = this.connector && this.connector.table, { dataCursor: i2 } = t3;
              s3 && i2.removeListener(s3.id, "xAxis.extremes.min", e3);
            };
        }, visibilityHandler: function() {
          let t3 = this, { board: e3 } = t3, s3 = (e4) => {
            let s4 = e4.cursor, i2 = t3.dataGrid;
            if (!(i2 && "position" === s4.type && s4.column))
              return;
            let o = s4.column;
            i2.update({ columns: { [o]: { show: "series.hide" !== s4.state } } });
          };
          if (e3)
            return (() => {
              let { dataCursor: t4 } = e3;
              if (!t4)
                return;
              let i2 = this.connector && this.connector.table;
              i2 && (t4.addListener(i2.id, "series.show", s3), t4.addListener(i2.id, "series.hide", s3));
            })(), () => {
              let t4 = this.connector && this.connector.table, { dataCursor: i2 } = e3;
              t4 && (i2.removeListener(t4.id, "series.show", s3), i2.removeListener(t4.id, "series.hide", s3));
            };
        } } };
        return { highlight: { emitter: i.emitters.highlightEmitter, handler: i.handlers.highlightHandler }, extremes: { handler: i.handlers.extremesHandler }, visibility: { handler: i.handlers.visibilityHandler } };
      }), s(e, "Dashboards/Components/DataGridComponent/DataGridComponentDefaults.js", [e["Data/Converters/DataConverter.js"], e["Dashboards/Components/DataGridComponent/DataGridSyncHandlers.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        let { uniqueKey: i } = s2;
        return { dataGridClassName: "dataGrid-container", dataGridID: "dataGrid-" + i(), dataGridOptions: {}, editableOptions: [{ name: "connectorName", propertyPath: ["connector", "id"], type: "select" }], syncHandlers: e2, onUpdate: (e3, s3) => {
          let i2 = e3.target;
          if (i2) {
            let e4 = i2.closest(".highcharts-datagrid-row"), o = i2.closest(".highcharts-datagrid-cell"), n = new t2();
            if (e4 && e4 instanceof HTMLElement && o && o instanceof HTMLElement) {
              let t3 = e4.dataset.rowIndex, { columnName: r } = o.dataset;
              if (void 0 !== t3 && void 0 !== r) {
                let e5 = s3.table;
                if (e5) {
                  let s4 = n.asGuessedType(i2.value);
                  s4 instanceof Date && (s4 = s4.toString()), e5.setCell(r, parseInt(t3, 10), s4);
                }
              }
            }
          }
        } };
      }), s(e, "Dashboards/Components/DataGridComponent/DataGridComponent.js", [e["Dashboards/Components/Component.js"], e["Dashboards/Components/DataGridComponent/DataGridSyncHandlers.js"], e["Dashboards/Components/DataGridComponent/DataGridComponentDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i) {
        let { diffObjects: o, merge: n } = i;
        class r extends t2 {
          static fromJSON(t3, e3) {
            let s3 = new r(e3, n(t3.options, { dataGridOptions: JSON.parse(t3.options.dataGridOptions || ""), syncHandlers: r.syncHandlers }));
            return s3.emit({ type: "fromJSON", json: t3 }), s3;
          }
          constructor(t3, e3, s3) {
            super(t3, e3 = n(r.defaultOptions, e3), s3), this.connectorListeners = [], this.options = e3, this.type = "DataGrid", this.options.dataGridClassName && this.contentElement.classList.add(this.options.dataGridClassName), this.options.dataGridID && (this.contentElement.id = this.options.dataGridID), this.sync = new r.Sync(this, this.syncHandlers), this.dataGridOptions = this.options.dataGridOptions || {}, this.innerResizeTimeouts = [], this.on("afterSetConnector", (t4) => {
              this.disableEditingModifiedColumns(t4.connector);
            });
          }
          onTableChanged() {
            var _a;
            this.dataGrid && !((_a = this.dataGrid) == null ? void 0 : _a.cellInputEl) && this.dataGrid.update({ dataTable: this.filterColumns() });
          }
          disableEditingModifiedColumns(t3) {
            var _a;
            let e3 = this.getColumnOptions(t3);
            (_a = this.dataGrid) == null ? void 0 : _a.update({ columns: e3 });
          }
          getColumnOptions(t3) {
            let e3 = t3.options.dataModifier;
            if (!e3 || "Math" !== e3.type)
              return {};
            let s3 = e3.columnFormulas;
            if (!s3)
              return {};
            let i2 = {};
            for (let t4 = 0, e4 = s3.length; t4 < e4; ++t4)
              i2[s3[t4].column] = { editable: false };
            return i2;
          }
          async load() {
            if (this.emit({ type: "load" }), await super.load(), this.connector && !this.connectorListeners.length) {
              let t3 = this.connectorListeners;
              t3.push(this.connector.on("afterLoad", (t4) => {
                t4.table && this.connector && this.connector.table.setColumns(t4.table.getColumns());
              })), t3.push(this.connector.table.on("afterSetCell", (t4) => {
                let e3 = this.dataGrid, s3 = true;
                if (e3) {
                  let i2 = e3.rowElements[t4.rowIndex], o2 = [];
                  i2 && (o2 = Array.prototype.slice.call(i2.childNodes)), o2.forEach((e4) => {
                    if (e4.childElementCount > 0) {
                      let i3 = e4.childNodes[0], o3 = "string" == typeof t4.cellValue ? i3.value : +i3.value;
                      e4.dataset.columnName === t4.columnName && o3 === t4.cellValue && (s3 = false);
                    }
                  });
                }
                s3 && this.update({});
              }));
            }
            return this.emit({ type: "afterLoad" }), this;
          }
          render() {
            return super.render(), this.dataGrid || (this.dataGrid = this.constructDataGrid()), this.connector && this.dataGrid && this.dataGrid.dataTable.modified !== this.connector.table.modified && this.dataGrid.update({ dataTable: this.filterColumns() }), this.sync.start(), this.emit({ type: "afterRender" }), this.setupConnectorUpdate(), this;
          }
          resize(t3, e3) {
            this.dataGrid && super.resize(t3, e3);
          }
          async update(t3) {
            var _a;
            if (((_a = t3.connector) == null ? void 0 : _a.id) !== this.connectorId) {
              let t4 = this.connectorListeners;
              for (let e3 = 0, s3 = t4.length; e3 < s3; ++e3)
                t4[e3]();
              t4.length = 0;
            }
            await super.update(t3), this.dataGrid && (this.filterAndAssignSyncOptions(e2), this.dataGrid.update(this.options.dataGridOptions || {})), this.emit({ type: "afterUpdate" });
          }
          constructDataGrid() {
            var _a, _b;
            if (r.DataGridNamespace) {
              let t3 = r.DataGridNamespace.DataGrid, e3 = this.connector ? this.getColumnOptions(this.connector) : {};
              return this.dataGrid = new t3(this.contentElement, { ...this.options.dataGridOptions, dataTable: ((_a = this.options.dataGridOptions) == null ? void 0 : _a.dataTable) || this.filterColumns(), columns: n(e3, (_b = this.options.dataGridOptions) == null ? void 0 : _b.columns) }), this.dataGrid;
            }
            throw Error("DataGrid not connected.");
          }
          setupConnectorUpdate() {
            let { connector: t3, dataGrid: e3 } = this;
            t3 && e3 && e3.on("cellClick", (e4) => {
              "input" in e4 && e4.input.addEventListener("keyup", (e5) => this.options.onUpdate(e5, t3));
            });
          }
          filterColumns() {
            var _a;
            let t3 = (_a = this.connector) == null ? void 0 : _a.table.modified, e3 = this.options.visibleColumns;
            if (t3) {
              if (!(e3 == null ? void 0 : e3.length))
                return t3;
              let s3 = t3.getColumnNames().filter((t4) => (e3 == null ? void 0 : e3.length) > 0 && !e3.includes(t4)), i2 = t3.clone();
              return i2.deleteColumns(s3), i2;
            }
          }
          getOptionsOnDrop(t3) {
            let e3 = t3.editMode.board.dataPool.getConnectorIds(), s3 = { cell: "", type: "DataGrid" };
            return e3.length && (s3 = { ...s3, connector: { id: e3[0] } }), s3;
          }
          toJSON() {
            let t3 = JSON.stringify(this.options.dataGridOptions), e3 = super.toJSON(), s3 = { ...e3, options: { ...e3.options, dataGridOptions: t3 } };
            return this.emit({ type: "toJSON", json: s3 }), s3;
          }
          getOptions() {
            return { ...o(this.options, r.defaultOptions), type: "DataGrid" };
          }
          destroy() {
            var _a;
            (_a = this.dataGrid) == null ? void 0 : _a.containerResizeObserver.disconnect(), super.destroy();
          }
        }
        return r.syncHandlers = e2, r.defaultOptions = n(t2.defaultOptions, s2), r;
      }), s(e, "Dashboards/Plugins/DataGridPlugin.js", [e["Dashboards/Components/DataGridComponent/DataGridComponent.js"]], function(t2) {
        return { custom: { connectDataGrid: function(e2) {
          t2.DataGridNamespace = e2;
        } }, name: "DataGrid.DashboardsPlugin", onRegister: function(e2) {
          let { ComponentRegistry: s2 } = e2;
          s2.registerComponent("DataGrid", t2);
        }, onUnregister: function(t3) {
        } };
      }), s(e, "Dashboards/Components/HighchartsComponent/HighchartsSyncHandlers.js", [e["Core/Utilities.js"]], function(t2) {
        let { addEvent: e2, isString: s2 } = t2;
        function i(t3, e3) {
          let { ranges: s3 } = e3;
          if (s3) {
            let e4 = s3.reduce((t4, e5) => (e5.minValue > t4.minValue && (t4 = e5), t4), s3[0]), i2 = t3.getRowIndexBy(e4.column, e4.minValue);
            if (i2)
              return i2;
          }
          return 0;
        }
        let o = { emitters: { highlightEmitter: function() {
          if ("Highcharts" !== this.type)
            return;
          let { chart: t3, board: e3 } = this;
          if (!this.sync.syncConfig.highlight.enabled)
            return;
          let { dataCursor: s3 } = e3, o2 = this.connector && this.connector.table;
          return (t3 == null ? void 0 : t3.series) && o2 && t3.series.forEach((e4) => {
            e4.update({ point: { events: { mouseOver: function() {
              let t4 = 0, n = o2.getModifier();
              (n == null ? void 0 : n.options.type) === "Range" && (t4 = i(o2, n.options)), s3.emitCursor(o2, { type: "position", row: t4 + this.index, column: e4.name, state: "point.mouseOver" });
            }, mouseOut: function() {
              let t4 = 0, n = o2.getModifier();
              (n == null ? void 0 : n.options.type) === "Range" && (t4 = i(o2, n.options)), s3.emitCursor(o2, { type: "position", row: t4 + this.index, column: e4.name, state: "point.mouseOut" });
            } } } }, false), t3.redraw();
          }), function() {
            t3 && t3.series && (t3.series.forEach((t4) => {
              t4.update({ point: { events: { mouseOver: void 0, mouseOut: void 0 } } }, false);
            }), t3.redraw());
          };
        }, seriesVisibilityEmitter: function() {
          if ("Highcharts" !== this.type)
            return;
          let { chart: t3, connector: e3, board: s3 } = this;
          if (!s3 || !t3)
            return;
          let i2 = e3 == null ? void 0 : e3.table;
          if (i2) {
            let { dataCursor: e4 } = s3, { series: o2 } = t3;
            o2.forEach((t4) => {
              t4.update({ events: { show: function() {
                e4.emitCursor(i2, { type: "position", state: "series.show", column: this.name });
              }, hide: function() {
                e4.emitCursor(i2, { type: "position", state: "series.hide", column: this.name });
              } } }, false);
            }), t3.redraw();
          }
          return function() {
            var _a;
            t3 && ((_a = t3.series) == null ? void 0 : _a.length) && (t3.series.forEach((t4) => {
              t4.update({ events: { show: void 0, hide: void 0 } }, false);
            }), t3.redraw());
          };
        }, extremesEmitter: function() {
          if ("Highcharts" === this.type) {
            let t3 = this, i2 = [], { chart: o2, connector: n, board: r } = t3, a = n && n.table, { dataCursor: l } = r;
            if (a && o2) {
              let n2 = (e3) => {
                var _a;
                let i3 = !!e3.resetSelection;
                if ((!e3.trigger || e3.trigger && "dashboards-sync" !== e3.trigger) && !i3) {
                  let i4 = e3.target, n3 = t3.seriesFromConnector.length > 0 ? o2.get(t3.seriesFromConnector[0]) : i4.series[0];
                  if (n3) {
                    let o3 = n3.points.filter((t4) => t4.isInside || false), r3 = { type: "position", state: `${i4.coll}.extremes.min` }, h2 = { type: "position", state: `${i4.coll}.extremes.max` };
                    if (t3.seriesFromConnector.length > 0 && "xAxis" === i4.coll && o3.length) {
                      let e4;
                      let l2 = (_a = t3.options.connector) == null ? void 0 : _a.columnAssignment;
                      if (l2) {
                        let t4 = l2.find((t5) => t5.seriesId === n3.options.id);
                        if (t4) {
                          let i5 = t4.data;
                          e4 = s2(i5) ? i5 : Array.isArray(i5) ? i5[i5.length - 1] : i5.y;
                        }
                      }
                      e4 || (e4 = i4.dateTime && a.hasColumns(["x"]) ? "x" : n3.options.id ?? n3.name), r3.row = o3[0].index, r3.column = e4, h2.row = o3[o3.length - 1].index, h2.column = e4;
                    }
                    l.emitCursor(a, r3, e3, true).emitCursor(a, h2, e3, true);
                  }
                }
              }, r2 = () => o2.axes.map((t4) => e2(t4, "afterSetExtremes", n2)), h = r2(), d = () => {
                h.forEach((t4) => {
                  t4();
                }), h = [];
              };
              i2.push(e2(o2, "selection", (t4) => {
                t4.resetSelection && (d(), l.emitCursor(a, { type: "position", state: "chart.zoomOut" }, t4), h.push(...r2()));
              })), i2.push(() => {
                l.remitCursor(a.id, { type: "position", state: "xAxis.extremes.min" }), l.remitCursor(a.id, { type: "position", state: "xAxis.extremes.max" }), d();
              });
            }
            return function() {
              i2.forEach((t4) => {
                t4();
              });
            };
          }
        } }, handlers: { seriesVisibilityHandler: function() {
          let t3 = this, { board: e3 } = this, s3 = (t4, e4) => {
            for (let s4 of t4)
              if (s4.name === e4)
                return s4;
          }, i2 = (e4) => {
            var _a;
            let i3 = t3.chart;
            if (i3 && ((_a = i3.series) == null ? void 0 : _a.length) && "position" === e4.cursor.type && void 0 !== e4.cursor.column) {
              let t4 = s3(i3.series, e4.cursor.column);
              t4 && t4.setVisible(true, true);
            }
          }, o2 = (e4) => {
            var _a;
            let i3 = t3.chart;
            if (i3 && ((_a = i3.series) == null ? void 0 : _a.length) && "position" === e4.cursor.type && void 0 !== e4.cursor.column) {
              let t4 = s3(i3.series, e4.cursor.column);
              t4 && t4.setVisible(false, true);
            }
          };
          if (e3)
            return (() => {
              let { dataCursor: t4 } = e3;
              if (!t4)
                return;
              let s4 = this.connector && this.connector.table;
              s4 && (t4.addListener(s4.id, "series.show", i2), t4.addListener(s4.id, "series.hide", o2));
            })(), () => {
              let t4 = this.connector && this.connector.table;
              t4 && (e3.dataCursor.removeListener(t4.id, "series.show", i2), e3.dataCursor.removeListener(t4.id, "series.hide", o2));
            };
        }, highlightHandler: function() {
          let { chart: t3, board: e3 } = this, s3 = (e4) => {
            var _a;
            let s4 = this.connector && this.connector.table;
            if (!s4)
              return;
            let o3 = 0, n2 = s4.getModifier();
            if (n2 && "Range" === n2.options.type && (o3 = i(s4, n2.options)), t3 && ((_a = t3.series) == null ? void 0 : _a.length)) {
              let s5 = e4.cursor;
              if ("position" === s5.type) {
                let [e5] = t3.series;
                if (t3.series.length > 1 && s5.column) {
                  let i2 = t3.series.filter((t4) => t4.name === s5.column);
                  i2.length > 0 && ([e5] = i2);
                }
                if ((e5 == null ? void 0 : e5.visible) && void 0 !== s5.row) {
                  let t4 = e5.data[s5.row - o3];
                  if (t4 == null ? void 0 : t4.graphic)
                    return t4;
                }
              }
            }
          }, o2 = (e4) => {
            var _a, _b, _c;
            let i2 = this.sync.syncConfig.highlight;
            if (!i2.enabled)
              return;
            let o3 = s3(e4);
            if (!o3 || !t3 || !o3.isInside && o3.series.isCartesian || o3 === t3.hoverPoint)
              return;
            let n2 = t3.tooltip;
            if (n2 && i2.showTooltip) {
              let e5 = n2.shared, s4 = t3.hoverPoint, i3 = (s4 == null ? void 0 : s4.series) || t3.hoverSeries, r = (_a = t3.pointer) == null ? void 0 : _a.getHoverData(o3, i3, t3.series, true, true);
              t3.tooltip && r && n2.refresh(e5 ? r.hoverPoints : o3);
            }
            i2.highlightPoint && (!(n2 == null ? void 0 : n2.shared) && i2.showTooltip || !i2.showTooltip) && o3.setState("hover"), i2.showCrosshair && ((_b = o3.series.xAxis) == null ? void 0 : _b.drawCrosshair(void 0, o3), (_c = o3.series.yAxis) == null ? void 0 : _c.drawCrosshair(void 0, o3));
          }, n = (e4) => {
            var _a, _b;
            let i2 = this.sync.syncConfig.highlight;
            if (!t3 || !t3.series.length || !i2.enabled)
              return;
            let o3 = s3(e4);
            if (o3 && (!o3.isInside && o3.series.isCartesian || o3 === t3.hoverPoint))
              return;
            let n2 = false, r = () => {
              let e5 = t3.series.length;
              for (let s4 = 0; s4 < e5; s4++) {
                let e6 = t3.series[s4].points, i3 = e6.length;
                for (let t4 = 0; t4 < i3; t4++)
                  e6[t4].setState();
              }
            }, a = t3.tooltip;
            if (a && i2.showTooltip && (a.hide(), a.shared && (r(), n2 = true)), i2.highlightPoint && !n2 && (o3 ? o3.setState() : r()), i2.showCrosshair) {
              if (o3)
                (_a = o3.series.xAxis) == null ? void 0 : _a.drawCrosshair(), (_b = o3.series.yAxis) == null ? void 0 : _b.drawCrosshair();
              else {
                let e5 = t3.xAxis, s4 = t3.yAxis;
                for (let t4 = 0, s5 = e5.length; t4 < s5; t4++)
                  e5[t4].drawCrosshair();
                for (let t4 = 0, e6 = s4.length; t4 < e6; t4++)
                  s4[t4].drawCrosshair();
              }
            }
          };
          if (e3)
            return (() => {
              let { dataCursor: t4 } = e3;
              if (t4) {
                let e4 = this.connector && this.connector.table;
                e4 && (t4.addListener(e4.id, "point.mouseOver", o2), t4.addListener(e4.id, "dataGrid.hoverRow", o2), t4.addListener(e4.id, "point.mouseOut", n), t4.addListener(e4.id, "dataGrid.hoverOut", n));
              }
            })(), () => {
              let t4 = this.connector && this.connector.table;
              t4 && (e3.dataCursor.removeListener(t4.id, "point.mouseOver", o2), e3.dataCursor.removeListener(t4.id, "dataGrid.hoverRow", o2), e3.dataCursor.removeListener(t4.id, "point.mouseOut", n), e3.dataCursor.removeListener(t4.id, "dataGrid.hoverOut", n));
            };
        }, extremesHandler: function() {
          var _a;
          let { chart: t3, board: e3 } = this;
          if (t3 && e3 && ((_a = t3.zooming) == null ? void 0 : _a.type)) {
            let s3 = t3.zooming.type.split("").map((t4) => t4 + "Axis"), i2 = [];
            return s3.forEach((s4) => {
              let o2 = (e4) => {
                let { cursor: i3, event: o3 } = e4;
                if ("position" === i3.type) {
                  let e5 = o3 && o3.target;
                  if (e5 && t3) {
                    let i4 = t3[s4], o4 = false;
                    i4.forEach((t4) => {
                      e5.coll === t4.coll && e5 !== t4 && null !== e5.min && null !== e5.max && (t4.max !== e5.max || t4.min !== e5.min) && (t4.setExtremes(e5.min, e5.max, false, void 0, { trigger: "dashboards-sync" }), o4 = true);
                    }), o4 && !t3.resetZoomButton && t3.showResetZoom(), t3.redraw();
                  }
                }
              };
              e3 && (() => {
                let { dataCursor: n } = e3, { connector: r } = this;
                if (r) {
                  let { table: e4 } = r;
                  n.addListener(e4.id, `${s4}.extremes.min`, o2), n.addListener(e4.id, `${s4}.extremes.max`, o2);
                  let a = () => {
                    t3.zoomOut(), setTimeout(() => {
                      this.element.querySelectorAll(".highcharts-reset-zoom").forEach((t4) => {
                        t4.remove();
                      });
                    });
                  };
                  n.addListener(e4.id, "chart.zoomOut", a), i2.push(() => {
                    n.removeListener(e4.id, `${s4}.extremes.min`, o2), n.removeListener(e4.id, `${s4}.extremes.max`, o2), n.removeListener(e4.id, "chart.zoomOut", a);
                  });
                }
              })();
            }), function() {
              i2.forEach((t4) => {
                t4();
              });
            };
          }
        } } };
        return { extremes: { emitter: o.emitters.extremesEmitter, handler: o.handlers.extremesHandler }, highlight: { emitter: o.emitters.highlightEmitter, handler: o.handlers.highlightHandler }, visibility: { emitter: o.emitters.seriesVisibilityEmitter, handler: o.handlers.seriesVisibilityHandler } };
      }), s(e, "Dashboards/Components/HighchartsComponent/HighchartsComponentDefaults.js", [e["Dashboards/Components/Component.js"], e["Dashboards/Components/HighchartsComponent/HighchartsSyncHandlers.js"], e["Core/Utilities.js"]], function(t2, e2, s2) {
        let { merge: i, uniqueKey: o } = s2;
        return { allowConnectorUpdate: true, className: [t2.defaultOptions.className, `${t2.defaultOptions.className}-highcharts`].join(" "), chartClassName: "chart-container", chartID: "chart-" + o(), chartOptions: { chart: { styledMode: true }, series: [] }, chartConstructor: "chart", editableOptions: (t2.defaultOptions.editableOptions || []).concat([{ name: "chartOptions", type: "nested", nestedOptions: [{ name: "chart", options: [{ name: "title", propertyPath: ["chartOptions", "title", "text"], type: "input" }, { name: "subtitle", propertyPath: ["chartOptions", "subtitle", "text"], type: "input" }, { name: "type", propertyPath: ["chartOptions", "chart", "type"], type: "select", selectOptions: [{ name: "column", iconURL: "series-types/icon-column.svg" }, { name: "line", iconURL: "series-types/icon-line.svg" }, { name: "scatter", iconURL: "series-types/icon-scatter.svg" }, { name: "pie", iconURL: "series-types/icon-pie.svg" }] }] }, { name: "xAxis", options: [{ name: "title", propertyPath: ["chartOptions", "xAxis", "title", "text"], type: "input" }, { name: "type", propertyPath: ["chartOptions", "xAxis", "type"], type: "select", selectOptions: [{ name: "linear" }, { name: "datetime" }, { name: "logarithmic" }] }] }, { name: "yAxis", options: [{ name: "title", propertyPath: ["chartOptions", "yAxis", "title", "text"], type: "input" }, { name: "type", propertyPath: ["chartOptions", "yAxis", "type"], type: "select", selectOptions: [{ name: "linear" }, { name: "datetime" }, { name: "logarithmic" }] }] }, { name: "legend", showToggle: true, propertyPath: ["chartOptions", "legend", "enabled"], options: [{ name: "align", propertyPath: ["chartOptions", "legend", "align"], type: "select", selectOptions: [{ name: "left" }, { name: "center" }, { name: "right" }] }] }, { name: "tooltip", showToggle: true, propertyPath: ["chartOptions", "tooltip", "enabled"], options: [{ name: "split", propertyPath: ["chartOptions", "tooltip", "split"], type: "toggle" }] }, { name: "dataLabels", propertyPath: ["chartOptions", "plotOptions", "series", "dataLabels", "enabled"], showToggle: true, options: [{ name: "align", propertyPath: ["chartOptions", "plotOptions", "series", "dataLabels", "align"], type: "select", selectOptions: [{ name: "left" }, { name: "center" }, { name: "right" }] }] }, { name: "credits", showToggle: true, propertyPath: ["chartOptions", "credits", "enabled"], options: [{ name: "name", propertyPath: ["chartOptions", "credits", "text"], type: "input" }, { name: "url", propertyPath: ["chartOptions", "credits", "href"], type: "input" }] }] }, { name: "chartConfig", propertyPath: ["chartOptions"], type: "textarea" }, { name: "chartClassName", propertyPath: ["chartClassName"], type: "input" }, { name: "chartID", propertyPath: ["chartID"], type: "input" }]), syncHandlers: e2, editableOptionsBindings: i(t2.defaultOptions.editableOptionsBindings, { skipRedraw: ["chartOptions", "chartConfig"] }) };
      }), s(e, "Dashboards/Components/HighchartsComponent/HighchartsComponent.js", [e["Dashboards/Components/Component.js"], e["Data/Converters/DataConverter.js"], e["Data/DataTable.js"], e["Dashboards/Globals.js"], e["Dashboards/Components/HighchartsComponent/HighchartsSyncHandlers.js"], e["Dashboards/Components/HighchartsComponent/HighchartsComponentDefaults.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i, o, n, r) {
        let { createElement: a, diffObjects: l, isString: h, merge: d, splat: c } = r;
        class u extends t2 {
          static fromJSON(t3, e3) {
            let s3 = new u(e3, d(t3.options, { chartOptions: JSON.parse(t3.options.chartOptions || "{}"), syncHandlers: u.syncHandlers }));
            return s3.emit({ type: "fromJSON", json: t3 }), s3;
          }
          constructor(t3, e3, s3) {
            super(t3, e3 = d(u.defaultOptions, e3), s3), this.seriesFromConnector = [], this.options = e3, this.chartConstructor = this.options.chartConstructor || "chart", this.type = "Highcharts", this.chartContainer = a("figure", void 0, void 0, this.contentElement, true), this.setOptions(), this.sync = new u.Sync(this, this.syncHandlers), this.chartOptions = d(this.options.chartOptions || { chart: {} }, { tooltip: {} }), this.connector && this.connector.on("afterLoad", (t4) => {
              t4.table && this.connector && this.connector.table.setColumns(t4.table.getColumns());
            }), this.innerResizeTimeouts = [];
          }
          onTableChanged() {
            this.updateSeries();
          }
          async load() {
            return this.emit({ type: "load" }), await super.load(), this.emit({ type: "afterLoad" }), this;
          }
          render() {
            return super.render(), this.chart = this.getChart(), this.updateSeries(), this.sync.start(), this.emit({ type: "afterRender" }), this.setupConnectorUpdate(), this;
          }
          resize(t3, e3) {
            for (super.resize(t3, e3); this.innerResizeTimeouts.length; ) {
              let t4 = this.innerResizeTimeouts.pop();
              t4 && clearTimeout(t4);
            }
            return this.innerResizeTimeouts.push(setTimeout(() => {
              var _a;
              if (this.chart && this.chart.container) {
                let t4 = this.contentElement.offsetHeight - ((_a = this.chart) == null ? void 0 : _a.container.offsetHeight);
                this.chart.setSize(null, Math.abs(t4) > 1 ? this.contentElement.offsetHeight : null, false);
              }
            }, 33)), this;
          }
          setupConnectorUpdate() {
            let { connector: t3, chart: e3 } = this;
            if (t3 && e3 && this.options.allowConnectorUpdate) {
              for (let s3 = 0, i2 = e3.series.length; s3 < i2; ++s3)
                e3.series[s3].update({ point: { events: { drag: (e4) => {
                  this.onChartUpdate(e4.target, t3);
                } } } }, false);
              e3.redraw();
            }
          }
          setOptions() {
            this.options.chartClassName && this.chartContainer.classList.add(this.options.chartClassName), this.options.chartID && (this.chartContainer.id = this.options.chartID);
          }
          onChartUpdate(t3, s3) {
            let i2 = s3.table, o2 = t3.series.name, n2 = t3.index, r2 = new e2().asNumber(t3.y);
            i2.setCell(o2, n2, r2);
          }
          async update(t3, e3 = true) {
            await super.update(t3, false), this.setOptions(), this.filterAndAssignSyncOptions(o), this.chart && this.chart.update(d(this.options.chartOptions) || {}), this.emit({ type: "afterUpdate" }), e3 && this.render();
          }
          updateSeries() {
            var _a, _b;
            let { chart: t3, connector: e3 } = this;
            if (!t3 || !e3)
              return;
            this.presentationModifier ? this.presentationTable = this.presentationModifier.modifyTable(e3.table.modified.clone()).modified : this.presentationTable = e3.table;
            let i2 = this.presentationTable.modified, o2 = (_a = this.presentationTable.getModifier()) == null ? void 0 : _a.options;
            this.emit({ type: "afterPresentationModifier", table: i2 });
            let n2 = i2.getColumnNames(), r2 = ((_b = this.options.connector) == null ? void 0 : _b.columnAssignment) ?? this.getDefaultColumnAssignment(n2);
            for (let e4 = 0, s3 = this.seriesFromConnector.length; e4 < s3; ++e4) {
              let s4 = this.seriesFromConnector[e4];
              if (r2.some((t4) => t4.seriesId === s4))
                continue;
              let i3 = t3.get(s4);
              i3 && i3.destroy();
            }
            this.seriesFromConnector.length = 0;
            for (let e4 = 0, n3 = r2.length; e4 < n3; ++e4) {
              let n4 = r2[e4], a2 = n4.data, l2 = t3.get(n4.seriesId), d2 = {}, c2 = (t4) => {
                var _a2;
                (o2 == null ? void 0 : o2.type) === "Math" && ((_a2 = o2.columnFormulas) == null ? void 0 : _a2.some((e5) => t4(e5.column))) && (d2.dragDrop = { draggableY: false });
              };
              if (h(a2)) {
                let t4 = i2.getColumn(a2);
                t4 && (d2.data = t4.slice()), c2((t5) => t5 === a2);
              } else if (Array.isArray(a2)) {
                let t4 = new s2({ columns: i2.getColumns(a2) });
                d2.data = t4.getRows(), c2((t5) => a2.some((e5) => e5 === t5));
              } else {
                let t4 = Object.keys(a2), e5 = [];
                for (let s3 = 0, i3 = t4.length; s3 < i3; ++s3)
                  e5.push(a2[t4[s3]]);
                let o3 = new s2({ columns: i2.getColumns(e5) });
                d2.keys = t4, d2.data = o3.getRows(), c2((t5) => e5.some((e6) => e6 === t5));
              }
              l2 ? l2.update(d2, false) : t3.addSeries({ name: n4.seriesId, id: n4.seriesId, ...d2 }, false), this.seriesFromConnector.push(n4.seriesId);
            }
            t3.redraw();
          }
          getChart() {
            return this.chart || this.createChart();
          }
          destroy() {
            var _a;
            (_a = this.chart) == null ? void 0 : _a.destroy(), super.destroy();
          }
          getDefaultColumnAssignment(t3 = []) {
            var _a;
            let e3 = [], s3 = (_a = this.presentationTable) == null ? void 0 : _a.getColumn(t3[0]);
            if (s3 && h(s3[0])) {
              for (let s4 = 1, i2 = t3.length; s4 < i2; ++s4)
                e3.push({ seriesId: t3[s4], data: [t3[0], t3[s4]] });
              return e3;
            }
            for (let s4 = 0, i2 = t3.length; s4 < i2; ++s4)
              e3.push({ seriesId: t3[s4], data: t3[s4] });
            return e3;
          }
          createChart() {
            let t3 = u.charter || i.win.Highcharts;
            this.chartConstructor || (this.chartConstructor = "chart");
            let e3 = t3[this.chartConstructor];
            if (e3)
              try {
                if ("chart" === this.chartConstructor)
                  return t3.Chart.chart(this.chartContainer, this.chartOptions);
                return new e3(this.chartContainer, this.chartOptions);
              } catch {
                throw Error("The Highcharts component is misconfigured: `" + this.cell.id + "`");
              }
            if ("function" != typeof t3.chart)
              throw Error("Chart constructor not found");
            return this.chart;
          }
          registerChartEvents() {
            if (this.chart && this.chart.options) {
              let t3 = this.chart.options;
              ["chart", "series", "yAxis", "xAxis", "colorAxis", "annotations", "navigation"].map((e3) => {
                let s3 = t3[e3] || {};
                return !Array.isArray(s3) && s3.events && (s3 = [s3]), s3 && "object" == typeof s3 && Array.isArray(s3) && s3.reduce((t4, s4, i2) => (s4 && s4.events && (t4[s4.id || `${e3}-${i2}`] = s4.events), t4), {}) || {};
              }).forEach((t4) => {
                Object.keys(t4).forEach((e3) => {
                  let s3 = t4[e3];
                  Object.keys(s3).forEach((t5) => {
                    this.callbackRegistry.addCallback(`${e3}-${t5}`, { type: "seriesEvent", func: s3[t5] });
                  });
                });
              });
            }
          }
          setConnector(t3) {
            var _a;
            let e3 = this.chart;
            if (this.connector && e3 && e3.series && this.connector.table.id !== (t3 == null ? void 0 : t3.table.id)) {
              let t4 = this.connector.table.id;
              for (let s3 = e3.series.length - 1; s3 >= 0; s3--) {
                let i2 = e3.series[s3];
                ((_a = i2.options.id) == null ? void 0 : _a.indexOf(t4)) !== -1 && i2.remove(false);
              }
            }
            return super.setConnector(t3), this;
          }
          getOptionsOnDrop(t3) {
            let e3 = t3.editMode.board.dataPool.getConnectorIds(), s3 = { cell: "", type: "Highcharts", chartOptions: { chart: { animation: false, type: "column", zooming: {} } } };
            return e3.length && (s3 = { ...s3, connector: { id: e3[0] } }), s3;
          }
          toJSON() {
            let t3 = JSON.stringify(this.options.chartOptions), e3 = this.options.chartConstructor || "chart";
            this.registerChartEvents();
            let s3 = super.toJSON(), i2 = { ...s3, type: "Highcharts", options: { ...s3.options, chartOptions: t3, chartConstructor: e3, type: "Highcharts", sync: {} } };
            return this.emit({ type: "toJSON", json: i2 }), i2;
          }
          getOptions() {
            return { ...l(this.options, u.defaultOptions), type: "Highcharts" };
          }
          getEditableOptions() {
            var _a;
            let t3 = this.options, e3 = this.chart, s3 = e3 && e3.options, i2 = s3 && ((_a = s3.chart) == null ? void 0 : _a.type) || "line";
            return d(t3, { chartOptions: s3 }, { chartOptions: { yAxis: c(e3 && e3.yAxis[0].options), xAxis: c(e3 && e3.xAxis[0].options), plotOptions: { series: (s3 && s3.plotOptions || {})[i2] } } });
          }
          getEditableOptionValue(t3) {
            return t3 ? 1 === t3.length && "chartOptions" === t3[0] ? JSON.stringify(this.options.chartOptions, null, 2) : super.getEditableOptionValue.call(this, t3) : void 0;
          }
        }
        return u.syncHandlers = o, u.defaultOptions = d(t2.defaultOptions, n), u;
      }), s(e, "Dashboards/Components/KPIComponent/KPISyncHandlers.js", [e["Core/Utilities.js"]], function(t2) {
        let { defined: e2 } = t2;
        return { extremes: { handler: { emitters: {}, handlers: { extremesHandler: function() {
          let { board: t3 } = this, s2 = (t4) => {
            let s3 = t4.cursor;
            if ("position" === s3.type && "number" == typeof (s3 == null ? void 0 : s3.row) && e2(s3.column) && this.connector && !e2(this.options.value)) {
              let t5 = this.connector.table.modified.getCellAsString(s3.column, s3.row);
              this.setValue(t5);
            }
          };
          if (t3)
            return (() => {
              let { dataCursor: e3 } = t3;
              if (!e3)
                return;
              let i = this.connector && this.connector.table;
              i && e3.addListener(i.id, "xAxis.extremes.max", s2);
            })(), () => {
              let e3 = this.connector && this.connector.table, { dataCursor: i } = t3;
              e3 && i.removeListener(e3.id, "xAxis.extremes.max", s2);
            };
        } } }.handlers.extremesHandler } };
      }), s(e, "Dashboards/Components/KPIComponent/KPIComponentDefaults.js", [e["Dashboards/Components/Component.js"], e["Dashboards/Components/KPIComponent/KPISyncHandlers.js"]], function(t2, e2) {
        return { type: "KPI", className: [t2.defaultOptions.className, `${t2.defaultOptions.className}-kpi`].join(" "), minFontSize: 20, syncHandlers: e2, thresholdColors: ["#f45b5b", "#90ed7d"], editableOptions: (t2.defaultOptions.editableOptions || []).concat([{ name: "Value", type: "input", propertyPath: ["value"] }, { name: "Column name", type: "input", propertyPath: ["columnName"] }, { name: "Value format", type: "input", propertyPath: ["valueFormat"] }]), linkedValueTo: { enabled: true, seriesIndex: 0, pointIndex: 0 } };
      }), s(e, "Core/Chart/ChartDefaults.js", [], function() {
        return { alignThresholds: false, panning: { enabled: false, type: "x" }, styledMode: false, borderRadius: 0, colorCount: 10, allowMutatingData: true, ignoreHiddenSeries: true, spacing: [10, 10, 15, 10], resetZoomButton: { theme: {}, position: {} }, reflow: true, type: "line", zooming: { singleTouch: false, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } }, width: null, height: null, borderColor: "#334eff", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" };
      }), s(e, "Core/Color/Palettes.js", [], function() {
        return { colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"] };
      }), s(e, "Core/Time.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { win: s2 } = t2, { defined: i, error: o, extend: n, isNumber: r, isObject: a, merge: l, objectEach: h, pad: d, pick: c, splat: u, timeUnits: p } = e2, m = t2.isSafari && s2.Intl && s2.Intl.DateTimeFormat.prototype.formatRange, f = t2.isSafari && s2.Intl && !s2.Intl.DateTimeFormat.prototype.formatRange;
        class g {
          constructor(t3) {
            this.options = {}, this.useUTC = false, this.variableTimezone = false, this.Date = s2.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(t3);
          }
          get(t3, e3) {
            if (this.variableTimezone || this.timezoneOffset) {
              let s3 = e3.getTime(), i2 = s3 - this.getTimezoneOffset(e3);
              e3.setTime(i2);
              let o2 = e3["getUTC" + t3]();
              return e3.setTime(s3), o2;
            }
            return this.useUTC ? e3["getUTC" + t3]() : e3["get" + t3]();
          }
          set(t3, e3, s3) {
            if (this.variableTimezone || this.timezoneOffset) {
              if ("Milliseconds" === t3 || "Seconds" === t3 || "Minutes" === t3 && this.getTimezoneOffset(e3) % 36e5 == 0)
                return e3["setUTC" + t3](s3);
              let i2 = this.getTimezoneOffset(e3), o2 = e3.getTime() - i2;
              e3.setTime(o2), e3["setUTC" + t3](s3);
              let n2 = this.getTimezoneOffset(e3);
              return o2 = e3.getTime() + n2, e3.setTime(o2);
            }
            return this.useUTC || m && "FullYear" === t3 ? e3["setUTC" + t3](s3) : e3["set" + t3](s3);
          }
          update(t3 = {}) {
            let e3 = c(t3.useUTC, true);
            this.options = t3 = l(true, this.options, t3), this.Date = t3.Date || s2.Date || Date, this.useUTC = e3, this.timezoneOffset = e3 && t3.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = e3 && !!(t3.getTimezoneOffset || t3.timezone);
          }
          makeTime(t3, e3, s3, i2, o2, n2) {
            let r2, a2, l2;
            return this.useUTC ? (r2 = this.Date.UTC.apply(0, arguments), a2 = this.getTimezoneOffset(r2), r2 += a2, a2 !== (l2 = this.getTimezoneOffset(r2)) ? r2 += l2 - a2 : a2 - 36e5 !== this.getTimezoneOffset(r2 - 36e5) || f || (r2 -= 36e5)) : r2 = new this.Date(t3, e3, c(s3, 1), c(i2, 0), c(o2, 0), c(n2, 0)).getTime(), r2;
          }
          timezoneOffsetFunction() {
            let t3 = this, e3 = this.options, s3 = e3.getTimezoneOffset;
            return this.useUTC ? e3.timezone ? (t4) => {
              try {
                let s4 = `shortOffset,${e3.timezone || ""}`, [i2, o2, n2, a2, l2 = 0] = (g.formatCache[s4] = g.formatCache[s4] || Intl.DateTimeFormat("en", { timeZone: e3.timezone, timeZoneName: "shortOffset" })).format(t4).split(/(GMT|:)/).map(Number), h2 = -(36e5 * (n2 + l2 / 60));
                if (r(h2))
                  return h2;
              } catch (t5) {
                o(34);
              }
              return 0;
            } : this.useUTC && s3 ? (t4) => 6e4 * s3(t4.valueOf()) : () => 6e4 * (t3.timezoneOffset || 0) : (t4) => 6e4 * new Date(t4.toString()).getTimezoneOffset();
          }
          dateFormat(e3, s3, o2) {
            if (!i(s3) || isNaN(s3))
              return t2.defaultOptions.lang && t2.defaultOptions.lang.invalidDate || "";
            e3 = c(e3, "%Y-%m-%d %H:%M:%S");
            let r2 = this, a2 = new this.Date(s3), l2 = this.get("Hours", a2), u2 = this.get("Day", a2), p2 = this.get("Date", a2), m2 = this.get("Month", a2), f2 = this.get("FullYear", a2), g2 = t2.defaultOptions.lang, y = g2 && g2.weekdays, b = g2 && g2.shortWeekdays;
            return h(n({ a: b ? b[u2] : y[u2].substr(0, 3), A: y[u2], d: d(p2), e: d(p2, 2, " "), w: u2, b: g2.shortMonths[m2], B: g2.months[m2], m: d(m2 + 1), o: m2 + 1, y: f2.toString().substr(2, 2), Y: f2, H: d(l2), k: l2, I: d(l2 % 12 || 12), l: l2 % 12 || 12, M: d(this.get("Minutes", a2)), p: l2 < 12 ? "AM" : "PM", P: l2 < 12 ? "am" : "pm", S: d(this.get("Seconds", a2)), L: d(Math.floor(s3 % 1e3), 3) }, t2.dateFormats), function(t3, i2) {
              for (; -1 !== e3.indexOf("%" + i2); )
                e3 = e3.replace("%" + i2, "function" == typeof t3 ? t3.call(r2, s3) : t3);
            }), o2 ? e3.substr(0, 1).toUpperCase() + e3.substr(1) : e3;
          }
          resolveDTLFormat(t3) {
            return a(t3, true) ? t3 : { main: (t3 = u(t3))[0], from: t3[1], to: t3[2] };
          }
          getTimeTicks(t3, e3, s3, o2) {
            let r2, a2, l2, h2;
            let d2 = this, u2 = d2.Date, m2 = [], f2 = {}, g2 = new u2(e3), y = t3.unitRange, b = t3.count || 1;
            if (o2 = c(o2, 1), i(e3)) {
              d2.set("Milliseconds", g2, y >= p.second ? 0 : b * Math.floor(d2.get("Milliseconds", g2) / b)), y >= p.second && d2.set("Seconds", g2, y >= p.minute ? 0 : b * Math.floor(d2.get("Seconds", g2) / b)), y >= p.minute && d2.set("Minutes", g2, y >= p.hour ? 0 : b * Math.floor(d2.get("Minutes", g2) / b)), y >= p.hour && d2.set("Hours", g2, y >= p.day ? 0 : b * Math.floor(d2.get("Hours", g2) / b)), y >= p.day && d2.set("Date", g2, y >= p.month ? 1 : Math.max(1, b * Math.floor(d2.get("Date", g2) / b))), y >= p.month && (d2.set("Month", g2, y >= p.year ? 0 : b * Math.floor(d2.get("Month", g2) / b)), a2 = d2.get("FullYear", g2)), y >= p.year && (a2 -= a2 % b, d2.set("FullYear", g2, a2)), y === p.week && (h2 = d2.get("Day", g2), d2.set("Date", g2, d2.get("Date", g2) - h2 + o2 + (h2 < o2 ? -7 : 0))), a2 = d2.get("FullYear", g2);
              let t4 = d2.get("Month", g2), n2 = d2.get("Date", g2), c2 = d2.get("Hours", g2);
              e3 = g2.getTime(), (d2.variableTimezone || !d2.useUTC) && i(s3) && (l2 = s3 - e3 > 4 * p.month || d2.getTimezoneOffset(e3) !== d2.getTimezoneOffset(s3));
              let u3 = g2.getTime();
              for (r2 = 1; u3 < s3; )
                m2.push(u3), y === p.year ? u3 = d2.makeTime(a2 + r2 * b, 0) : y === p.month ? u3 = d2.makeTime(a2, t4 + r2 * b) : l2 && (y === p.day || y === p.week) ? u3 = d2.makeTime(a2, t4, n2 + r2 * b * (y === p.day ? 1 : 7)) : l2 && y === p.hour && b > 1 ? u3 = d2.makeTime(a2, t4, n2, c2 + r2 * b) : u3 += y * b, r2++;
              m2.push(u3), y <= p.hour && m2.length < 1e4 && m2.forEach(function(t5) {
                t5 % 18e5 == 0 && "000000000" === d2.dateFormat("%H%M%S%L", t5) && (f2[t5] = "day");
              });
            }
            return m2.info = n(t3, { higherRanks: f2, totalRange: y * b }), m2;
          }
          getDateFormat(t3, e3, s3, i2) {
            let o2 = this.dateFormat("%m-%d %H:%M:%S.%L", e3), n2 = "01-01 00:00:00.000", r2 = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, a2 = "millisecond", l2 = a2;
            for (a2 in p) {
              if (t3 === p.week && +this.dateFormat("%w", e3) === s3 && o2.substr(6) === n2.substr(6)) {
                a2 = "week";
                break;
              }
              if (p[a2] > t3) {
                a2 = l2;
                break;
              }
              if (r2[a2] && o2.substr(r2[a2]) !== n2.substr(r2[a2]))
                break;
              "week" !== a2 && (l2 = a2);
            }
            return this.resolveDTLFormat(i2[a2]).main;
          }
        }
        return g.formatCache = {}, g;
      }), s(e, "Core/Defaults.js", [e["Core/Chart/ChartDefaults.js"], e["Core/Globals.js"], e["Core/Color/Palettes.js"], e["Core/Time.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i, o) {
        let { isTouchDevice: n, svg: r } = e2, { merge: a } = o, l = { colors: s2.colors, symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], decimalPoint: ".", numericSymbols: ["k", "M", "G", "T", "P", "E"], resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: {}, time: { Date: void 0, getTimezoneOffset: void 0, timezone: void 0, timezoneOffset: 0, useUTC: true }, chart: t2, title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "center", widthAdjust: -44 }, caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, legend: { enabled: true, align: "center", alignColumns: true, className: "highcharts-no-tooltip", layout: "horizontal", itemMarginBottom: 2, itemMarginTop: 2, labelFormatter: function() {
          return this.name;
        }, borderColor: "#999999", borderRadius: 0, navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" }, itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#666666", textDecoration: "line-through" }, shadow: false, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: true, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontSize: "0.8em", fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } }, tooltip: { enabled: true, animation: r, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %e %b, %H:%M:%S.%L", second: "%A, %e %b, %H:%M:%S", minute: "%A, %e %b, %H:%M", hour: "%A, %e %b, %H:%M", day: "%A, %e %b %Y", week: "Week from %A, %e %b %Y", month: "%B %Y", year: "%Y" }, footerFormat: "", headerShape: "callout", hideDelay: 500, padding: 8, shape: "callout", shared: false, snap: n ? 25 : 10, headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>', pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>', backgroundColor: "#ffffff", borderWidth: void 0, shadow: true, stickOnContact: false, style: { color: "#333333", cursor: "default", fontSize: "0.8em" }, useHTML: false }, credits: { enabled: true, href: "https://www.highcharts.com?credits", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" }, text: "Highcharts.com" } };
        l.chart.styledMode = false;
        let h = new i(l.time);
        return { defaultOptions: l, defaultTime: h, getOptions: function() {
          return l;
        }, setOptions: function(t3) {
          return a(true, l, t3), (t3.time || t3.global) && (e2.time ? e2.time.update(a(l.global, l.time, t3.global, t3.time)) : e2.time = h), l;
        } };
      }), s(e, "Core/Templating.js", [e["Core/Defaults.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { defaultOptions: s2, defaultTime: i } = t2, { extend: o, getNestedProperty: n, isArray: r, isNumber: a, isObject: l, pick: h, pInt: d } = e2, c = { add: (t3, e3) => t3 + e3, divide: (t3, e3) => 0 !== e3 ? t3 / e3 : "", eq: (t3, e3) => t3 == e3, each: function(t3) {
          let e3 = arguments[arguments.length - 1];
          return !!r(t3) && t3.map((s3, i2) => u(e3.body, o(l(s3) ? s3 : { "@this": s3 }, { "@index": i2, "@first": 0 === i2, "@last": i2 === t3.length - 1 }))).join("");
        }, ge: (t3, e3) => t3 >= e3, gt: (t3, e3) => t3 > e3, if: (t3) => !!t3, le: (t3, e3) => t3 <= e3, lt: (t3, e3) => t3 < e3, multiply: (t3, e3) => t3 * e3, ne: (t3, e3) => t3 != e3, subtract: (t3, e3) => t3 - e3, unless: (t3) => !t3 };
        function u(t3 = "", e3, o2) {
          let r2 = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g, a2 = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g, l2 = [], d2 = /f$/, m = /\.([0-9])/, f = s2.lang, g = o2 && o2.time || i, y = o2 && o2.numberFormatter || p, b = (t4 = "") => {
            let s3;
            return "true" === t4 || "false" !== t4 && ((s3 = Number(t4)).toString() === t4 ? s3 : n(t4, e3));
          }, C, w, O = 0, v;
          for (; null !== (C = r2.exec(t3)); ) {
            let s3 = a2.exec(C[1]);
            s3 && (C = s3, v = true), w && w.isBlock || (w = { ctx: e3, expression: C[1], find: C[0], isBlock: "#" === C[1].charAt(0), start: C.index, startInner: C.index + C[0].length, length: C[0].length });
            let i2 = C[1].split(" ")[0].replace("#", "");
            c[i2] && (w.isBlock && i2 === w.fn && O++, w.fn || (w.fn = i2));
            let o3 = "else" === C[1];
            if (w.isBlock && w.fn && (C[1] === `/${w.fn}` || o3)) {
              if (O)
                !o3 && O--;
              else {
                let e4 = w.startInner, s4 = t3.substr(e4, C.index - e4);
                void 0 === w.body ? (w.body = s4, w.startInner = C.index + C[0].length) : w.elseBody = s4, w.find += s4 + C[0], o3 || (l2.push(w), w = void 0);
              }
            } else
              w.isBlock || l2.push(w);
            if (s3 && !(w == null ? void 0 : w.isBlock))
              break;
          }
          return l2.forEach((s3) => {
            let i2, o3;
            let { body: n2, elseBody: r3, expression: a3, fn: l3 } = s3;
            if (l3) {
              let t4 = [s3], h2 = a3.split(" ");
              for (o3 = c[l3].length; o3--; )
                t4.unshift(b(h2[o3 + 1]));
              i2 = c[l3].apply(e3, t4), s3.isBlock && "boolean" == typeof i2 && (i2 = u(i2 ? n2 : r3, e3));
            } else {
              let t4 = a3.split(":");
              if (i2 = b(t4.shift() || ""), t4.length && "number" == typeof i2) {
                let e4 = t4.join(":");
                if (d2.test(e4)) {
                  let t5 = parseInt((e4.match(m) || ["", "-1"])[1], 10);
                  null !== i2 && (i2 = y(i2, t5, f.decimalPoint, e4.indexOf(",") > -1 ? f.thousandsSep : ""));
                } else
                  i2 = g.dateFormat(e4, i2);
              }
            }
            t3 = t3.replace(s3.find, h(i2, ""));
          }), v ? u(t3, e3, o2) : t3;
        }
        function p(t3, e3, i2, o2) {
          let n2, r2;
          t3 = +t3 || 0, e3 = +e3;
          let l2 = s2.lang, c2 = (t3.toString().split(".")[1] || "").split("e")[0].length, u2 = t3.toString().split("e"), p2 = e3;
          -1 === e3 ? e3 = Math.min(c2, 20) : a(e3) ? e3 && u2[1] && u2[1] < 0 && ((r2 = e3 + +u2[1]) >= 0 ? (u2[0] = (+u2[0]).toExponential(r2).split("e")[0], e3 = r2) : (u2[0] = u2[0].split(".")[0] || 0, t3 = e3 < 20 ? (u2[0] * Math.pow(10, u2[1])).toFixed(e3) : 0, u2[1] = 0)) : e3 = 2;
          let m = (Math.abs(u2[1] ? u2[0] : t3) + Math.pow(10, -Math.max(e3, c2) - 1)).toFixed(e3), f = String(d(m)), g = f.length > 3 ? f.length % 3 : 0;
          return i2 = h(i2, l2.decimalPoint), o2 = h(o2, l2.thousandsSep), n2 = (t3 < 0 ? "-" : "") + (g ? f.substr(0, g) + o2 : ""), 0 > +u2[1] && !p2 ? n2 = "0" : n2 += f.substr(g).replace(/(\d{3})(?=\d)/g, "$1" + o2), e3 && (n2 += i2 + m.slice(-e3)), u2[1] && 0 != +n2 && (n2 += "e" + u2[1]), n2;
        }
        return { dateFormat: function(t3, e3, s3) {
          return i.dateFormat(t3, e3, s3);
        }, format: u, helpers: c, numberFormat: p };
      }), s(e, "Dashboards/Components/KPIComponent/KPIComponent.js", [e["Core/Renderer/HTML/AST.js"], e["Dashboards/Components/Component.js"], e["Dashboards/Components/KPIComponent/KPISyncHandlers.js"], e["Dashboards/Components/KPIComponent/KPIComponentDefaults.js"], e["Core/Templating.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i, o, n) {
        let { format: r } = o, { createElement: a, css: l, defined: h, diffObjects: d, isArray: c, isNumber: u, merge: p } = n;
        class m extends e2 {
          static fromJSON(t3, e3) {
            let s3 = t3.options, i2 = s3.chartOptions && JSON.parse(s3.chartOptions), o2 = JSON.parse(s3.subtitle || "{}"), n2 = s3.title && JSON.parse(s3.title);
            return new m(e3, p(s3, { chartOptions: i2, title: n2, subtitle: o2 }));
          }
          constructor(t3, e3, s3) {
            super(t3, e3 = p(m.defaultOptions, e3), s3), this.options = e3, this.type = "KPI", this.sync = new m.Sync(this, this.syncHandlers), this.value = a("span", { className: `${e3.className}-value` }, {}, this.contentElement), this.subtitle = a("span", { className: this.getSubtitleClassName() }, {}, this.contentElement);
          }
          async load() {
            return await super.load(), this.linkValueToChart(), this;
          }
          resize(t3, e3) {
            return super.resize(t3, e3), this.chart && this.chart.container && this.chart.reflow(), this;
          }
          render() {
            var _a;
            super.render(), this.updateElements();
            let t3 = (_a = m.charter) == null ? void 0 : _a.Chart;
            return t3 && this.options.chartOptions && !this.chart ? (this.chartContainer || (this.chartContainer = a("div", { className: `${this.options.className}-chart-container` }, { padding: "0.1px" }, this.contentElement)), this.chart = t3.chart(this.chartContainer, p(m.defaultChartOptions, this.options.chartOptions))) : this.chart && !this.options.chartOptions && "chartOptions" in this.options && (this.chart.destroy(), this.chart = void 0), this.sync.start(), this.emit({ type: "afterRender" }), this;
          }
          setOptions() {
            this.filterAndAssignSyncOptions(s2);
          }
          async update(t3, e3 = true) {
            await super.update(t3), this.setOptions(), t3.chartOptions && this.chart && this.chart.update(t3.chartOptions), e3 && this.render();
          }
          onTableChanged() {
            this.setValue();
          }
          destroy() {
            var _a;
            (_a = this.chart) == null ? void 0 : _a.destroy(), super.destroy();
          }
          getValue() {
            var _a;
            if (h(this.options.value))
              return this.options.value;
            if (this.connector && this.options.columnName) {
              let t3 = (_a = this.connector) == null ? void 0 : _a.table.modified, e3 = t3.getColumn(this.options.columnName), s3 = (e3 == null ? void 0 : e3.length) || 0;
              return t3.getCellAsString(this.options.columnName, s3 - 1);
            }
          }
          setValue(e3 = this.getValue()) {
            let { valueFormat: s3, valueFormatter: i2 } = this.options;
            if (h(e3)) {
              let o2;
              u(+e3) && (o2 = +e3), i2 ? e3 = i2.call(this, e3) : s3 ? e3 = r(s3, { value: e3 }) : u(e3) && (e3 = e3.toLocaleString()), t2.setElementHTML(this.value, "" + e3), this.linkValueToChart(o2), this.prevValue = o2;
            }
          }
          linkValueToChart(t3 = this.getValue()) {
            let e3 = this.chart, s3 = this.options.linkedValueTo;
            if (!e3 || !s3.enabled || !h(t3) || !u(+t3))
              return;
            t3 = +t3;
            let i2 = e3.series[s3.seriesIndex ?? 0], o2 = i2 == null ? void 0 : i2.points[s3.pointIndex ?? 0];
            if (i2) {
              if (o2) {
                o2.update({ y: t3 });
                return;
              }
              i2.addPoint({ y: t3 });
              return;
            }
            e3.addSeries({ data: [{ y: t3 }] });
          }
          updateElements() {
            let { style: e3, subtitle: s3 } = this.options;
            this.setValue(), t2.setElementHTML(this.subtitle, this.getSubtitle()), e3 && l(this.element, e3), "object" == typeof s3 && (s3.style && l(this.subtitle, s3.style), this.subtitle.className = this.getSubtitleClassName()), this.chartContainer && (this.chartContainer.style.flex = this.options.chartOptions ? "1" : "0"), this.chart && this.chart.reflow(), this.value.style.color = this.getValueColor();
          }
          getSubtitle() {
            let { subtitle: t3, value: e3 } = this.options;
            if ("string" == typeof t3)
              return t3;
            if (t3) {
              if (u(this.prevValue) && u(e3)) {
                let s3 = e3 - this.prevValue, i2 = "";
                if (s3 > 0)
                  i2 = '<span style="color:green">&#9650;</span> +';
                else {
                  if (!(s3 < 0))
                    return this.subtitle.innerHTML;
                  i2 = '<span style="color:red">&#9660;</span> ';
                }
                if ("diff" === t3.type)
                  return i2 + s3.toLocaleString();
                if ("diffpercent" === t3.type)
                  return i2 + r("{v:,.2f}%", { v: s3 / this.prevValue * 100 });
              }
              return t3.text || "";
            }
            return "";
          }
          getSubtitleClassName() {
            let { subtitle: t3 } = this.options;
            return `${e2.defaultOptions.className}-subtitle` + ("object" == typeof t3 && t3.className || "");
          }
          getValueColor() {
            let { threshold: t3, thresholdColors: e3, value: s3 } = this.options;
            if (e3 && t3 && u(s3)) {
              if (c(t3)) {
                for (let i2 = t3.length - 1; i2 >= 0; i2--)
                  if (s3 >= t3[i2]) {
                    if (i2 + 1 < e3.length)
                      return e3[i2 + 1];
                    return e3[e3.length - 1];
                  }
              } else if (s3 >= t3)
                return e3[1];
              return e3[0];
            }
            return "";
          }
          getOptionsOnDrop(t3) {
            let e3 = t3.editMode.board.dataPool.getConnectorIds(), s3 = { cell: "", type: "KPI" };
            return e3.length && (s3 = { ...s3, connector: { id: e3[0] } }), s3;
          }
          toJSON() {
            let t3 = super.toJSON(), e3 = { ...t3, type: "KPI", options: { ...t3.options, type: "KPI", value: this.options.value, subtitle: JSON.stringify(this.options.subtitle), title: JSON.stringify(this.options.title), threshold: this.options.threshold, thresholdColors: this.options.thresholdColors, chartOptions: JSON.stringify(this.options.chartOptions), valueFormat: this.options.valueFormat } };
            return this.emit({ type: "toJSON", json: t3 }), e3;
          }
          getOptions() {
            return { ...d(this.options, m.defaultOptions), type: "KPI" };
          }
        }
        return m.defaultOptions = p(e2.defaultOptions, i), m.syncHandlers = s2, m.defaultChartOptions = { chart: { type: "spline", styledMode: true, zooming: { mouseWheel: { enabled: false } } }, title: { text: void 0 }, xAxis: { visible: false }, yAxis: { visible: false, title: { text: null } }, legend: { enabled: false }, credits: { enabled: false }, tooltip: { outside: true }, plotOptions: { series: { marker: { enabled: false } } } }, m;
      }), s(e, "Dashboards/Components/NavigatorComponent/NavigatorComponentDefaults.js", [e["Dashboards/Components/Component.js"]], function(t2) {
        return { type: "Navigator", chartOptions: { chart: { animation: false, height: 200, styledMode: true, type: "column", zooming: { mouseWheel: { enabled: false } } }, credits: { enabled: false }, legend: { enabled: false }, navigator: { enabled: true, outlineWidth: 0, series: { animation: false, lineWidth: 0 }, xAxis: { endOnTick: true, gridZIndex: 4, labels: { x: 1, y: 22 }, opposite: true, showFirstLabel: true, showLastLabel: true, startOnTick: true, tickPosition: "inside" }, yAxis: { maxPadding: 0.5 } }, plotOptions: { series: { borderRadius: 0, marker: { enabled: false }, states: { hover: { enabled: false } } } }, scrollbar: { enabled: true }, title: { text: "" }, tooltip: { enabled: false }, xAxis: { visible: false, minRange: Number.MIN_VALUE }, yAxis: { visible: false } }, editableOptions: (t2.defaultOptions.editableOptions || []).concat() };
      }), s(e, "Dashboards/Components/NavigatorComponent/NavigatorSyncHandlers.js", [e["Data/Modifiers/DataModifier.js"], e["Core/Utilities.js"]], function(t2, e2) {
        let { Range: s2 } = t2.types, { addEvent: i, pick: o } = e2, n = { handlers: { extremesHandler() {
          let t3 = this, e3 = t3.board.dataCursor, i2 = (e4) => {
            let i3 = e4.cursor;
            if (!t3.connector)
              return;
            let n2 = t3.connector.table, r = n2.getColumnNames()[0], a = n2.getRowCount(), l = 0;
            "range" === i3.type ? (a = i3.lastRow, l = i3.firstRow, i3.columns && (r = o(i3.columns[0], r))) : "xAxis.extremes.max" === i3.state ? (r = o(i3.column, r), a = o(i3.row, a)) : (r = o(i3.column, r), l = o(i3.row, l));
            let h = n2.getModifier();
            if ("string" == typeof r && h instanceof s2) {
              let t4 = h.options.ranges, e5 = n2.getCell(r, l), s3 = n2.getCell(r, a);
              null != s3 && null != e5 && (function(t5, e6) {
                for (let s4 = 0, i4 = t5.length; s4 < i4; ++s4)
                  if (t5[s4].column === e6)
                    return t5.splice(s4, 1)[0];
              }(t4, r), t4.unshift({ column: r, maxValue: s3, minValue: e5 }), n2.setModifier(h));
            }
          };
          return (() => {
            let s3 = t3.connector && t3.connector.table;
            s3 && (e3.addListener(s3.id, "xAxis.extremes", i2), e3.addListener(s3.id, "xAxis.extremes.max", i2), e3.addListener(s3.id, "xAxis.extremes.min", i2));
          })(), () => {
            let s3 = t3.connector && t3.connector.table;
            s3 && (e3.removeListener(s3.id, "xAxis.extremes", i2), e3.removeListener(s3.id, "xAxis.extremes.max", i2), e3.removeListener(s3.id, "xAxis.extremes.min", i2));
          };
        } }, emitters: { crossfilterEmitter() {
          let t3;
          let e3 = this, o2 = async (t4) => {
            if (e3.connector) {
              let i2 = e3.connector.table, o3 = e3.board.dataCursor, n2 = e3.getColumnAssignment()[0], [r, a] = e3.getAxisExtremes(), l = i2.getModifier();
              l instanceof s2 ? function(t5, e4, s3, i3) {
                let o4 = false;
                for (let n3 = 0, r2 = t5.length; n3 < r2; ++n3)
                  if (t5[n3].column === e4) {
                    t5[n3].maxValue = i3, t5[n3].minValue = s3, o4 = true;
                    break;
                  }
                o4 || t5.push({ column: e4, maxValue: i3, minValue: s3 });
              }(l.options.ranges, n2, r, a) : l = new s2({ ranges: [{ column: n2, maxValue: a, minValue: r }] }), await i2.setModifier(l), o3.emitCursor(i2, { type: "range", columns: [n2], firstRow: 0, lastRow: i2.getRowCount() - 1, state: "crossfilter" }, t4);
            }
          };
          return i(e3.chart.xAxis[0], "afterSetExtremes", function(e4) {
            clearTimeout(t3), t3 = setTimeout(o2, 50, this, e4);
          });
        }, extremesEmitter() {
          let t3;
          let e3 = this, s3 = (t4) => {
            if (e3.connector) {
              let s4 = e3.connector.table, i2 = e3.board.dataCursor, o2 = e3.getColumnAssignment()[0], [n2, r] = e3.getAxisExtremes();
              i2.emitCursor(s4, { type: "position", column: o2, row: s4.getRowIndexBy(o2, n2), state: "xAxis.extremes.min" }, t4), i2.emitCursor(s4, { type: "position", column: o2, row: s4.getRowIndexBy(o2, r), state: "xAxis.extremes.max" }, t4);
            }
          };
          return i(e3.chart.xAxis[0], "afterSetExtremes", function(e4) {
            clearTimeout(t3), t3 = setTimeout(s3, 50, this, e4);
          });
        } } };
        return { crossfilter: { emitter: n.emitters.crossfilterEmitter }, extremes: { emitter: n.emitters.extremesEmitter, handler: n.emitters.extremesHandler } };
      }), s(e, "Dashboards/Components/NavigatorComponent/NavigatorComponent.js", [e["Dashboards/Components/Component.js"], e["Dashboards/Globals.js"], e["Dashboards/Components/NavigatorComponent/NavigatorComponentDefaults.js"], e["Dashboards/Components/NavigatorComponent/NavigatorSyncHandlers.js"], e["Core/Utilities.js"]], function(t2, e2, s2, i, o) {
        let { diffObjects: n, isNumber: r, isString: a, merge: l, pick: h } = o;
        class d extends t2 {
          static fromJSON(t3, e3) {
            let s3 = new d(e3, t3.options);
            return s3.emit({ type: "fromJSON", json: t3 }), s3;
          }
          constructor(t3, s3) {
            var _a;
            super(t3, s3), this.options = l(d.defaultOptions, s3);
            let o2 = d.charter.Chart || e2.win.Highcharts;
            this.chartContainer = e2.win.document.createElement("div"), this.chart = o2.chart(this.chartContainer, this.options.chartOptions || {}), this.chartContainer.classList.add(e2.classNamePrefix + "navigator"), this.filterAndAssignSyncOptions(i), this.sync = new d.Sync(this, this.syncHandlers), ((_a = this.sync.syncConfig.crossfilter) == null ? void 0 : _a.enabled) && this.chart.update(l({ navigator: { xAxis: { labels: { format: "{value}" } } } }, this.options.chartOptions || {}), false);
          }
          adjustNavigator() {
            let t3 = this.chart, e3 = h(t3.chartHeight, this.contentElement.clientHeight), s3 = this.contentElement.clientWidth, i2 = {};
            if ((t3.chartHeight !== e3 || t3.chartWidth !== s3) && (i2.chart = { height: e3, width: s3 }), t3.navigator) {
              let s4 = t3.navigator, o2 = s4.top - t3.plotTop + s4.height;
              s4.height !== o2 && (i2.navigator = { handles: { height: Math.round(e3 / 4) }, height: o2 }), Object.keys(i2).length && t3.update(i2, false), s4.series && s4.series[0] && s4.series[0].update({ type: t3.series[0].type }, false);
            } else
              Object.keys(i2).length && t3.update(i2, false);
          }
          getColumnAssignment() {
            let t3;
            let e3 = this.options.columnAssignments || {};
            for (let s3 of Object.keys(e3))
              if (null !== (t3 = e3[s3]))
                return [s3, t3];
            if (this.connector) {
              let t4 = this.connector.table.getColumnNames();
              if (t4.length)
                return [t4[0], "y"];
            }
            return ["", "y"];
          }
          getOptions() {
            return { ...n(this.options, s2), type: "Navigator" };
          }
          getAxisExtremes() {
            let t3 = this.chart.xAxis[0], e3 = t3.getExtremes(), s3 = r(e3.min) ? e3.min : e3.dataMin, i2 = r(e3.max) ? e3.max : e3.dataMax;
            return this.categories ? [this.categories[Math.max(0, Math.ceil(s3))], this.categories[Math.min(this.categories.length - 1, Math.floor(i2))]] : t3.hasNames ? [t3.names[Math.ceil(s3)], t3.names[Math.floor(i2)]] : [s3, i2];
          }
          async load() {
            return await super.load(), this.contentElement.appendChild(this.chartContainer), this.parentElement.appendChild(this.element), this.adjustNavigator(), this.emit({ type: "afterLoad" }), this;
          }
          onTableChanged() {
            this.renderNavigator();
          }
          redrawNavigator() {
            let t3 = this.resizeTimeouts;
            for (let e3 = 0, s3 = t3.length; e3 < s3; ++e3)
              clearTimeout(t3[e3]);
            t3.length = 0, t3.push(setTimeout(() => {
              this.adjustNavigator(), this.chart.redraw();
            }, 33));
          }
          render() {
            return super.render(), this.renderNavigator(), this.sync.start(), this.emit({ type: "afterRender" }), this;
          }
          renderNavigator() {
            var _a;
            let t3 = this.chart;
            if (this.connector) {
              let e3;
              let s3 = this.connector.table, i2 = this.getColumnAssignment(), o2 = s3.getColumn(i2[0], true) || [];
              e3 = ((_a = this.sync.syncConfig.crossfilter) == null ? void 0 : _a.enabled) ? this.generateCrossfilterData() : o2.slice(), t3.series[0] ? t3.series[0].setData(e3, false) : t3.addSeries({ id: s3.id, data: e3 }, false);
            }
            this.redrawNavigator();
          }
          generateCrossfilterData() {
            var _a, _b;
            let t3;
            let e3 = this.sync.syncConfig.crossfilter, s3 = (_a = this.connector) == null ? void 0 : _a.table, i2 = (s3 == null ? void 0 : s3.getColumn(this.getColumnAssignment()[0], true)) || [];
            if (!s3 || i2.length < 1 || !e3)
              return [];
            let o2 = [], n2 = [];
            for (let t4 = 0, e4 = i2.length; t4 < e4; t4++) {
              let e5 = i2[t4];
              if (null !== e5) {
                if (r(e5) || (e5 = `${e5}`), void 0 === this.stringData)
                  this.stringData = a(e5);
                else if (this.stringData !== a(e5))
                  throw Error("Mixed data types in crossfilter navigator are not supported.");
                o2.push(e5), -1 === n2.indexOf(e5) && n2.push(e5);
              }
            }
            n2.sort((t4, e4) => h(t4, NaN) < h(e4, NaN) ? -1 : t4 === e4 ? 0 : 1);
            let l2 = (_b = s3.getModifier()) == null ? void 0 : _b.options;
            if (e3.affectNavigator && l2) {
              let e4 = [], i3 = [], { ranges: n3 } = l2;
              for (let t4 = 0, o3 = n3.length; t4 < o3; t4++)
                n3[t4].column !== this.getColumnAssignment()[0] && (e4.push(n3[t4]), i3.push(s3.getColumn(n3[t4].column, true) || []));
              t3 = [];
              let r2 = e4.length;
              for (let s4 = 0, n4 = o2.length; s4 < n4; s4++) {
                let n5 = o2[s4], a2 = true;
                for (let t4 = 0; t4 < r2; t4++) {
                  let o3 = e4[t4];
                  if (!(i3[t4][s4] >= (o3.minValue ?? -1 / 0) && i3[t4][s4] <= (o3.maxValue ?? 1 / 0))) {
                    a2 = false;
                    break;
                  }
                }
                a2 && t3.push(n5);
              }
            } else
              t3 = o2;
            let d2 = [];
            if (this.stringData) {
              this.categories = n2;
              for (let t4 = 0, e4 = n2.length; t4 < e4; t4++)
                d2.push([t4, null]);
            } else
              for (let t4 = 0, e4 = n2.length; t4 < e4; t4++)
                d2.push([n2[t4], null]);
            for (let e4 = 0, s4 = t3.length; e4 < s4; e4++) {
              let s5 = n2.indexOf(t3[e4]);
              d2[s5][1] = (d2[s5][1] || 0) + 1;
            }
            return d2;
          }
          resize(t3, e3) {
            return super.resize(t3, e3), this.redrawNavigator(), this;
          }
          async update(t3, e3 = true) {
            var _a;
            let s3 = this.chart;
            await super.update(t3, false), t3.sync && this.filterAndAssignSyncOptions(i), t3.chartOptions && s3.update(l(((_a = this.sync.syncConfig.crossfilter) == null ? void 0 : _a.enabled) ? { navigator: { xAxis: { labels: { format: "{value}" } } } } : {}, t3.chartOptions), false), this.emit({ type: "afterUpdate" }), e3 && this.render();
          }
          getOptionsOnDrop(t3) {
            return {};
          }
        }
        return d.defaultOptions = l(t2.defaultOptions, s2), d;
      }), s(e, "Dashboards/Plugins/HighchartsPlugin.js", [e["Dashboards/Components/HighchartsComponent/HighchartsComponent.js"], e["Dashboards/Components/HighchartsComponent/HighchartsSyncHandlers.js"], e["Dashboards/Components/KPIComponent/KPIComponent.js"], e["Dashboards/Components/NavigatorComponent/NavigatorComponent.js"]], function(t2, e2, s2, i) {
        return { custom: { connectHighcharts: function(e3) {
          t2.charter = e3, s2.charter = e3, i.charter = e3;
        } }, name: "Highcharts.DashboardsPlugin", onRegister: function(o) {
          let { Sync: n, ComponentRegistry: r } = o;
          r.registerComponent("Highcharts", t2), r.registerComponent("KPI", s2), r.registerComponent("Navigator", i), n.defaultHandlers = { ...n.defaultHandlers, ...e2 };
        }, onUnregister: function(t3) {
          let { Sync: s3 } = t3;
          Object.keys(e2).forEach((t4) => {
            s3.defaultHandlers[t4] === e2[t4] && delete s3.defaultHandlers[t4];
          });
        } };
      }), s(e, "Dashboards/PluginHandler.js", [e["Dashboards/Board.js"], e["Dashboards/Components/Sync/Sync.js"], e["Dashboards/Components/ComponentRegistry.js"]], function(t2, e2, s2) {
        var i, o;
        return (o = i || (i = {})).registry = {}, o.revision = 0, o.addPlugin = function(i2, n = i2.name) {
          let { maxRevision: r, minRevision: a, onRegister: l } = i2;
          if (o.registry[n]) {
            if (n !== i2.name)
              throw Error(`Plugin '${n}' already registered.`);
            return;
          }
          if ("number" == typeof a && a > o.revision || "number" == typeof r && r < o.revision)
            throw Error(`Plugin '${n}' does not support revision ${o.revision}.`);
          l({ Board: t2, ComponentRegistry: s2, Sync: e2, revision: o.revision }), o.registry[n] = i2;
        }, o.removePlugin = function(i2) {
          o.registry[i2] && (o.registry[i2].onUnregister({ ComponentRegistry: s2, Board: t2, Sync: e2, revision: o.revision }), delete o.registry[i2]);
        }, i;
      }), s(e, "masters/dashboards.src.js", [e["Core/Renderer/HTML/AST.js"], e["Data/Connectors/DataConnector.js"], e["Dashboards/Board.js"], e["Dashboards/Components/Component.js"], e["Dashboards/Components/ComponentRegistry.js"], e["Data/DataPool.js"], e["Data/DataCursor.js"], e["Data/Modifiers/DataModifier.js"], e["Data/DataTable.js"], e["Dashboards/Globals.js"], e["Dashboards/Plugins/DataGridPlugin.js"], e["Dashboards/Plugins/HighchartsPlugin.js"], e["Dashboards/PluginHandler.js"], e["Dashboards/Components/Sync/Sync.js"], e["Dashboards/Utilities.js"]], function(t2, e2, s2, i, o, n, r, a, l, h, d, c, u, p, m) {
        return h.board = s2.board, h.error = m.error, h.merge = m.merge, h.uniqueKey = m.uniqueKey, h.AST = t2, h.Board = s2, h.Component = i, h.ComponentRegistry = o, h.DataConnector = e2, h.DataCursor = r, h.DataModifier = a, h.DataPool = n, h.DataTable = l, h.DataGridPlugin = d, h.HighchartsPlugin = c, h.PluginHandler = u, h.Sync = p, h.win.Dashboards || (h.win.Dashboards = h), h.win.DataGrid && (d.custom.connectDataGrid(h.win.DataGrid), h.PluginHandler.addPlugin(d)), h.win.Highcharts && (c.custom.connectHighcharts(h.win.Highcharts), h.PluginHandler.addPlugin(c)), h;
      }), e["masters/dashboards.src.js"]._modules = e, e["masters/dashboards.src.js"];
    });
  }
});
export default require_dashboards();
//# sourceMappingURL=@highcharts_dashboards.js.map
