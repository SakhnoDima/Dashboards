import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/public-google-sheets-parser/src/fetch.js
var require_fetch = __commonJS({
  "node_modules/public-google-sheets-parser/src/fetch.js"(exports, module) {
    var https = require_https();
    var nodeFetch = async (url) => {
      return new Promise((resolve, reject) => {
        const req = https.request(url, (res) => {
          const body = [];
          let isStarted = false;
          res.on("data", (chunk) => {
            if (!isStarted && !String(chunk).startsWith("/*O_o*/"))
              return resolve(null);
            isStarted = true;
            body.push(chunk);
          });
          res.on("end", () => {
            const response = { ok: true, text: () => Buffer.concat(body).toString() };
            resolve(response);
          });
        });
        req.on("error", reject);
        req.end();
      });
    };
    module.exports = nodeFetch;
    module.exports.default = nodeFetch;
  }
});

// node_modules/public-google-sheets-parser/src/index.js
var require_src = __commonJS({
  "node_modules/public-google-sheets-parser/src/index.js"(exports, module) {
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    var fetch = isBrowser ? (
      /* istanbul ignore next */
      window.fetch
    ) : require_fetch();
    var PublicGoogleSheetsParser = class {
      constructor(spreadsheetId, option) {
        this.id = spreadsheetId;
        this.setOption(option);
      }
      setOption(option) {
        if (!option) {
          this.sheetName = this.sheetName || null;
          this.sheetId = this.sheetId || null;
          this.useFormattedDate = this.useFormattedDate || false;
          this.useFormat = this.useFormat || false;
        } else if (typeof option === "string") {
          this.sheetName = option;
          this.sheetId = this.sheetId || null;
        } else if (typeof option === "object") {
          this.sheetName = option.sheetName || this.sheetName;
          this.sheetId = option.sheetId || this.sheetId;
          this.useFormattedDate = option.hasOwnProperty("useFormattedDate") ? option.useFormattedDate : this.useFormattedDate;
          this.useFormat = option.hasOwnProperty("useFormat") ? option.useFormat : this.useFormat;
        }
      }
      isDate(date) {
        return date && typeof date === "string" && /Date\((\d+),(\d+),(\d+)\)/.test(date);
      }
      async getSpreadsheetDataUsingFetch() {
        if (!this.id)
          return null;
        let url = `https://docs.google.com/spreadsheets/d/${this.id}/gviz/tq?`;
        url += this.sheetId ? `gid=${this.sheetId}` : `sheet=${this.sheetName}`;
        try {
          const response = await fetch(url);
          return response && response.ok ? response.text() : null;
        } catch (e) {
          console.error("Error fetching spreadsheet data:", e);
          return null;
        }
      }
      normalizeRow(rows) {
        return rows.map((row) => row && (row.v !== null && row.v !== void 0) ? row : {});
      }
      applyHeaderIntoRows(header, rows) {
        return rows.map(({ c: row }) => this.normalizeRow(row)).map((row) => row.reduce((p, c, i) => c.v !== null && c.v !== void 0 ? Object.assign(p, { [header[i]]: this.useFormat ? c.f || c.v : this.useFormattedDate && this.isDate(c.v) ? c.f || c.v : c.v }) : p, {}));
      }
      getItems(spreadsheetResponse) {
        let rows = [];
        try {
          const payloadExtractRegex = /google\.visualization\.Query\.setResponse\(({.*})\);/;
          const [_, payload] = spreadsheetResponse.match(payloadExtractRegex);
          const parsedJSON = JSON.parse(payload);
          const hasSomeLabelPropertyInCols = parsedJSON.table.cols.some(({ label }) => !!label);
          if (hasSomeLabelPropertyInCols) {
            const header = parsedJSON.table.cols.map(({ label }) => label);
            rows = this.applyHeaderIntoRows(header, parsedJSON.table.rows);
          } else {
            const [headerRow, ...originalRows] = parsedJSON.table.rows;
            const header = this.normalizeRow(headerRow.c).map((row) => row.v);
            rows = this.applyHeaderIntoRows(header, originalRows);
          }
        } catch (e) {
          console.error("Error parsing spreadsheet data:", e);
        }
        return rows;
      }
      async parse(spreadsheetId, option) {
        if (spreadsheetId)
          this.id = spreadsheetId;
        if (option)
          this.setOption(option);
        if (!this.id)
          throw new Error("SpreadsheetId is required.");
        const spreadsheetResponse = await this.getSpreadsheetDataUsingFetch();
        if (spreadsheetResponse === null)
          return [];
        return this.getItems(spreadsheetResponse);
      }
    };
    if (isBrowser && typeof module === "undefined") {
      window.PublicGoogleSheetsParser = PublicGoogleSheetsParser;
    } else {
      module.exports = PublicGoogleSheetsParser;
      module.exports.default = PublicGoogleSheetsParser;
    }
  }
});
export default require_src();
//# sourceMappingURL=public-google-sheets-parser.js.map
